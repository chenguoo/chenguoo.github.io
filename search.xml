<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL优化最干货总结笔记</title>
      <link href="2021/06/18/sql-you-hua-zui-gan-huo-zong-jie-bi-ji/"/>
      <url>2021/06/18/sql-you-hua-zui-gan-huo-zong-jie-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL优化最干货总结笔记"><a href="#SQL优化最干货总结笔记" class="headerlink" title="SQL优化最干货总结笔记"></a>SQL优化最干货总结笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网上关于SQL优化的教程很多，但是比较杂乱。而且百度字节等大厂的面试难度越来越高，无论从大厂还是到小公司，一直未变的一个重点就是对SQL优化经验的考察。一提到数据库，先“说一说你对SQL优化的见解吧？”。SQL优化已经成为衡量程序猿优秀与否的硬性指标，甚至在各大厂招聘岗位职能上都有明码标注，所以近日有空我专门花费了大量的时间查找资料、修改、排版，希望能够帮助到有需要的朋友，<strong>感觉好的话推荐给更多的人，让更多的人看到、纠正以及补充。</strong></p><p><img src="/2021/06/18/sql-you-hua-zui-gan-huo-zong-jie-bi-ji/22306b966b5b470585d2c751cff2e472" alt="字节总监GitHub21k的SQL优化最干货总结笔记！不吃透都对不起他"></p><p>有朋友疑问到，SQL优化真的有这么重要么？如下图所示，SQL优化在提升系统性能中是：（成本最低 &amp;&amp; 优化效果最明显） 的途径。如果你的团队在SQL优化这方面搞得很优秀，对你们整个大型系统可用性方面无疑是一个质的跨越，真的能让你们老板省下不止几沓子钱。</p><p><img src="/2021/06/18/sql-you-hua-zui-gan-huo-zong-jie-bi-ji/8e63a028c54e45fab56970f18b2d8648" alt="字节总监GitHub21k的SQL优化最干货总结笔记！不吃透都对不起他"></p><ul><li>优化成本：硬件&gt;系统配置&gt;数据库表结构&gt;SQL及索引。</li><li>优化效果：硬件&lt;系统配置&lt;数据库表结构&lt;SQL及索引。</li></ul><pre><code>String result = "嗯，不错，";if ("SQL优化经验足") {    if ("熟悉事务锁") {        if ("并发场景处理666") {            if ("会打王者荣耀") {                result += "明天入职"             }        }    }} else {    result += "先回去等消息吧";} Logger.info("面试官：" + result );</code></pre><p>别看了，上面这是一道送命题。</p><p><img src="/2021/06/18/sql-you-hua-zui-gan-huo-zong-jie-bi-ji/29ae5a2c74304f9aabde56f13a89296a" alt="字节总监GitHub21k的SQL优化最干货总结笔记！不吃透都对不起他"></p><p>好了我们言归正传，首先，对于MySQL层优化我一般遵从五个原则：</p><ul><li>减少数据访问： 设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO</li><li>返回更少的数据： 只返回需要的字段和数据分页处理 减少磁盘io及网络io</li><li>减少交互次数： 批量DML操作，函数存储等减少数据连接次数</li><li>减少服务器CPU开销： 尽量减少数据库排序操作以及全表查询，减少cpu 内存占用</li><li>利用更多资源： 使用表分区，可以增加并行操作，更大限度利用cpu资源</li></ul><p>总结到SQL优化中，就三点:</p><ul><li>最大化利用索引；</li><li>尽可能避免全表扫描；</li><li>减少无效数据的查询；</li></ul><p>理解SQL优化原理 ，首先要搞清楚SQL执行顺序：</p><h2 id="SELECT语句-语法顺序："><a href="#SELECT语句-语法顺序：" class="headerlink" title="SELECT语句 - 语法顺序："></a>SELECT语句 - 语法顺序：</h2><pre><code>1. SELECT 2. DISTINCT &lt;select_list&gt;3. FROM &lt;left_table&gt;4. &lt;join_type&gt; JOIN &lt;right_table&gt;5. ON &lt;join_condition&gt;6. WHERE &lt;where_condition&gt;7. GROUP BY &lt;group_by_list&gt;8. HAVING &lt;having_condition&gt;9. ORDER BY &lt;order_by_condition&gt;10.LIMIT &lt;limit_number&gt;</code></pre><p>SELECT语句 - 执行顺序：</p><pre><code>FROM&lt;表名&gt; # 选取表，将多个表数据通过笛卡尔积变成一个表。ON&lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选JOIN &lt;join, left join, right join...&gt; &lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中WHERE&lt;where条件&gt; # 对上述虚表进行筛选GROUP BY&lt;分组条件&gt; # 分组&lt;SUM()等聚合函数&gt; # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的HAVING&lt;分组筛选&gt; # 对分组后的结果进行聚合筛选SELECT&lt;返回数据列表&gt; # 返回的单列必须在group by子句中，聚合函数除外DISTINCT# 数据除重ORDER BY&lt;排序条件&gt; # 排序LIMIT&lt;行数限制&gt;</code></pre><h2 id="SQL优化策略"><a href="#SQL优化策略" class="headerlink" title="SQL优化策略"></a>SQL优化策略</h2><p><strong>声明：以下SQL优化策略适用于数据量较大的场景下，如果数据量较小，没必要以此为准，以免画蛇添足。</strong></p><h3 id="一、建表优化"><a href="#一、建表优化" class="headerlink" title="一、建表优化"></a>一、建表优化</h3><ol><li>在表中建立索引，优先考虑where、order by使用到的字段。</li><li>尽量使用数字型字段（如性别，男：1 女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。<br>这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</li><li>查询数据量大的表 会造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示。要查询100000到100050的数据，如下：</li></ol><pre><code>SELECT * FROM (SELECT ROW_NUMBER() OVER(ORDER BY ID ASC) AS rowid,*    FROM infoTab)t WHERE t.rowid &gt; 100000 AND t.rowid &lt;= 100050</code></pre><ol><li>用varchar/nvarchar 代替 char/nchar</li></ol><p>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。<br>不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。</p><h3 id="二、增删改-DML-语句优化"><a href="#二、增删改-DML-语句优化" class="headerlink" title="二、增删改 DML 语句优化"></a>二、增删改 DML 语句优化</h3><ol><li>大批量插入数据</li></ol><p>如果同时执行大量的插入，建议使用多个值的INSERT语句(方法二)。这比使用分开INSERT语句快（方法一），一般情况下批量插入效率有几倍的差别。</p><p>方法一：</p><pre><code>insert into T values(1,2); insert into T values(1,3); insert into T values(1,4);</code></pre><p>方法二：</p><pre><code>Insert into T values(1,2),(1,3),(1,4); </code></pre><p>选择后一种方法的原因有三。</p><ul><li>减少SQL语句解析的操作，MySQL没有类似Oracle的share pool，采用方法二，只需要解析一次就能进行数据的插入操作；</li><li>在特定场景可以减少对DB连接次数</li><li>SQL语句较短，可以减少网络传输的IO。</li></ul><ol><li>适当使用commit</li></ol><p>适当使用commit可以释放事务占用的资源而减少消耗，commit后能释放的资源如下：</p><ul><li>事务占用的undo数据块；</li><li>事务在redo log中记录的数据块；</li><li>释放事务施加的，减少锁争用影响性能。特别是在需要使用delete删除大量数据的时候，必须分解删除量并定期commit。</li></ul><ol><li>避免重复查询更新的数据</li></ol><p>针对业务中经常出现的更新行同时又希望获得改行信息的需求，MySQL并不支持PostgreSQL那样的UPDATE RETURNING语法，在MySQL中可以通过变量实现。</p><p>例如，更新一行记录的时间戳，同时希望查询当前记录中存放的时间戳是什么，简单方法实现：</p><pre><code>Update t1 set time=now() where col1=1; Select time from t1 where id =1; </code></pre><p>使用变量，可以重写为以下方式：</p><pre><code>Update t1 set time=now () where col1=1 and @now: = now (); Select @now; </code></pre><p>前后二者都需要两次网络来回，但使用变量避免了再次访问数据表，特别是当t1表数据量较大时，后者比前者快很多。</p><p>4.查询优先还是更新（insert、update、delete）优先</p><p>MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。下面我们提到的改变调度策略的方法主要是针对只存在表锁的存储引擎，比如 MyISAM 、MEMROY、MERGE，对于Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。MySQL 的默认的调度策略可用总结如下：</p><p>1）写入操作优先于读取操作。</p><p>2）对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。</p><p>3）对某张数据表的多个读取操作可以同时地进行。MySQL 提供了几个语句调节符，允许你修改它的调度策略：</p><ul><li>LOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE；</li><li>HIGH_PRIORITY关键字应用于SELECT和INSERT语句；</li><li>DELAYED关键字应用于INSERT和REPLACE语句。</li></ul><p>如果写入操作是一个 LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在 LOW_PRIORITY写入操作永远被阻塞的情况。</p><p>SELECT 查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的 SELECT 在正常的 SELECT 语句之前执行，因为这些语句会被写入操作阻塞。如果希望所有支持LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么 请使用–low-priority-updates 选项来启动服务器。通过使用 INSERTHIGH_PRIORITY 来把 INSERT 语句提高到正常的写入优先级，可以消除该选项对单个INSERT语句的影响。</p><h3 id="三、避免不走索引的场景"><a href="#三、避免不走索引的场景" class="headerlink" title="三、避免不走索引的场景"></a>三、避免不走索引的场景</h3><ol><li>尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。如下：</li></ol><pre><code>SELECT * FROM t WHERE username LIKE '%陈%'</code></pre><p>优化方式：尽量在字段后面使用模糊查询。如下：</p><pre><code>SELECT * FROM t WHERE username LIKE '陈%'</code></pre><p>如果需求是要在前面使用模糊查询，</p><ul><li>使用MySQL内置函数INSTR(str,substr) 来匹配，作用类似于java中的indexOf()，查询字符串出现的角标位置，可参阅《MySQL模糊查询用法大全（正则、通配符、内置函数等）》</li><li>使用FullText全文索引，用match against 检索</li><li>数据量较大的情况，建议引用ElasticSearch、solr，亿级数据量检索速度秒级</li><li>当表数据量较少（几千条儿那种），别整花里胡哨的，直接用like ‘%xx%’。</li></ul><ol><li>尽量避免使用in 和not in，会导致引擎走全表扫描。如下：</li></ol><pre><code>SELECT * FROM t WHERE id IN (2,3)</code></pre><p>优化方式：如果是连续数值，可以用between代替。如下：</p><pre><code>SELECT * FROM t WHERE id BETWEEN 2 AND 3</code></pre><p>如果是子查询，可以用exists代替。详情见《MySql中如何用exists代替in》如下：</p><pre><code>-- 不走索引select * from A where A.id in (select id from B);-- 走索引select * from A where exists (select * from B where B.id = A.id);</code></pre><ol><li>尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。如下：</li></ol><pre><code>SELECT * FROM t WHERE id = 1 OR id = 3</code></pre><p>优化方式：可以用union代替or。如下：</p><pre><code>SELECT * FROM t WHERE id = 1   UNIONSELECT * FROM t WHERE id = 3</code></pre><ol><li>尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下：</li></ol><pre><code>SELECT * FROM t WHERE score IS NULL</code></pre><p>优化方式：可以给字段添加默认值0，对0值进行判断。如下：</p><pre><code>SELECT * FROM t WHERE score = 0</code></pre><p>5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。</p><p>可以将表达式、函数操作移动到等号右侧。如下：</p><pre><code>-- 全表扫描SELECT * FROM T WHERE score/10 = 9-- 走索引SELECT * FROM T WHERE score = 10*9</code></pre><ol><li>当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：</li></ol><pre><code>SELECT username, age, sex FROM T WHERE 1=1</code></pre><p>优化方式：用代码拼装sql时进行判断，没 where 条件就去掉 where，有where条件就加 and。</p><ol><li>查询条件不能用 &lt;&gt; 或者 !=</li></ol><p>使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。</p><ol><li>where条件仅包含复合索引非前置列</li></ol><p>如下：复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列”key_part1”，按照MySQL联合索引的最左匹配原则，不会走联合索引。</p><pre><code>select col1 from table where key_part2=1 and key_part3=2</code></pre><ol><li>隐式类型转换造成不使用索引</li></ol><p>如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。</p><pre><code>select col1 from table where col_varchar=123; </code></pre><ol><li>order by 条件要与where中条件一致，否则order by不会利用索引进行排序</li></ol><pre><code>-- 不走age索引SELECT * FROM t order by age;-- 走age索引SELECT * FROM t where age &gt; 0 order by age;</code></pre><p>对于上面的语句，数据库的处理顺序是：</p><ul><li>第一步：根据where条件和统计信息生成执行计划，得到数据。</li><li>第二步：将得到的数据排序。当执行处理数据（order by）时，数据库会先查看第一步的执行计划，看order by 的字段是否在执行计划中利用了索引。如果是，则可以利用索引顺序而直接取得已经排好序的数据。如果不是，则重新进行排序操作。</li><li>第三步：返回排序后的数据。<br>当order by 中的字段出现在where条件中时，才会利用索引而不再二次排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作。</li></ul><p>这个结论不仅对order by有效，对其他需要排序的操作也有效。比如group by 、union 、distinct等。</p><ol><li>正确使用hint优化语句</li></ol><p>MySQL中可以使用hint指定优化器在执行时选择或忽略特定的索引。一般而言，处于版本变更带来的表结构索引变化，更建议避免使用hint，而是通过Analyze table多收集统计信息。但在特定场合下，指定hint可以排除其他索引干扰而指定更优的执行计划。</p><ul><li>USE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。例子: SELECT col1 FROM table USE INDEX (mod_time, name)…</li><li>IGNORE INDEX 如果只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。例子: SELECT col1 FROM table IGNORE INDEX (priority) …</li><li>FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。例子: SELECT col1 FROM table FORCE INDEX (mod_time) …</li></ul><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。</p><p>例如：</p><pre><code>SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC;</code></pre><h3 id="四、查询条件优化"><a href="#四、查询条件优化" class="headerlink" title="四、查询条件优化"></a>四、查询条件优化</h3><ol><li>对于复杂的查询，可以使用中间临时表 暂存数据；</li><li>优化group by语句</li></ol><p>默认情况下，MySQL 会对GROUP BY分组的所有值进行排序，如 “GROUP BY col1，col2，…;” 查询的方法如同在查询中指定 “ORDER BY col1，col2，…;” 如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。</p><p>因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序。例如：</p><pre><code>SELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2 ORDER BY NULL ;</code></pre><ol><li>优化join语句</li></ol><p>MySQL中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)…替代。</p><p>例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成：</p><pre><code>SELECT col1 FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo )</code></pre><p>如果使用连接(JOIN)… 来完成这个查询工作，速度将会有所提升。尤其是当 salesinfo表中对 CustomerID 建有索引的话，性能将会更好，查询如下：</p><pre><code>SELECT col1 FROM customerinfo    LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID       WHERE salesinfo.CustomerID IS NULL </code></pre><p>连接(JOIN)… 之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。</p><ol><li>优化union查询</li></ol><p>MySQL通过创建并填充临时表的方式来执行union查询。除非确实要消除重复的行，否则建议使用union all。原因在于如果没有all这个关键词，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。</p><p>高效：</p><pre><code>SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION ALL SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= 'TEST'; </code></pre><p>低效：</p><pre><code>SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= 'TEST';</code></pre><p>5.拆分复杂SQL为多个小SQL，避免大事务</p><ul><li>简单的SQL容易使用到MySQL的QUERY CACHE；</li><li>减少锁表时间特别是使用MyISAM存储引擎的表；</li><li>可以使用多核CPU。</li></ul><ol><li>使用truncate代替delete</li></ol><p>当删除全表中记录时，使用delete语句的操作会被记录到undo块中，删除记录也记录binlog，当确认需要删除全表时，会产生很大量的binlog并占用大量的undo数据块，此时既没有很好的效率也占用了大量的资源。</p><p>使用truncate替代，不会记录可恢复的信息，数据不能被恢复。也因此使用truncate操作有其极少的资源占用与极快的时间。另外，使用truncate可以回收表的水位，使自增字段值归零。</p><ol><li>使用合理的分页方式以提高分页效率</li></ol><p>使用合理的分页方式以提高分页效率 针对展现等分页需求，合适的分页方式能够提高分页的效率。</p><p>案例1：</p><pre><code>select * from t where thread_id = 10000 and deleted = 0    order by gmt_create asc limit 0, 15;</code></pre><p>上述例子通过一次性根据过滤条件取出所有字段进行排序返回。数据访问开销=索引IO+索引全部记录结果对应的表数据IO。因此，该种写法越翻到后面执行效率越差，时间越长，尤其表数据量很大的时候。</p><p>适用场景：当中间结果集很小（10000行以下）或者查询条件复杂（指涉及多个不同查询字段或者多表连接）时适用。</p><p>案例2：</p><pre><code>select t.* from (select id from t where thread_id = 10000 and deleted = 0   order by gmt_create asc limit 0, 15) a, t       where a.id = t.id; </code></pre><p>上述例子必须满足t表主键是id列，且有覆盖索引secondary key:(thread_id, deleted, gmt_create)。通过先根据过滤条件利用覆盖索引取出主键id进行排序，再进行join操作取出其他字段。数据访问开销=索引IO+索引分页后结果（例子中是15行）对应的表数据IO。因此，该写法每次翻页消耗的资源和时间都基本相同，就像翻第一页一样。</p><p>适用场景：当查询和排序字段（即where子句和order by子句涉及的字段）有对应覆盖索引时，且中间结果集很大的情况时适用。</p><h3 id="五、SELECT语句其他优化"><a href="#五、SELECT语句其他优化" class="headerlink" title="五、SELECT语句其他优化"></a>五、SELECT语句其他优化</h3><ol><li>避免出现select *</li></ol><p>首先，select * 操作在任何类型数据库中都不是一个好的SQL编写习惯。</p><p>使用select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I/O,内存和CPU消耗。</p><p>建议提出业务实际需要的列数，将指定列名以取代select *。具体详情见《为什么大家都说SELECT * 效率低》：</p><ol><li>避免出现不确定结果的函数</li></ol><p>特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如now()、rand()、sysdate()、current_user()等不确定结果的函数很容易导致主库与从库相应的数据不一致。另外不确定值的函数,产生的SQL语句无法利用query cache。</p><p>3.多表关联查询时，小表在前，大表在后。</p><p>在MySQL中，执行 from 后的表关联查询是从左往右执行的（Oracle相反），第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。</p><p>例如：表1有50条数据，表2有30亿条数据；如果全表扫描表2，你品，那就先去吃个饭再说吧是吧。</p><ol><li>使用表的别名</li></ol><p>当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。</p><ol><li>用where字句替换HAVING字句</li></ol><p>避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。</p><p>where和having的区别：where后面不能使用组函数</p><p>6.调整Where字句中的连接顺序</p><p>MySQL采用从左往右，自上而下的顺序解析where子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存溢出/内存泄漏分析过程</title>
      <link href="2021/06/18/nei-cun-yi-chu-nei-cun-xie-lou-fen-xi-guo-cheng/"/>
      <url>2021/06/18/nei-cun-yi-chu-nei-cun-xie-lou-fen-xi-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="内存溢出-内存泄漏分析过程"><a href="#内存溢出-内存泄漏分析过程" class="headerlink" title="内存溢出/内存泄漏分析过程"></a>内存溢出/内存泄漏分析过程</h1><h2 id="一、名词解释"><a href="#一、名词解释" class="headerlink" title="一、名词解释"></a>一、名词解释</h2><ul><li>内存泄漏（<strong>memory leak</strong>）含义：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</li><li>内存溢出（<strong>out of memory</strong>）：简称OOM含义：程序申请内存时，没有足够的内存分配给使用者</li></ul><p>注：内存泄漏的堆积最终会导致内存溢出</p><h2 id="二、OOM常见报错信息"><a href="#二、OOM常见报错信息" class="headerlink" title="二、OOM常见报错信息"></a>二、OOM常见报错信息</h2><p>常见报错有下面2类：</p><ul><li>java.lang.OutOfMemoryError: Java heap spacejava堆空间不足，一般是堆内存设置过小 或 堆空间的对象太多，不能被GC清除</li><li>java.lang.OutOfMemoryError: GC overhead limit exceeded如果Java进程花费98%以上的时间执行GC，并且每次只有不到2%的堆被恢复，则JVM抛出此错误。想象一下，如果不抛异常，再进行下去的话，系统就只能一直GC中，还有能力为你的服务吗？</li></ul><h2 id="三、模拟OOM"><a href="#三、模拟OOM" class="headerlink" title="三、模拟OOM"></a>三、模拟OOM</h2><p>为了便于复现，我们先设置jvm参数：</p><p>-Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=E:\JAVA\dump</p><pre><code>-Xms5m ：堆初始内存（5m便于复现OOM）-Xmx5m ：堆最大内存（5m便于复现OOM）-XX:+HeapDumpOnOutOfMemoryError：当JVM发生OOM时，自动生成DUMP文件（.hprof）-XX:HeapDumpPath=E:\JAVA\dump ：发生oom时，生成.hprof文件存放地址</code></pre><p>编写程序，制造大量对象放入集合中：</p><pre><code>    private static class MyOOM {    }    public static void main(String[] args) {        List&lt;MyOOM&gt; list = new ArrayList&lt;&gt;();        while (true) {            list.add(new MyOOM());        }    }</code></pre><p>运行结果如下：</p><pre><code>java.lang.OutOfMemoryError: Java heap spaceDumping heap to E:\JAVA\dump\java_pid2892.hprof ...Heap dump file created [9507297 bytes in 0.068 secs]Exception in thread "main" java.lang.OutOfMemoryError: Java heap space    at java.util.Arrays.copyOf(Arrays.java:3210)    at java.util.Arrays.copyOf(Arrays.java:3181)    at java.util.ArrayList.grow(ArrayList.java:261)    at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)    at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)    at java.util.ArrayList.add(ArrayList.java:458)    at com.abao.demo.Demo.main(Demo.java:22)</code></pre><h2 id="四、分析与改进措施"><a href="#四、分析与改进措施" class="headerlink" title="四、分析与改进措施"></a>四、分析与改进措施</h2><p>一般解决OOM有如下几种方法：</p><h3 id="1、增大堆空间"><a href="#1、增大堆空间" class="headerlink" title="1、增大堆空间"></a>1、增大堆空间</h3><p>既然堆内存少了，那就增加堆内存即可。但是再大的内存也会有用尽的时候，因此此方法治标不治本。</p><h3 id="2、找到占用内存大的地方，优化代码"><a href="#2、找到占用内存大的地方，优化代码" class="headerlink" title="2、找到占用内存大的地方，优化代码"></a>2、找到占用内存大的地方，优化代码</h3><p>怎么定位呢？通过jvm生成的dump文件定位。</p><p>运行结果中已经表明，当发生OOM时，堆栈信息的文件的存放路径了。这里我们使用工具打开java_pid2892.hprof。常用工具有 jvisualvm（jdk自带）、MAT、arthas（阿里的工具）等。</p><p>我们选择jvisualvm（cmd窗口中输入 jvisualvm就会自己打开该工具）</p><p><img src="/2021/06/18/nei-cun-yi-chu-nei-cun-xie-lou-fen-xi-guo-cheng/ff704cbc216e488e9f675a617cace11e" alt="内存溢出/内存泄漏分析过程"></p><p>在概要-堆转储上的线程 中查看发生OOM的地方，点击进入看详情（<strong>此处可以看到发生OOM在哪一行代码</strong>）</p><p><img src="/2021/06/18/nei-cun-yi-chu-nei-cun-xie-lou-fen-xi-guo-cheng/e96da59f6c6947daae813a2a1831b553" alt="内存溢出/内存泄漏分析过程"></p><p>结合上下2张图可以看出来，当向ArrayList中插入第240098个MyOOM对象时出现内存溢出了。</p><p><img src="/2021/06/18/nei-cun-yi-chu-nei-cun-xie-lou-fen-xi-guo-cheng/2bc13a7b02254b29a9c2f0988b0bb454" alt="内存溢出/内存泄漏分析过程"></p><p>因此我们可以看看整个jvm中对象信息，可以看到此对象产生的数量太多了，占用堆空间最大。</p><p><img src="/2021/06/18/nei-cun-yi-chu-nei-cun-xie-lou-fen-xi-guo-cheng/bb0fbad7fbef4813a25eadd76942779d" alt="内存溢出/内存泄漏分析过程"></p><h3 id="3、怎么改"><a href="#3、怎么改" class="headerlink" title="3、怎么改"></a>3、怎么改</h3><p>既然找到哪一行代码发生的问题，以及是哪一个对象了。便可以适当清除集合，比如下方代码：</p><pre><code>    public static void main(String[] args) {        List&lt;MyOOM&gt; list = new ArrayList&lt;&gt;();        while (true) {            list.add(new MyOOM());            if (一定的业务条件){                list.clear();// 清除集合中对象的引用            }        }    }</code></pre><p>综上，只要我们设置合理的堆栈大小，再配合一定的代码优化便可一定程度上解决OOM，让程序更健壮。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql slow query</title>
      <link href="2021/06/18/mysql-slow-query/"/>
      <url>2021/06/18/mysql-slow-query/</url>
      
        <content type="html"><![CDATA[<h1 id="如何检查和定位Mysql数据库中存在的慢查询语句？"><a href="#如何检查和定位Mysql数据库中存在的慢查询语句？" class="headerlink" title="如何检查和定位Mysql数据库中存在的慢查询语句？"></a>如何检查和定位Mysql数据库中存在的慢查询语句？</h1><p>如果在生产环境中监控到Mysql数据库CPU使用率过高的情况，那么很有可能是查询语句中存在慢查询，那么如何定位慢查询呢？</p><h2 id="开启慢查询日志功能"><a href="#开启慢查询日志功能" class="headerlink" title="开启慢查询日志功能"></a>开启慢查询日志功能</h2><p>要定位慢查询，就需要开启慢查询日志功能。</p><h3 id="（1）首先登录数据库服务器，连接数据库。"><a href="#（1）首先登录数据库服务器，连接数据库。" class="headerlink" title="（1）首先登录数据库服务器，连接数据库。"></a><strong>（1）首先登录数据库服务器，连接数据库。</strong></h3><pre><code>mysql -uroot -p</code></pre><h3 id="（2）然后查看慢查询日志是否开启，执行命令：show-variables-like-‘-slow-’"><a href="#（2）然后查看慢查询日志是否开启，执行命令：show-variables-like-‘-slow-’" class="headerlink" title="（2）然后查看慢查询日志是否开启，执行命令：show variables like ‘%slow%’"></a><strong>（2）然后查看慢查询日志是否开启</strong>，执行命令：show variables like ‘%slow%’</h3><p><img src="/2021/06/18/mysql-slow-query/6dd72a10d7a743db920a5a95258f57c5" alt="如何检查和定位Mysql数据库中存在的慢查询语句？"></p><p>查看慢查询日志是否开启</p><p>执行show variables like ‘%slow%’ 这个命令的时候，有可能会报错：<br>performance_schema.session_variables 不存在，无法显示上面的信息。那么就需要执行以下命令检查和升级mysql表，完成后要重启Mysql服务器。</p><pre><code>mysql_upgrade -u root -p --force</code></pre><p>上表列出了带有slow字样的变量：</p><ul><li>log_slow_admin_statements：记录执行缓慢的管理类SQL。比如alter table, analyze table, check table, create index, drop index, optimize table, repair table等。</li><li>log_slow_slave_statements：记录从库上执行的慢查询语句。</li><li>slow_query_log：慢查询日志开关，ON为开启，OFF为关闭。</li><li>slow_query_log_file：慢查询日志文件路径，可通过日志查看慢sql语句及执行时间。</li><li>slow_lauch_time：这个值经常与慢查询阈值混淆，实际上和慢查询没有什么关系，而是和创建线程的耗时有关系。这里就不展开说了。与慢查询有关系的变量是<strong>long_query_time。</strong></li><li><strong>long_query_time：</strong>Sql查询的执行时间阈值，也就是慢查询阈值。大于该值的查询为慢查询，将被记录到日志中。这个值默认的是10s，可以根据需求进行配置。Mysql 5.5以上版本可以追踪到微秒。</li></ul><p><img src="/2021/06/18/mysql-slow-query/70bfced762f04ad5a53ea6767ac6c6ae" alt="如何检查和定位Mysql数据库中存在的慢查询语句？"></p><p>long_query_time</p><p>其他与慢查询日志有关系的变量还包括：</p><ul><li>log_queries_not_using_indexes：如果设置了该变量，那么未使用索引的查询也被记录到慢查询日志中。这就是为什么有时会在慢查询日志中看到执行时间低于慢查询阈值的sql语句。</li><li>log_output：日志存储方式。默认值是’FILE’，表示将日志存入文件。’TABLE’表示将日志存入数据库，这样日志信息就会被写入到 mysql.slow_log 表中。日志写入到数据库专用日志表中，要比写入到文件耗费更多的系统资源，因此建议优先记录到文件。</li></ul><h3 id="（3）通过日志查看慢查询的sql语句，看sql语句的执行计划，看是否缺少索引，是否可以进行优化。"><a href="#（3）通过日志查看慢查询的sql语句，看sql语句的执行计划，看是否缺少索引，是否可以进行优化。" class="headerlink" title="（3）通过日志查看慢查询的sql语句，看sql语句的执行计划，看是否缺少索引，是否可以进行优化。"></a><strong>（3）通过日志查看慢查询的sql语句</strong>，看sql语句的执行计划，看是否缺少索引，是否可以进行优化。</h3><p>执行select sleep(11)语句, 即可在慢查询日志文件上看到刚刚执行的sql。</p><p><img src="/2021/06/18/mysql-slow-query/41b548cd203447838ec27505a2f3ebab" alt="如何检查和定位Mysql数据库中存在的慢查询语句？"></p><p>慢查询日志</p><p>默认情况下slow_query_log 的值为OFF，表示慢查询日志是禁用的，可以通过设置 slow_query_log 的值来开启。</p><pre><code>set global slow_query_log=1</code></pre><p>这种方法只对当前数据库生效，如果MySQL重启后，这个设置则会失效。如果需要设置永久生效，就必须修改配置文件my.cnf。</p><h2 id="慢查询日志分析"><a href="#慢查询日志分析" class="headerlink" title="慢查询日志分析"></a>慢查询日志分析</h2><p>用肉眼来分析慢查询日志，这个工作量可能不太有利于身心健康。所以有专门的分析工具来分析慢查询日志，比如<strong>mysqldumpslow</strong>。</p><pre><code>mysqldumpslow -s t -t 10 /var/lib/mysql/MyDB-slow.log</code></pre><p>-s 表示以何种方式来进行排序，t 表示查询时间。c 表示访问计数。l 表示锁定时间。r 表示返回记录。al 表示平均锁定时间。ar 表示平均返回记录数。at 表示平均查询时间。</p><p>-t 是top n的意思，即为返回前面多少条的数据。</p><p>以上命令的意思就是从慢查询日志中找出查询时间最长的10条sql语句。</p><p>随着时间积累，日志文件会越来越大，可能会大到<strong>mysqldumpslow</strong> 也处理不了。最好是通过定时任务<strong>crontab</strong>，按天切割归纳慢查询日志，方便定位和分析。</p><h2 id="慢查询问题的解决"><a href="#慢查询问题的解决" class="headerlink" title="慢查询问题的解决"></a>慢查询问题的解决</h2><p><strong>线上问题的解决</strong>：当发现生产环境cpu占用率过高，通常的做法是通过执行命令show processlist，先找出执行时间过长的线程，再把它们给kill掉。</p><p>当然这只是暂时性的做法，要想尽量避免出现线上问题，最好采取以下措施：</p><ul><li>在程序设计和开发过程中，要考虑查询的优化，建立必要的索引，降低查询的逻辑 IO。</li><li>新功能、新模块上线前，在预生产环境中使用生产环境数据进行压力测试，尽早地发现问题。</li><li>在生产环境的监控系统中设置 CPU 使用率告警，实例 CPU 使用率保证一定的冗余度，当发现CPU使用率过高，可以尽早采取措施。</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用 Git 使用技巧</title>
      <link href="2021/05/31/git-chang-yong-shi-yong-ji-qiao/"/>
      <url>2021/05/31/git-chang-yong-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h2 id="常见企业工作流程"><a href="#常见企业工作流程" class="headerlink" title="常见企业工作流程"></a>常见企业工作流程</h2><p>主要介绍，企业中常用的 Git 工作流程！</p><h4 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h4><ul><li>主干分支</li><li>稳定分支</li><li>开发分支</li><li>补丁分支</li><li>修改分支</li></ul><p><img src="/2021/05/31/git-chang-yong-shi-yong-ji-qiao/20210531102657.png" alt="图片"></p><h4 id="Github-Flow"><a href="#Github-Flow" class="headerlink" title="Github Flow"></a>Github Flow</h4><ul><li>创建分支</li><li>添加提交</li><li>提交 PR 请求</li><li>讨论和评估代码</li><li>部署检测</li><li>合并代码</li></ul><p><img src="/2021/05/31/git-chang-yong-shi-yong-ji-qiao/20210531102739.png" alt="图片"></p><h4 id="Gitlab-Flow"><a href="#Gitlab-Flow" class="headerlink" title="Gitlab Flow"></a>Gitlab Flow</h4><ul><li>带生产分支</li><li>带环境分支</li><li>带发布分支</li></ul><p><img src="/2021/05/31/git-chang-yong-shi-yong-ji-qiao/20210531102756.png" alt="图片"></p><h2 id="日常使用最佳实践"><a href="#日常使用最佳实践" class="headerlink" title="日常使用最佳实践"></a>日常使用最佳实践</h2><p>总结日常工作中应该遵循的 Git 使用方式和方法！</p><ul><li><p>使用命令行代替图形化界面</p></li><li><p>使用命令行来操作，简洁且效率高</p></li><li><p>提交应该尽可能的表述提交修改内容</p></li><li><ul><li>区分 subject 和 body 内容，使用空行隔开</li><li>subject 一般不超过 50 个字符</li><li>body 每一行的长度控制在 72 个字符</li><li>subject 结尾不需要使用句号或者点号结尾</li><li>body 用来详细解释此次提交具体做了什么</li></ul></li><li><p>使用 .gitignore 文件来排除无用文件</p></li><li><ul><li>可使用模板文件，然后根据项目实际进行修改</li></ul></li><li><p>基于分支或 fork 的开发模式</p></li><li><ul><li>不要直接在主干分支上面进行开发</li><li>在新建的分支上进行功能的开发和问题的修复</li></ul></li><li><p>使用 release 分支和 tag 标记进行版本管理</p></li><li><ul><li>使用 release 分支发布代码和版本维护(release/1.32)</li><li>使用 tag 来标记版本(A-大feature功能.B-小feature功能.C-只修bug)</li></ul></li></ul><h2 id="常用命令汇总整理"><a href="#常用命令汇总整理" class="headerlink" title="常用命令汇总整理"></a>常用命令汇总整理</h2><p>日常使用只要记住 6 个命令就可以了。</p><p><img src="/2021/05/31/git-chang-yong-shi-yong-ji-qiao/20210531102813.png" alt="图片"></p><pre class="line-numbers language-shell"><code class="language-shell"># 工作区 -> 暂存区$ git add <file/dir># 暂存区 -> 本地仓库$ git commit -m "some info"# 本地仓库 -> 远程仓库$ git push origin master # 本地master分支推送到远程origin仓库# 工作区 <- 暂存区$ git checkout -- <file>  # 暂存区文件内容覆盖工作区文件内容# 暂存区 <- 本地仓库$ git reset HEAD <file>   # 本地仓库文件内容覆盖暂存区文件内容# 本地仓库 <- 远程仓库$ git clone <git_url>        # 克隆远程仓库$ git fetch upstream master  # 拉取远程代码到本地但不应用在当前分支$ git pull upstream master   # 拉取远程代码到本地但应用在当前分支$ git pull --rebase upstream master  # 如果平时使用rebase合并代码则加上# 工作区 <- 本地仓库$ git reset <commit>          # 本地仓库覆盖到工作区(保存回退文件内容修改)$ git reset --mixed <commit>  # 本地仓库覆盖到工作区(保存回退文件内容修改)$ git reset --soft <commit>   # 本地仓库覆盖到工作区(保留修改并加到暂存区)$ git reset --hard <commit>   # 本地仓库覆盖到工作区(不保留修改直接删除掉)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置实用参数选项"><a href="#配置实用参数选项" class="headerlink" title="配置实用参数选项"></a>配置实用参数选项</h2><p>虽然配置比较简单，但是非常有用！另外，关注公众号Java技术栈，在后台回复：面试，可以获取我整理的 Java 系列面试题和答案，非常齐全。</p><h4 id="全局配置"><a href="#全局配置" class="headerlink" title="[全局配置]"></a>[全局配置]</h4><pre class="line-numbers language-shell"><code class="language-shell"># 用户信息$ git config --global user.name "your_name"$ git config --global user.email "your_email"# 文本编辑器$ git config --global core.editor "nvim"# 分页器$ git config --global core.pager "more"# 别名$ git config --global alias.gs "git status"# 纠错$ git config --global help.autocorrect 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="个人配置"><a href="#个人配置" class="headerlink" title="[个人配置]"></a>[个人配置]</h4><pre class="line-numbers language-shell"><code class="language-shell"># 不加--global参数的话，则为个人配置$ git config --list$ git config user.name$ git config user.name "your_name"# 如果在项目中设置，则保存在.git/config文件里面$ cat .git/config[user]    name = "your_name"......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="合并和变基的选择"><a href="#合并和变基的选择" class="headerlink" title="合并和变基的选择"></a>合并和变基的选择</h2><p>到底什么时候使用 merge 操作，什么时候使用 rebase 操作呢？</p><h4 id="使用-merge-操作-Python-中的-Requests-库在使用"><a href="#使用-merge-操作-Python-中的-Requests-库在使用" class="headerlink" title="使用 merge 操作 - Python 中的 Requests 库在使用"></a>使用 merge 操作 - Python 中的 Requests 库在使用</h4><p>支持使用 merge 的开发者，他们认为仓库的提交历史就是记录实际发生过什么，它是针对于历史的一个文档，本身其实是有价值的，我们不应该随意修改。我们改变历史的话，就相当于使用“谎言”来掩盖实际发生过的事情，而这些痕迹是应该被保留的。可能，这样并不是很好。</p><pre class="line-numbers language-shell"><code class="language-shell"># 3rd的两个分支的commit修改相同内容*   62a322d - (HEAD->master) Merge branch 'hotfix3' into master|\| * 6fa8f4a - (hotfix3) 3rd commit in hotfix3* | 548d681 - 3rd commit in master|/* 6ba4a08 - 2nd commit* 22afcc1 - 1st commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="使用-rebase-操作-Python-中的-Django-库在使用"><a href="#使用-rebase-操作-Python-中的-Django-库在使用" class="headerlink" title="使用 rebase 操作 - Python 中的 Django 库在使用"></a>使用 rebase 操作 - Python 中的 Django 库在使用</h4><p>支持使用 rebase 的开发者，他们认为提交历史是项目过程中发生过的事情，需要项目的主干非常的干净。而使用 merge 操作会生成一个 merge 的 commit 对象，让提交历史多了一些非常多余的内容。</p><p>当我们后期，使用 log 命令参看提交历史的话，会发现主干的提交历史非常的尴尬。比如，同样的修改内容重复提交了两次，这显然是分支合并导致的问题。</p><pre class="line-numbers language-shell"><code class="language-shell"># 3rd的两个分支的commit修改相同内容* 697167e - (HEAD -> master, hotfix) 3rd commit* 6ba4a08 - 2nd commit (2 minutes ago)* 22afcc1 - 1st commit (3 minutes ago)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="两者的使用原则"><a href="#两者的使用原则" class="headerlink" title="两者的使用原则"></a>两者的使用原则</h4><p>总的原则就是，只对尚未推送或分享给其他人的本地修改执行变基操作清理历史，从不对已经推送到仓库的提交记录执行变基操作，这样，你才可能享受到两种方式带来的便利。</p><h2 id="更新仓库提交历史"><a href="#更新仓库提交历史" class="headerlink" title="更新仓库提交历史"></a>更新仓库提交历史</h2><p>Git 提供了一些工具，可以帮助我们完善版本库中的提交内容，比如：</p><h4 id="合并多个-commit-提交记录"><a href="#合并多个-commit-提交记录" class="headerlink" title="合并多个 commit 提交记录"></a>合并多个 commit 提交记录</h4><p>日常开发中，我们为了完成一个功能或者特性，提交很多个 commit 记录。但是在最后，提交 PR 之前，一般情况下，我们是应该整理下这些提交记录的。有些 commit 需要合并起来，或者需要将其删除掉，等等。</p><pre class="line-numbers language-shell"><code class="language-shell"># 调整最近五次的提交记录$ git rebase -i HEAD~5$ git rebase -i 5af4zd35  # 往前第六次的commit值reword c2aeb6e 3rd commitsquash 25a3122 4th commitpick 5d36f1d 5th commitfixup bd5d32f 6th commitdrop 581e96d 7th commit# 查看提交历史记录$ git log* ce813eb - (HEAD -> master) 5th commit* aa2f043 - 3rd commit -> modified* 6c5418f - 2nd commit* c8f7dea - 1st commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/05/31/git-chang-yong-shi-yong-ji-qiao/640" alt="图片"></p><h4 id="删除意外调试的测试代码"><a href="#删除意外调试的测试代码" class="headerlink" title="删除意外调试的测试代码"></a>删除意外调试的测试代码</h4><p>有时候提交之后，我们才发现提交的历史记录中存在这一些问题，而这个时候我们又不想新生成一个 commit 记录，且达到一个修改的目录。即，修改之前的 commit 提交记录。</p><pre class="line-numbers language-shell"><code class="language-shell"># 不使用分页器$ git --no-pager log --oneline -1d5e96d9 (HEAD -> master) say file# 改变提交信息并加入暂存区$ echo "hello" > say.txt$ git add -u# 改变当前最新一次提交记录$ git commit --amend# 改变且息不改变提交信$ git commit --amend --no-edit# 改变当前最新一次提交记录并修改信息$ git commit --amend -m "some_info"# 不使用分页器$ git --no-pager log --oneline -19e1e0eb (HEAD -> master) say file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="取消多个-commit-中的部分提交"><a href="#取消多个-commit-中的部分提交" class="headerlink" title="取消多个 commit 中的部分提交"></a>取消多个 commit 中的部分提交</h4><p>我们开发了一个功能，而在上线的时候，产品经理说这个功能的部分特性已经不需要了，即相关特性的提交记录和内容就可以忽略/删除掉了。</p><pre class="line-numbers language-shell"><code class="language-shell"># 回滚操作(可多次执行回滚操作)# 彻底上次提交记录；也可是PR的提交记录# 默认会生成一个类型为reverts的新commit对象$ git revert 3zj5sldl[4] 合并某些特定的 commit 提交我们不希望合并整个分支，而是需要合并该分支的某些提交记录就可以了。bash# 摘樱桃$ git cherry-pick -x z562e23d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用引用日志记录"><a href="#使用引用日志记录" class="headerlink" title="使用引用日志记录"></a>使用引用日志记录</h2><p>如何找回我们丢失的内容和记录？</p><p>我们之前说过，使用下面命令回退内容、强制推送代码、删除本地分支，都是非常危险的操作，因为重置之后我们就没有办法在找到之前的修改内容了。</p><pre class="line-numbers language-shell"><code class="language-shell"># 回退$ git reset --hard <commit># 推送$ git push origin master -f# 分支$ git branch -D <branch_name><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实 Git 给我们留了一个后门，就是使用 relflog 命令来找回之前的内容，只不过是相对来说麻烦一些。而原理也很简答，就是在我们使用 Git 命令操作仓库的时候，Git 偷偷地帮助我们把所有的操作记录了下来。</p><pre class="line-numbers language-shell"><code class="language-shell"># 查看日志记录$ git --no-pager log --oneline -14bc8703 (HEAD -> master) hhhh# 回退到上次提交$ git reset --hard HEAD~1# 查看引用日志记录$ git reflog6a89f1b (HEAD -> master) HEAD@{0}: reset: moving to HEAD~14bc8703 HEAD@{1}: commit (amend): hhhh# 找回内容$ git cherry-pick 4bc8703<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="批量修改历史提交"><a href="#批量修改历史提交" class="headerlink" title="批量修改历史提交"></a>批量修改历史提交</h2><p>批量修改历史提交虽然不常用，但是理解的话可以省下很多时间！</p><p>之前我们学习到的命令都是针对于一个或者多个 commit 提交信息进行修改的，如果我们需要全局修改历史提交呢？当然，Git 中也是支持全局修改历史提交的，比如全局修改邮箱地址，或者将一个文件从全局历史中删除或修改。</p><ul><li>开源项目中使用了公司邮箱进行提交了</li><li>提交文件中包含隐私性的密码相关信息</li><li>提交时将大文件提交到了仓库代码中了</li></ul><p>这里我们可以使用 filter-brach 的方式进行修改，但是建议在使用之前，新建一个分支，在上面进行测试没有问题之后，再在主干上操作，防止出现问题，背个大锅在身上。</p><pre class="line-numbers language-shell"><code class="language-shell"># 创建分支$ git branch -b testing# 修改邮箱地址$ git filter-branch --commit-filter '    if [ "$GIT_AUTHOR_EMAIL" == "escape@escapelife.site" ]; then        GIT_AUTHOR_NAME="escape";        GIT_AUTHOR_EMAIL="escape@gmail.com";        git commit-tree "$@"    else        git commit-tree "$@"  fi' HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="灵活使用钩子函数"><a href="#灵活使用钩子函数" class="headerlink" title="灵活使用钩子函数"></a>灵活使用钩子函数</h2><p>主要介绍.git/hooks 目录下面的示例钩子函数！</p><p>在 Git 里面有两类，分别对应客户端和服务端钩子函数。客户端的钩子函数，是在执行提交和合并之类的操作时调用的。而服务端钩子函数，就是当服务端收到代码提交之后，可以出发代码检查和持续集成的步骤。作为开发者我们并不会搭建 Git 服务器，所以基本不会涉及。</p><p>下面就是 Git 自带的钩子脚本，但是自带的都以 .sample 作为后缀，表示并没有启用，表示为一个示例。如果需要启用的话，将 .sample 作为后缀删除掉，即可。而其钩子脚本的对应内容，都是使用 Shell 语法进行编写的。</p><pre class="line-numbers language-shell"><code class="language-shell">➜ ll .git/hookstotal 112-rwxr-xr-x  applypatch-msg.sample-rwxr-xr-x  commit-msg.sample-rwxr-xr-x  fsmonitor-watchman.sample-rwxr-xr-x  post-update.sample-rwxr-xr-x  pre-applypatch.sample-rwxr-xr-x  pre-commit.sample-rwxr-xr-x  pre-merge-commit.sample-rwxr-xr-x  pre-push.sample  # 不会推送包含WIP的commit提交-rwxr-xr-x  pre-rebase.sample-rwxr-xr-x  pre-receive.sample-rwxr-xr-x  prepare-commit-msg.sample-rwxr-xr-x  update.sample<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实，钩子脚本使用任何语言编写都是可以的，只要你让程序返回对应的退出码就可以了。</p><p>正常的代码合入流程就是，我们本地修改之后，提一个 PR 请求并通过 Github 的 CI 检查，接下来进行代码评审，最后被合并入主干。但是，好的一个习惯就是，在代码提交之前就应该保证代码不会出现语法错误等基础问题，比如通过 flake8 和 PEP8 标准等。</p><p>这个时候我们就可以使用 pre-commit 这个 Github 的开源项目了，其本质就是给项目添加钩子函数的一个脚本，可以保证我们在提交代码或者推送代码之前，先检查代码的质量。</p><p>而 pre-commit-hooks 这个项目里面包含的就是，现在所支持的钩子脚本，即开箱即用的钩子脚本集合。而其钩子脚本的对应内容，都是使用 Python 语法进行编写的。</p><pre class="line-numbers language-shell"><code class="language-shell"># 安装方式$ pip install pre-commit# 指定hook类型(即在哪里检查)$ pre-commit install -f --hook-type pre-push# 配置需要执行的检查$ cat .pre-commit-config.yamlrepos:- repo: https://github.com/pre-commit/pre-commit-hooks  rev: v2.9.2  hooks:    - id: trailing-whitespace    - id: flake8# 执行push操作时检查$ git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="快速克隆大型项目"><a href="#快速克隆大型项目" class="headerlink" title="快速克隆大型项目"></a>快速克隆大型项目</h2><p>在大项目中工作中，拉取代码非常占时间！</p><p>我们如果想为 Linux 或 Python 这样的大型项目贡献提交的时候，首先遇到的问题就是，如果快速的 clone 该项目到本地。因为改项目提交历史超多且仓库巨大，加了国内网络的问题，可能等项目完全拉下来的时候，我们的热情都消减下去了。</p><p>好在 Git 也帮我们想到了这样的问题，我们可以使用 –depth 参数值拉取远程仓库上面最新一次的提交历史，并不包含项目历史记录，即 .git/objects/ 目录下的对象只是本地的，并不包含之前的多次修改产生的对象。</p><pre class="line-numbers language-shell"><code class="language-shell"># 克隆不包含之前历史$ git clone http://xxx.xx.xxx/xxx --depth=1但是，有时间我们可能会需要 clone 仓库中的某个 tag 版本对应下的内容。如果我们直接使用 clone 命令是无法做到的，需要执行如下操作，即可完美解决。# 克隆特定版本代码$ git init xxx-15-0-1$ git remote add origin http://xxx.xx.xxx/xxx$ git -c protocol.version=2 fetch origin 15.0.1 --depth=1$ git checkout FETCH_HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的效果已经基本可以满足我们日常使用需求了，但是不幸的是，你现在接受了一个机器学习的项目，里面包含了大量的 lfs 文件，现在 clone 又会变得非常慢。可以使用如下操作来避免，Git 工具主动拉去 lfs 文件，来达到目录。</p><pre class="line-numbers language-shell"><code class="language-shell"># 克隆不包含LFS数据$ GIT_LFS_SKIP_SMUDGE=1 git clone http://xxx.xx.xxx/xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="如何处理工作中断"><a href="#如何处理工作中断" class="headerlink" title="如何处理工作中断"></a>如何处理工作中断</h2><p>如果在多路运转的时候，还能够高效的进行开发！</p><p>比如，我们现在正在一个分支为项目添加一个小的功能，此时，产品经理找到你说是线上环境现在有一个 bug 需要让你来修复下。但是，此时我们添加的小功能并没有完成。</p><p>如果此时，我们直接切换到主干分支的话，会将之前分支没有来得及提交的内容全部都带到了主干分支上来，这是我们不想看到的情况。此时，我们需要保存上个分支的工作状态，在我们修改完成线上 bug 之后，再继续工作。</p><p>好在 Git 也帮我们想到了这样的问题，我们可以使用 stash 子命令帮助我们将当前工作区、暂存区当中的修改都保存到堆栈之中。等到需要处理的时候，再弹出堆栈中的内容，我们再次进行开发。</p><pre class="line-numbers language-shell"><code class="language-shell">➜ git stash -husage: git stash list [<options>]   or: git stash show [<options>] [<stash>]   or: git stash drop [-q|--quiet] [<stash>]   or: git stash ( pop | apply ) [--index] [-q|--quiet] [<stash>]   or: git stash branch <branchname> [<stash>]   or: git stash clear   or: git stash [push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]          [-u|--include-untracked] [-a|--all] [-m|--message <message>]          [--pathspec-from-file=<file> [--pathspec-file-nul]]          [--] [<pathspec>...]]   or: git stash save [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]          [-u|--include-untracked] [-a|--all] [<message>]# 存储当前的修改但不用提交commit$ git stash# 保存当前状态包括untracked的文件$ git stash -u# 展示所有stashes信息$ git stash list# 回到某个stash状态$ git stash apply <stash@{n}># 删除储藏区$ git stash drop <stash@{n}># 回到最后一个stash的状态并删除这个stash信息$ git stash pop# 删除所有的stash信息$ git stash clear# 从stash中拿出某个文件的修改$ git checkout <stash@{n}> -- <file-path><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实比较保险的做法就是，将当前的所有修改进行 push 并保存到远程仓库里面。这样的好处在于，可以远端备份我们的修改，不会害怕本地文件丢失等问题。等到我们需要继续开发的时候，拉下对应内容，再想办法进行补救，比如使用 –amend 或者 reset 命令。</p><pre class="line-numbers language-shell"><code class="language-shell"># 将工作区和暂存区覆盖最近一次提交$ git commit --amend$ git commit --amend -m "some_info"# 回退到指定版本并记录修改内容(--mixed)# 本地仓库覆盖到工作区(保存回退文件内容修改)$ git reset a87f328$ git reset HEAD~$ git reset HEAD~2$ git reset <tag>~2$ git reset --mixed <commit/reference># 本地仓库覆盖到工作区(不保留修改直接删除掉)$ git reset --soft <commit/reference># 本地仓库覆盖到工作区(保留修改并加到暂存区)$ git reset --hard <commit/reference><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git cherry-pick 简单教程</title>
      <link href="2021/05/27/git-cherry-pick-jian-dan-jiao-cheng/"/>
      <url>2021/05/27/git-cherry-pick-jian-dan-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="git-cherry-pick-简单教程"><a href="#git-cherry-pick-简单教程" class="headerlink" title="git cherry-pick 简单教程"></a>git cherry-pick 简单教程</h1><p><img src="/2021/05/27/git-cherry-pick-jian-dan-jiao-cheng/4ce1759da0804fe086acd617202afbdf" alt="git cherry-pick 简单教程"></p><p>在上一篇文章说以为某些原因，我趁着下班前的功夫简单写了份规范文档，里面就提到使用cherry-pick 这个命令。</p><p>cherry-pick是一个可以提高开发效率的命令。</p><p>cherry-pick可以把其它分支上的commit一个个抽离出来，合并到指定分支上。</p><hr><h1 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h1><p>git cherry-pick命令的作用，就是将指定的提交（commit）应用于其他分支。</p><pre><code>$ git cherry-pick &lt;commitHash&gt;</code></pre><p>上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。</p><p>举例来说，代码仓库有master和feature两个分支。</p><pre><code>    a - b - c - d   Master         \           e - f - g Feature</code></pre><p>现在将提交f应用到master分支。</p><pre><code># 切换到 master 分支$ git checkout master# Cherry pick 操作$ git cherry-pick f</code></pre><p>上面的操作完成以后，代码库就变成了下面的样子。</p><pre><code>    a - b - c - d - f   Master         \           e - f - g Feature</code></pre><p>从上面可以看到，master分支的末尾增加了一个提交f。</p><p>git cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。</p><pre><code>$ git cherry-pick feature</code></pre><p>上面代码表示将feature分支的最近一次提交，转移到当前分支。</p><hr><h1 id="二、转移多个提交"><a href="#二、转移多个提交" class="headerlink" title="二、转移多个提交"></a>二、转移多个提交</h1><p>Cherry pick 支持一次转移多个提交。</p><pre><code>$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;</code></pre><p>上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。</p><p>如果想要转移一系列的连续提交，可以使用下面的简便语法。</p><pre><code>$ git cherry-pick A..B </code></pre><p>上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。</p><p>注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。</p><pre><code>$ git cherry-pick A^..B </code></pre><hr><h1 id="三、配置项"><a href="#三、配置项" class="headerlink" title="三、配置项"></a>三、配置项</h1><p>git cherry-pick命令的常用配置项如下。</p><p>（1）-e，–edit</p><p>打开外部编辑器，编辑提交信息。</p><p>（2）-n，–no-commit</p><p>只更新工作区和暂存区，不产生新的提交。</p><p>（3）-x</p><p>在提交信息的末尾追加一行(cherry picked from commit …)，方便以后查到这个提交是如何产生的。</p><p>（4）-s，–signoff</p><p>在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</p><p>（5）-m parent-number，–mainline parent-number</p><p>如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p><p>-m配置项告诉 Git，应该采用哪个分支的变动。它的参数parent-number是一个从1开始的整数，代表原始提交的父分支编号。</p><pre><code>$ git cherry-pick -m 1 &lt;commitHash&gt;</code></pre><p>上面命令表示，Cherry pick 采用提交commitHash来自编号1的父分支的变动。</p><p>一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。</p><hr><h1 id="四、代码冲突"><a href="#四、代码冲突" class="headerlink" title="四、代码冲突"></a>四、代码冲突</h1><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p><p>（1）–continue</p><p>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。</p><pre><code>$ git cherry-pick --continue</code></pre><p>（2）–abort</p><p>发生代码冲突后，放弃合并，回到操作前的样子。</p><p>（3）–quit</p><p>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</p><h1 id="五、转移到另一个代码库"><a href="#五、转移到另一个代码库" class="headerlink" title="五、转移到另一个代码库"></a>五、转移到另一个代码库</h1><p>Cherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。</p><pre><code>$ git remote add target git://gitUrl</code></pre><p>上面命令添加了一个远程仓库target。</p><p>然后，将远程代码抓取到本地。</p><pre><code>$ git fetch target</code></pre><p>上面命令将远程代码仓库抓取到本地。</p><p>接着，检查一下要从远程仓库转移的提交，获取它的哈希值。</p><pre><code>$ git log target/master</code></pre><p>最后，使用git cherry-pick命令转移提交。</p><pre><code>$ git cherry-pick &lt;commitHash&gt;</code></pre><p>（完）</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot配置大全</title>
      <link href="2021/05/25/springboot-pei-zhi-da-quan/"/>
      <url>2021/05/25/springboot-pei-zhi-da-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-配置文件中的花样，看这一篇足矣！"><a href="#Spring-Boot-配置文件中的花样，看这一篇足矣！" class="headerlink" title="Spring Boot 配置文件中的花样，看这一篇足矣！"></a>Spring Boot 配置文件中的花样，看这一篇足矣！</h1><p>在<a href="http://blog.didispace.com/spring-boot-learning-21-1-1/">快速入门</a>一节中，我们轻松的实现了一个简单的RESTful API应用，体验了一下Spring Boot给我们带来的诸多优点，我们用非常少的代码量就成功的实现了一个Web应用，这是传统的Spring应用无法办到的，虽然我们在实现Controller时用到的代码是一样的，但是在配置方面，相信大家也注意到了，在上面的例子中，除了Maven的配置之后，就没有引入任何的配置。</p><p>这就是之前我们所提到的，Spring Boot针对我们常用的开发场景提供了一系列自动化配置来减少原本复杂而又几乎很少改动的模板化配置内容。但是，我们还是需要去了解如何在Spring Boot中修改这些自动化的配置内容，以应对一些特殊的场景需求，比如：我们在同一台主机上需要启动多个基于Spring Boot的web应用，若我们不为每个应用指定特别的端口号，那么默认的8080端口必将导致冲突。</p><p>如果您还有在读我的<a href="http://blog.didispace.com/spring-cloud-learning/">Spring Cloud系列教程</a>，其实有大量的工作都会是针对配置文件的。所以我们有必要深入的了解一些关于Spring Boot中的配置文件的知识，比如：它的配置方式、如何实现多环境配置，配置信息的加载顺序等。</p><h2 id="配置基础"><a href="#配置基础" class="headerlink" title="配置基础"></a>配置基础</h2><p>在<a href="http://blog.didispace.com/spring-boot-learning-21-1-1/">快速入门</a>示例中，我们介绍Spring Boot的工程结构时，有提到过 <code>src/main/resources</code>目录是Spring Boot的配置目录，所以我们要为应用创建配置个性化配置时，就是在该目录之下。</p><p>Spring Boot的默认配置文件位置为： <code>src/main/resources/application.properties</code>。关于Spring Boot应用的配置内容都可以集中在该文件中了，根据我们引入的不同Starter模块，可以在这里定义诸如：容器端口名、数据库链接信息、日志级别等各种配置信息。比如，我们需要自定义web模块的服务端口号，可以在<code>application.properties</code>中添加<code>server.port=8888</code>来指定服务端口为8888，也可以通过<code>spring.application.name=hello</code>来指定应用名（该名字在Spring Cloud应用中会被注册为服务名）。</p><p>Spring Boot的配置文件除了可以使用传统的properties文件之外，还支持现在被广泛推荐使用的YAML文件。</p><blockquote><p>YAML（英语发音：/ˈjæməl/，尾音类似camel骆驼）是一个可读性高，用来表达资料序列的格式。YAML参考了其他多种语言，包括：C语言、Python、Perl，并从XML、电子邮件的数据格式（RFC 2822）中获得灵感。Clark Evans在2001年首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。目前已经有数种编程语言或脚本语言支援（或者说解析）这种语言。YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递回缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言），但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重新命名。AML的语法和其他高阶语言类似，并且可以简单表达清单、散列表，标量等资料形态。它使用空白符号缩排和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种设定档、倾印除错内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。尽管它比较适合用来表达阶层式（hierarchical model）的数据结构，不过也有精致的语法可以表示关联性（relational model）的资料。由于YAML使用空白字元和分行来分隔资料，使得它特别适合用grep／Python／Perl／Ruby操作。其让人最容易上手的特色是巧妙避开各种封闭符号，如：引号、各种括号等，这些符号在巢状结构时会变得复杂而难以辨认。 —— 维基百科</p></blockquote><p>YAML采用的配置格式不像properties的配置那样以单纯的键值对形式来表示，而是以类似大纲的缩进形式来表示。比如：下面的一段YAML配置信息</p><pre><code>environments:    dev:        url: http://dev.bar.com        name: Developer Setup    prod:        url: http://foo.bar.com        name: My Cool App复制代码</code></pre><p>与其等价的properties配置如下。</p><pre><code>environments.dev.url=http://dev.bar.comenvironments.dev.name=Developer Setupenvironments.prod.url=http://foo.bar.comenvironments.prod.name=My Cool App复制代码</code></pre><p>通过YAML的配置方式，我们可以看到配置信息利用阶梯化缩进的方式，其结构显得更为清晰易读，同时配置内容的字符量也得到显著的减少。除此之外，YAML还可以在一个单个文件中通过使用<code>spring.profiles</code>属性来定义多个不同的环境配置。例如下面的内容，在指定为test环境时，<code>server.port</code>将使用8882端口；而在prod环境，<code>server.port</code>将使用8883端口；如果没有指定环境，<code>server.port</code>将使用8881端口。</p><pre><code>server:    port: 8881---spring:    profiles: testserver:    port: 8882---spring:    profiles: prodserver:    port: 8883复制代码</code></pre><p><strong>注意：YAML目前还有一些不足，它无法通过<code>@PropertySource</code>注解来加载配置。但是，YAML加载属性到内存中保存的时候是有序的，所以当配置文件中的信息需要具备顺序含义时，YAML的配置方式比起properties配置文件更有优势。</strong></p><h3 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h3><p>我们除了可以在Spring Boot的配置文件中设置各个Starter模块中预定义的配置属性，也可以在配置文件中定义一些我们需要的自定义属性。比如在<code>application.properties</code>中添加：</p><pre><code>book.name=SpringCloudInActionbook.author=ZhaiYongchao复制代码</code></pre><p>然后，在应用中我们可以通过<code>@Value</code>注解来加载这些自定义的参数，比如：</p><pre><code>@Componentpublic class Book {    @Value("${book.name}")    private String name;    @Value("${book.author}")    private String author;    // 省略getter和setter}复制代码</code></pre><p><code>@Value</code>注解加载属性值的时候可以支持两种表达式来进行配置：</p><ul><li>一种是我们上面介绍的PlaceHolder方式，格式为 <code>${...}</code>，大括号内为PlaceHolder</li><li>另外还可以使用SpEL表达式（Spring Expression Language）， 格式为 <code>#{...}</code>，大括号内为SpEL表达式</li></ul><h3 id="参数引用"><a href="#参数引用" class="headerlink" title="参数引用"></a>参数引用</h3><p>在<code>application.properties</code>中的各个参数之间，我们也可以直接通过使用PlaceHolder的方式来进行引用，就像下面的设置：</p><pre><code>book.name=SpringCloudbook.author=ZhaiYongchaobook.desc=${book.author}  is writing《${book.name}》复制代码</code></pre><p><code>book.desc</code>参数引用了上文中定义的<code>book.name</code>和<code>book.author</code>属性，最后该属性的值就是<code>ZhaiYongchao is writing《SpringCloud》</code>。</p><h3 id="使用随机数"><a href="#使用随机数" class="headerlink" title="使用随机数"></a>使用随机数</h3><p>在一些特殊情况下，有些参数我们希望它每次加载的时候不是一个固定的值，比如：密钥、服务端口等。在Spring Boot的属性配置文件中，我们可以通过使用<code>${random}</code>配置来产生随机的int值、long值或者string字符串，这样我们就可以容易的通过配置来属性的随机生成，而不是在程序中通过编码来实现这些逻辑。</p><p><code>${random}</code>的配置方式主要有一下几种，读者可作为参考使用。</p><pre><code># 随机字符串com.didispace.blog.value=${random.value}# 随机intcom.didispace.blog.number=${random.int}# 随机longcom.didispace.blog.bignumber=${random.long}# 10以内的随机数com.didispace.blog.test1=${random.int(10)}# 10-20的随机数com.didispace.blog.test2=${random.int[10,20]}复制代码</code></pre><p><strong>该配置方式可以用于设置应用端口等场景，避免在本地调试时出现端口冲突的麻烦</strong></p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>回顾一下在本章的快速入门中，我们还介绍了如何启动Spring Boot应用，其中提到了使用命令<code>java -jar</code>命令来启动的方式。该命令除了启动应用之外，还可以在命令行中来指定应用的参数，比如：<code>java -jar xxx.jar --server.port=8888</code>，直接以命令行的方式，来设置server.port属性，另启动应用的端口设为8888。</p><p>在命令行方式启动Spring Boot应用时，连续的两个减号<code>--</code>就是对<code>application.properties</code>中的属性值进行赋值的标识。所以，<code>java -jar xxx.jar --server.port=8888</code>命令，等价于我们在<code>application.properties</code>中添加属性<code>server.port=8888</code>。</p><p>通过命令行来修改属性值是Spring Boot非常重要的一个特性，通过此特性，理论上已经使得我们应用的属性在启动前是可变的，所以其中端口号也好、数据库连接也好，都是可以在应用启动时发生改变，而不同于以往的Spring应用通过Maven的Profile在编译器进行不同环境的构建。其最大的区别就是，Spring Boot的这种方式，可以让应用程序的打包内容，贯穿开发、测试以及线上部署，而Maven不同Profile的方案每个环境所构建的包，其内容本质上是不同的。但是，如果每个参数都需要通过命令行来指定，这显然也不是一个好的方案，所以下面我们看看如果在Spring Boot中实现多环境的配置。</p><h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><p>我们在开发任何应用的时候，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。</p><p>对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。</p><p>在Spring Boot中多环境配置文件名需要满足<code>application-{profile}.properties</code>的格式，其中<code>{profile}</code>对应你的环境标识，比如：</p><ul><li><code>application-dev.properties</code>：开发环境</li><li><code>application-test.properties</code>：测试环境</li><li><code>application-prod.properties</code>：生产环境</li></ul><p>至于哪个具体的配置文件会被加载，需要在<code>application.properties</code>文件中通过<code>spring.profiles.active</code>属性来设置，其值对应配置文件中的<code>{profile}</code>值。如：<code>spring.profiles.active=test</code>就会加载<code>application-test.properties</code>配置文件内容。</p><p>下面，以不同环境配置不同的服务端口为例，进行样例实验。</p><ul><li>针对各环境新建不同的配置文件<code>application-dev.properties</code>、<code>application-test.properties</code>、<code>application-prod.properties</code></li><li>在这三个文件均都设置不同的<code>server.port</code>属性，如：dev环境设置为1111，test环境设置为2222，prod环境设置为3333</li><li>application.properties中设置<code>spring.profiles.active=dev</code>，就是说默认以dev环境设置</li><li>测试不同配置的加载</li><li>执行<code>java -jar xxx.jar</code>，可以观察到服务端口被设置为<code>1111</code>，也就是默认的开发环境（dev）</li><li>执行<code>java -jar xxx.jar --spring.profiles.active=test</code>，可以观察到服务端口被设置为<code>2222</code>，也就是测试环境的配置（test）</li><li>执行<code>java -jar xxx.jar --spring.profiles.active=prod</code>，可以观察到服务端口被设置为<code>3333</code>，也就是生产环境的配置（prod）</li></ul><p>按照上面的实验，可以如下总结多环境的配置思路：</p><ul><li><code>application.properties</code>中配置通用内容，并设置<code>spring.profiles.active=dev</code>，以开发环境为默认配置</li><li><code>application-{profile}.properties</code>中配置各个环境不同的内容</li><li>通过命令行方式去激活不同环境的配置</li></ul><h3 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h3><p>在上面的例子中，我们将Spring Boot应用需要的配置内容都放在了项目工程中，虽然我们已经能够通过<code>spring.profiles.active</code>或是通过Maven来实现多环境的支持。但是，当我们的团队逐渐壮大，分工越来越细致之后，往往我们不需要让开发人员知道测试或是生成环境的细节，而是希望由每个环境各自的负责人（QA或是运维）来集中维护这些信息。那么如果还是以这样的方式存储配置内容，对于不同环境配置的修改就不得不去获取工程内容来修改这些配置内容，当应用非常多的时候就变得非常不方便。同时，配置内容都对开发人员可见，本身这也是一种安全隐患。对此，现在出现了很多将配置内容外部化的框架和工具，后续将要介绍的Spring Cloud Config就是其中之一，为了后续能更好的理解Spring Cloud Config的加载机制，我们需要对Spring Boot对数据文件的加载机制有一定的了解。</p><p>Spring Boot为了能够更合理的重写各属性的值，使用了下面这种较为特别的属性加载顺序：</p><ol><li>命令行中传入的参数。</li><li><code>SPRING_APPLICATION_JSON</code>中的属性。<code>SPRING_APPLICATION_JSON</code>是以JSON格式配置在系统环境变量中的内容。</li><li><code>java:comp/env</code>中的<code>JNDI</code>属性。</li><li>Java的系统属性，可以通过<code>System.getProperties()</code>获得的内容。</li><li>操作系统的环境变量</li><li>通过<code>random.*</code>配置的随机属性</li><li>位于当前应用jar包之外，针对不同<code>{profile}</code>环境的配置文件内容，例如：<code>application-{profile}.properties</code>或是<code>YAML</code>定义的配置文件</li><li>位于当前应用jar包之内，针对不同<code>{profile}</code>环境的配置文件内容，例如：<code>application-{profile}.properties</code>或是<code>YAML</code>定义的配置文件</li><li>位于当前应用jar包之外的<code>application.properties</code>和<code>YAML</code>配置内容</li><li>位于当前应用jar包之内的<code>application.properties</code>和<code>YAML</code>配置内容</li><li>在<code>@Configuration</code>注解修改的类中，通过<code>@PropertySource</code>注解定义的属性</li><li>应用默认属性，使用<code>SpringApplication.setDefaultProperties</code>定义的内容</li></ol><p><strong>优先级按上面的顺序有高到低，数字越小优先级越高。</strong></p><p>可以看到，其中第7项和第9项都是从应用jar包之外读取配置文件，所以，实现外部化配置的原理就是从此切入，为其指定外部配置文件的加载位置来取代jar包之内的配置内容。通过这样的实现，我们的工程在配置中就变的非常干净，我们只需要在本地放置开发需要的配置即可，而其他环境的配置就可以不用关心，由其对应环境的负责人去维护即可。</p><h2 id="2-x-新特性"><a href="#2-x-新特性" class="headerlink" title="2.x 新特性"></a>2.x 新特性</h2><p>在Spring Boot 2.0中推出了Relaxed Binding 2.0，对原有的属性绑定功能做了非常多的改进以帮助我们更容易的在Spring应用中加载和读取配置信息。下面本文就来说说Spring Boot 2.0中对配置的改进。</p><h3 id="配置文件绑定"><a href="#配置文件绑定" class="headerlink" title="配置文件绑定"></a>配置文件绑定</h3><h4 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h4><p>在Spring Boot 2.0中对配置属性加载的时候会除了像1.x版本时候那样<strong>移除特殊字符</strong>外，还会将配置均以<strong>全小写</strong>的方式进行匹配和加载。所以，下面的4种配置方式都是等价的：</p><ul><li>properties格式：</li></ul><pre><code>spring.jpa.databaseplatform=mysqlspring.jpa.database-platform=mysqlspring.jpa.databasePlatform=mysqlspring.JPA.database_platform=mysql复制代码</code></pre><ul><li>yaml格式：</li></ul><pre><code>spring:  jpa:    databaseplatform: mysql    database-platform: mysql    databasePlatform: mysql    database_platform: mysql复制代码</code></pre><p><strong>Tips：推荐使用全小写配合<code>-</code>分隔符的方式来配置，比如：<code>spring.jpa.database-platform=mysql</code></strong></p><h4 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h4><p>在properties文件中使用<code>[]</code>来定位列表类型，比如：</p><pre><code>spring.my-example.url[0]=http://example.comspring.my-example.url[1]=http://spring.io复制代码</code></pre><p>也支持使用<strong>逗号</strong>分割的配置方式，上面与下面的配置是等价的：</p><pre><code>spring.my-example.url=http://example.com,http://spring.io复制代码</code></pre><p>而在yaml文件中使用可以使用如下配置：</p><pre><code>spring:  my-example:    url:      - http://example.com      - http://spring.io复制代码</code></pre><p>也支持<strong>逗号</strong>分割的方式：</p><pre><code>spring:  my-example:    url: http://example.com, http://spring.io复制代码</code></pre><p><strong>注意：在Spring Boot 2.0中对于List类型的配置必须是连续的，不然会抛出<code>UnboundConfigurationPropertiesException</code>异常，所以如下配置是不允许的：</strong></p><pre><code>foo[0]=afoo[2]=b复制代码</code></pre><p><strong>在Spring Boot 1.x中上述配置是可以的，<code>foo[1]</code>由于没有配置，它的值会是<code>null</code></strong></p><h4 id="Map类型"><a href="#Map类型" class="headerlink" title="Map类型"></a>Map类型</h4><p>Map类型在properties和yaml中的标准配置方式如下：</p><ul><li>properties格式：</li></ul><pre><code>spring.my-example.foo=barspring.my-example.hello=world复制代码</code></pre><ul><li>yaml格式：</li></ul><pre><code>spring:  my-example:    foo: bar    hello: world复制代码</code></pre><p><strong>注意：如果Map类型的key包含非字母数字和<code>-</code>的字符，需要用<code>[]</code>括起来，比如：</strong></p><pre><code>spring:  my-example:    '[foo.baz]': bar复制代码</code></pre><h3 id="环境属性绑定"><a href="#环境属性绑定" class="headerlink" title="环境属性绑定"></a>环境属性绑定</h3><p><strong>简单类型</strong></p><p>在环境变量中通过小写转换与<code>.</code>替换<code>_</code>来映射配置文件中的内容，比如：环境变量<code>SPRING_JPA_DATABASEPLATFORM=mysql</code>的配置会产生与在配置文件中设置<code>spring.jpa.databaseplatform=mysql</code>一样的效果。</p><p><strong>List类型</strong></p><p>由于环境变量中无法使用<code>[</code>和<code>]</code>符号，所以使用<code>_</code>来替代。任何由下划线包围的数字都会被认为是<code>[]</code>的数组形式。比如：</p><pre><code>MY_FOO_1_ = my.foo[1]MY_FOO_1_BAR = my.foo[1].barMY_FOO_1_2_ = my.foo[1][2]复制代码</code></pre><p>另外，最后环境变量最后是以数字和下划线结尾的话，最后的下划线可以省略，比如上面例子中的第一条和第三条等价于下面的配置：</p><pre><code>MY_FOO_1 = my.foo[1]MY_FOO_1_2 = my.foo[1][2]复制代码</code></pre><h3 id="系统属性绑定"><a href="#系统属性绑定" class="headerlink" title="系统属性绑定"></a>系统属性绑定</h3><p><strong>简单类型</strong></p><p>系统属性与文件配置中的类似，都以移除特殊字符并转化小写后实现绑定，比如下面的命令行参数都会实现配置<code>spring.jpa.databaseplatform=mysql</code>的效果：</p><pre><code>-Dspring.jpa.database-platform=mysql-Dspring.jpa.databasePlatform=mysql-Dspring.JPA.database_platform=mysql复制代码</code></pre><p><strong>List类型</strong></p><p>系统属性的绑定也与文件属性的绑定类似，通过<code>[]</code>来标示，比如：</p><pre><code>-D"spring.my-example.url[0]=http://example.com"-D"spring.my-example.url[1]=http://spring.io"复制代码</code></pre><p>同样的，他也支持逗号分割的方式，比如：</p><pre><code>-Dspring.my-example.url=http://example.com,http://spring.io复制代码</code></pre><h3 id="属性的读取"><a href="#属性的读取" class="headerlink" title="属性的读取"></a>属性的读取</h3><p>上文介绍了Spring Boot 2.0中对属性绑定的内容，可以看到对于一个属性我们可以有多种不同的表达，但是如果我们要在Spring应用程序的environment中读取属性的时候，每个属性的唯一名称符合如下规则：</p><ul><li>通过<code>.</code>分离各个元素</li><li>最后一个<code>.</code>将前缀与属性名称分开</li><li>必须是字母（a-z）和数字(0-9)</li><li>必须是小写字母</li><li>用连字符<code>-</code>来分隔单词</li><li>唯一允许的其他字符是<code>[</code>和<code>]</code>，用于List的索引</li><li>不能以数字开头</li></ul><p>所以，如果我们要读取配置文件中<code>spring.jpa.database-platform</code>的配置，可以这样写：</p><pre><code>this.environment.containsProperty("spring.jpa.database-platform")复制代码</code></pre><p>而下面的方式是无法获取到<code>spring.jpa.database-platform</code>配置内容的：</p><pre><code>this.environment.containsProperty("spring.jpa.databasePlatform")复制代码</code></pre><p><strong>注意：使用<code>@Value</code>获取配置内容的时候也需要这样的特点</strong></p><h3 id="全新的绑定API"><a href="#全新的绑定API" class="headerlink" title="全新的绑定API"></a>全新的绑定API</h3><p>在Spring Boot 2.0中增加了新的绑定API来帮助我们更容易的获取配置信息。下面举个例子来帮助大家更容易的理解：</p><p><strong>例子一：简单类型</strong></p><p>假设在propertes配置中有这样一个配置：<code>com.didispace.foo=bar</code></p><p>我们为它创建对应的配置类：</p><pre><code>@Data@ConfigurationProperties(prefix = "com.didispace")public class FooProperties {    private String foo;}复制代码</code></pre><p>接下来，通过最新的<code>Binder</code>就可以这样来拿配置信息了：</p><pre><code>@SpringBootApplicationpublic class Application {    public static void main(String[] args) {        ApplicationContext context = SpringApplication.run(Application.class, args);        Binder binder = Binder.get(context.getEnvironment());        // 绑定简单配置        FooProperties foo = binder.bind("com.didispace", Bindable.of(FooProperties.class)).get();        System.out.println(foo.getFoo());    }}复制代码</code></pre><p><strong>例子二：List类型</strong></p><p>如果配置内容是List类型呢？比如：</p><pre><code>com.didispace.post[0]=Why Spring Bootcom.didispace.post[1]=Why Spring Cloudcom.didispace.posts[0].title=Why Spring Bootcom.didispace.posts[0].content=It is perfect!com.didispace.posts[1].title=Why Spring Cloudcom.didispace.posts[1].content=It is perfect too!复制代码</code></pre><p>要获取这些配置依然很简单，可以这样实现：</p><pre><code>ApplicationContext context = SpringApplication.run(Application.class, args);Binder binder = Binder.get(context.getEnvironment());// 绑定List配置List&lt;String&gt; post = binder.bind("com.didispace.post", Bindable.listOf(String.class)).get();System.out.println(post);List&lt;PostInfo&gt; posts = binder.bind("com.didispace.posts", Bindable.listOf(PostInfo.class)).get();System.out.println(posts);复制代码</code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>本教程配套仓库：</p><ul><li>Github：<a href="https://github.com/dyc87112/SpringBoot-Learning/tree/2.x">github.com/dyc87112/Sp…</a></li><li>Gitee：<a href="https://gitee.com/didispace/SpringBoot-Learning/tree/2.x">gitee.com/didispace/S…</a></li></ul><p><strong>如果您觉得本文不错，欢迎Star、Follow支持！您的关注是我坚持的动力！</strong></p><h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><ul><li><a href="http://blog.didispace.com/springbootproperties/">Spring Boot 1.x：属性配置文件详解</a></li><li><a href="http://blog.didispace.com/Spring-Boot-2-0-feature-1-relaxed-binding-2/">Spring Boot 2.0：配置绑定 2.0 全解析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何一台机器同时使用多个git秘钥</title>
      <link href="2021/05/25/ru-he-yi-tai-ji-qi-tong-shi-shi-yong-duo-ge-git-mi-yao/"/>
      <url>2021/05/25/ru-he-yi-tai-ji-qi-tong-shi-shi-yong-duo-ge-git-mi-yao/</url>
      
        <content type="html"><![CDATA[<h1 id="如何一台机器同时使用多个git秘钥"><a href="#如何一台机器同时使用多个git秘钥" class="headerlink" title="如何一台机器同时使用多个git秘钥"></a>如何一台机器同时使用多个git秘钥</h1><blockquote><p>如果❤️我的文章有帮助，欢迎点赞、关注。这是对我继续技术创作最大的鼓励。</p></blockquote><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>公司一个 gitlab 代码仓库;个人一个 github 代码仓库;</p><p>然后最近 github 本来就慢，被<code>河蟹</code>之后丢包更严重了。所以为了不影响使用，又加了个国内码云 <code>gitee</code>；</p><p>正巧重新配了下 仓库秘钥，做个记录方便之后换机器、重置系统再用。</p><h2 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h2><blockquote><p>为了方便说明，我假设需要重新配置全部秘钥。如果机器上已经配置好其它秘钥，直接生成新的秘钥（注意不要覆盖 <code>已经生成好</code> 的秘钥）</p></blockquote><p>使用终端 ssh命令 生成 rsa秘钥</p><blockquote><p>ssh-keygen -t rsa -C “邮箱地址1” -f ~/.ssh/id_rsa_github</p></blockquote><p>-f 为秘钥存放地址。默认为<code>当前路径</code> 。一直回车下去，过程如下：</p><p><img src="/2021/05/25/ru-he-yi-tai-ji-qi-tong-shi-shi-yong-duo-ge-git-mi-yao/01b2dc42ceae402e9c877ce63b3d70a6~tplv-k3u1fbpfcp-watermark.image" alt="QQ截图20210524214918.png"></p><p>此时<code>~/.ssh</code>目录下会生成2个文件，分别对应 公钥<code>id_rsa_github.pub</code> 和 私钥<code>id_rsa_github</code> 。</p><h2 id="将公钥告诉git服务器"><a href="#将公钥告诉git服务器" class="headerlink" title="将公钥告诉git服务器"></a>将公钥告诉git服务器</h2><p>打开公钥文件，复制里面内容。</p><blockquote><p>vim id_rsa_github.pub</p></blockquote><p>登陆 <code>git服务器</code> (这里以github举例)。 github账户 &gt; setting选项 &gt; SSH and GPG keys，把 <code>公钥字符串</code> 粘贴里面的key输入框中，保存退出即可。</p><p><img src="/2021/05/25/ru-he-yi-tai-ji-qi-tong-shi-shi-yong-duo-ge-git-mi-yao/da29a21ed05747609526bd2564f88c15~tplv-k3u1fbpfcp-watermark.image" alt="QQ截图20210524215702.png"></p><p>通过命令 <code>ssh -T git@github.com</code> 测试，</p><p><img src="/2021/05/25/ru-he-yi-tai-ji-qi-tong-shi-shi-yong-duo-ge-git-mi-yao/d5047045333c4abfacb626d4279ee2a3~tplv-k3u1fbpfcp-watermark.image" alt="QQ截图20210524215917.png"> 如果出现上图提示，说明秘钥添加成功。</p><h2 id="配置多个秘钥"><a href="#配置多个秘钥" class="headerlink" title="配置多个秘钥"></a>配置多个秘钥</h2><p>我们重复步骤 <code>生成秘钥</code>、<code>将公钥告诉git服务器</code> 生成并配置新的秘钥后。 在 <code>.ssh</code> 目录下面新建 <code>config文件</code>，文件内容如下： 配置以下内容：</p><pre class="line-numbers language-config"><code class="language-config">Host github.com    HostName github.com    PreferredAuthentications publickey    IdentityFile ~/.ssh/id_rsa_github    user coderdaoHost github.com    HostName github.com    PreferredAuthentications publickey    IdentityFile ~/.ssh/id_rsa_gitee    user coderdao复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>HostName 指定秘钥使用域名，就能区分不同域名之间使用秘钥不同</p><p>保存后，测试 <code>ssh -T git@github.com</code>、<code>ssh -T git@gitee.com</code></p><p><img src="/2021/05/25/ru-he-yi-tai-ji-qi-tong-shi-shi-yong-duo-ge-git-mi-yao/4f00a0b0465843f9bba882c6e971f1d0~tplv-k3u1fbpfcp-watermark.image" alt="QQ截图20210524220724.png"> 上图所示，即配置多个git秘钥配置成功</p><h2 id="配置项目多个git仓库"><a href="#配置项目多个git仓库" class="headerlink" title="配置项目多个git仓库"></a>配置项目多个git仓库</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><blockquote><p>进入项目目录下执行</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell">$ git remote add github  ******$ git remote add gitee  ******<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>输入上面代码后，再输入</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell">$ git remote -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>terminal中打印</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell">gitee    https://gitee.com/***.git (fetch)gitee    https://gitee.com/***.git (push)github    https://github.com/***.git (fetch)github    https://github.com/*** (push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>推送代码</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell">$ git pull gitee master$ git push gitee master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>1.添加关联</p><pre class="line-numbers language-shell"><code class="language-shell">git remote set-url --add origin 仓库地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.推送</p><pre class="line-numbers language-shell"><code class="language-shell">$ git remote -v$ git push origin master:master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>好处，只需要推送一次就可以到两个仓库</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>如果配置 <code>config</code> 文件后，未能生效。本地 <code>git</code> 软件的配置存在缓存，可使用以下命令判断秘钥是否生效：</p><p><img src="/2021/05/25/ru-he-yi-tai-ji-qi-tong-shi-shi-yong-duo-ge-git-mi-yao/6639557d416d4db49fbaa7b7e82b120f~tplv-k3u1fbpfcp-watermark.image" alt="QQ截图20210524221347.png"></p><pre class="line-numbers language-shell"><code class="language-shell">$ cd ~/.ssh$ eval $(ssh-agent)Agent pid 3593$ exec ssh-agent bash$ ssh-add ~/.ssh/id_rsa_githubIdentity added: /c/Users/Administrator/.ssh/id_rsa_github$ ssh -T git@github.comHi coderdao! You've successfully authenticated, but GitHub does not provide shell access.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金额计算的4个坑</title>
      <link href="2021/05/21/jin-e-ji-suan-de-4-ge-keng/"/>
      <url>2021/05/21/jin-e-ji-suan-de-4-ge-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>电商项目开发时肯定少不了金额计算，金额计算时有很多让人坑人的地方，在此记录，以免被坑。</p><h4 id="1、多精度计算问题"><a href="#1、多精度计算问题" class="headerlink" title="1、多精度计算问题"></a>1、多精度计算问题</h4><p>多精度不能直接计算，会存在经度缺失的问题。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">double</span> num1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">double</span> num2 <span class="token operator">=</span> <span class="token number">31.2</span><span class="token punctuation">;</span>  <span class="token keyword">double</span> num3 <span class="token operator">=</span> <span class="token number">323.03</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span> <span class="token punctuation">(</span>num1<span class="token operator">+</span>num2<span class="token operator">+</span>num3<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 355.22999999999996   */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码，3 个数值想加之后却得出了一个很长的数值。</p><p>在 java 开发中可以通过 BigDecimal 进行数值类型的计算，详细可到 BigDecimal 工具类。</p><p>数据库也是一样，mysql中有float和double类型，通过sql直接累加数据也会有精度缺失的情况。如果要精确的数值计算，要使用mysql的decimal类型。</p><h4 id="2、包装类型比对"><a href="#2、包装类型比对" class="headerlink" title="2、包装类型比对"></a>2、包装类型比对</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Integer i1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>     Integer i2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>     Integer i3 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>     Integer i4 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token operator">==</span>i2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3<span class="token operator">==</span>i4<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// false</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码很神奇，同样是数值比对100的时候可以通过双等号返回true。200就返回false。</p><p>这是因为Integer的valueOf()方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Integer的valueOf方法</span><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>        <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在[-128,128]之间的数，可以通过双等于比对成功，之外的数值就会返回一个new一个新的Integer，因此会返回false。Double的比较就简单一点，双等于比对全是false。这是因为Double直接是返回了一个新的Double。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Double的valueOf方法</span><span class="token keyword">public</span> <span class="token keyword">static</span> Double <span class="token function">valueOf</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token keyword">throws</span> NumberFormatException <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在数值比对的时候乱的样子，那我发现他们都有eq方法，通过这个方法比对可以吗？<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484834&amp;idx=1&amp;sn=ea4af7434a399f6433d3a0ae3aac2d05&amp;chksm=eb538094dc240982f3793e54918b128aa4b683b995ac33dfc5c45579422e24bf5fcef3e4226b&amp;scene=21#wechat_redirect">金融系统中正确的金额计算及存储方式</a>这篇看下。</p><p>可以的，不管是Integer还是Double都存在一个equas方法，通过这个方法即可进行数值比对。但是这个方法不是很完美。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>  Double i1 <span class="token operator">=</span> <span class="token number">100d</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token punctuation">.</span><span class="token function">equals</span> <span class="token punctuation">(</span><span class="token string">"100"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//false</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示，因为太多的人都知道字符串类型不能用双等号进行比对，要用eq方法进行比对其value。</p><p>这样会让很多人误以为Integer和Double类型也是如此，而且在编码的时候如上这种写法也没有报错，会认为都是100肯定会返回true。恰巧这种想法是错误的。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Double</span><span class="token punctuation">)</span>           <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">doubleToLongBits</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Double<span class="token punctuation">)</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token operator">==</span>                  <span class="token function">doubleToLongBits</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Double的eq方法入参是Object类型，因此不管传入什么类型都不会报错。i1.equals (“100”)这种就是双精度和字符进行比对，这两个永远都不可能返回true。正确的写法应该是i1.equals (100d)。</p><p>但是尽管多次提醒，但是还是会有不认真的开发小伙伴错误，因此，可以使用Double.compareTo方法，这个方法和eq方法类似，但是有编译的异常，这样可有效的提醒开发人员。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>  Double i1 <span class="token operator">=</span> <span class="token number">100d</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token punctuation">.</span><span class="token function">compareTo</span> <span class="token punctuation">(</span><span class="token number">100d</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//0</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token punctuation">.</span><span class="token function">compareTo</span> <span class="token punctuation">(</span><span class="token number">1d</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3、除以0会怎样？"><a href="#3、除以0会怎样？" class="headerlink" title="3、除以0会怎样？"></a>3、除以0会怎样？</h4><p>小学的时候就讲过，进行除法运算时，除以0是没有意义的，开发过程中也是如此， 发现可能存在除以0的场景要特别注意，程序不会抛出异常，竟然会返回一个字符串！虽然这种场景不多，但是还是需要了解一下。</p><p>1除以0的场景：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Double d <span class="token operator">=</span> <span class="token number">1d</span><span class="token punctuation">;</span>  <span class="token keyword">double</span> v <span class="token operator">=</span> d <span class="token operator">/</span> <span class="token number">0d</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//Infinity</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>0除以0的场景：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Double d <span class="token operator">=</span> <span class="token number">0d</span><span class="token punctuation">;</span>  <span class="token keyword">double</span> v <span class="token operator">=</span> d <span class="token operator">/</span> <span class="token number">0d</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//NaN</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4、float转double"><a href="#4、float转double" class="headerlink" title="4、float转double"></a>4、float转double</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> Float f <span class="token operator">=</span> <span class="token number">12312.12f</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span><span class="token function">parseDouble</span> <span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">toString</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//12312.1201171875</span> <span class="token comment" spellcheck="true">//12312.12</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Float类中有一个doubleValue方法，返回值是一个double类型，这样会很容易的以为这是float转换double类型。但是转换之后精度缺失了，只能乖乖的换一种方式转换。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>起飞，会了这4个 Intellij IDEA 调试魔法，阅读源码都简单了</title>
      <link href="2021/05/14/idea-debug-magic/"/>
      <url>2021/05/14/idea-debug-magic/</url>
      
        <content type="html"><![CDATA[<p>前言</p><p>上一篇文章 IntelliJ IDEA 高级调试之Stream Trace 算是 IntelliJ IDEA 高级调试技巧的开胃菜，很多小伙伴被这个小技巧征服。趁热打铁，今天给大家带来几个我日常工作以及阅读源码必备的 IntelliJ IDEA 高级调试技巧，分分钟要起飞的节奏</p><h2 id="断点处添加-log"><a href="#断点处添加-log" class="headerlink" title="断点处添加 log"></a>断点处添加 log</h2><p>很多程序员在调试代码时都喜欢 print 一些内容，这样看起来更直观，print 完之后又很容易忘记删除掉这些没用的内容，最终将代码提交到 remote，code review 时又不得不删减这些内容重新提交，不但增加不必要的工作量，还让 log tree 的一些节点没有任何价值</p><p>IntelliJ IDEA 提供 Evaluate and Log at Breakpoints 功能恰巧可以帮助我们解决这个问题, 来看下面代码：</p><pre><code>public static void main(String[] args) {  ThreadLocalRandom random = ThreadLocalRandom.current();  int count = 0;  for (int i = 0; i &lt; 5; i++) {   if (isInterested(random.nextInt(10))) {    count++;   }  }  System.out.printf("Found %d interested values%n", count); } private static boolean isInterested(int i) {  return i % 2 == 0; }</code></pre><p>假如我们想在第 15 行查看每次调用，随即出来的 i 的值到底是多少，我们没必要在这个地方添加任何 log，在正常加断点的地方使用快捷键 Shift + 鼠标左键，就会弹出下面的内容</p><p><img src="/2021/05/14/idea-debug-magic/344f9e37c7c443a0b85e4902bb8e217e.png" alt="起飞，会了这4个 Intellij IDEA 调试魔法，阅读源码都简单了"></p><p>勾选上 Evaluate and log, 并自定义你想查看的 log/变量，比如这里的 “interested” + i, 这样以 Debug 模式运行程序（正常模式运行，不会打印这些 log）：</p><pre><code>interested 7interested 5interested 1interested 2interested 0Found 2 interested values</code></pre><p>如果你在多处添加了这种断点，简单地看 log 可能偶尔还是不够直观，可以勾选上面图片绿色框线的 “Breakpoint hit” message :</p><pre><code>Breakpoint reached at top.dayarch.TestDebug.isInterested(TestDebug.java:49)interested 6Breakpoint reached at top.dayarch.TestDebug.isInterested(TestDebug.java:49)interested 0Breakpoint reached at top.dayarch.TestDebug.isInterested(TestDebug.java:49)interested 9Breakpoint reached at top.dayarch.TestDebug.isInterested(TestDebug.java:49)interested 8Breakpoint reached at top.dayarch.TestDebug.isInterested(TestDebug.java:49)interested 1Found 3 interested valuesDisconnected from the target VM, address: '127.0.0.1:0', transport: 'socket'Process finished with exit code </code></pre><p>如果你想要更详细的信息，那就勾选上 Stack trace (大家自己查看运行结果吧)，有了这个功能，上面说的一些问题都不复存在了</p><h2 id="字段断点"><a href="#字段断点" class="headerlink" title="字段断点"></a>字段断点</h2><p>如果你阅读源码，你一定会有个困扰，类中的某个字段的值到底是在哪里改变的，你要一点点追踪调用栈，逐步排查，稍不留神，就可能有遗漏</p><blockquote><p>我们可以在 IntelliJ IDEA 中为某个字段添加断点，当字段值有修改时，自动跳到相应方法位置</p></blockquote><p>使用起来很简单：</p><ol><li>在字段定义处鼠标左键添加断点（会出现「眼睛」的图标）</li><li>在「眼睛」图标上鼠标右键</li><li>在弹框中勾选上 Field access 和 Field modification 两个选项</li></ol><p><img src="/2021/05/14/idea-debug-magic/77aa5385d71349c6963c0c31c5859449.png" alt="起飞，会了这4个 Intellij IDEA 调试魔法，阅读源码都简单了"></p><p>如果修改字段值的方法比较多，也可以在 Condition 的地方定义断点进入条件, 有了这个功能的加成，相信你阅读源码会顺畅许多</p><h2 id="异常断点"><a href="#异常断点" class="headerlink" title="异常断点"></a>异常断点</h2><p>除了阅读源码，一定是遇到了异常我们才开始调试代码，代码在抛出异常之后会自动停止，但是我们希望：</p><blockquote><p>代码停在抛出异常之前，方便我们查看当时的变量信息</p></blockquote><p>这时我们就用到了 Exception Breakpoints, 当抛出异常时，在 catch 的地方打上断点，可以通过下图的几个位置获取栈顶异常类型，比如这里的 NumberFormatException</p><p><img src="/2021/05/14/idea-debug-magic/b0db37f62b324326b1d65f169d2ac65b.png" alt="起飞，会了这4个 Intellij IDEA 调试魔法，阅读源码都简单了"></p><p>知道异常类型后，就可以按照如下步骤添加异常断点了：</p><p><img src="/2021/05/14/idea-debug-magic/6d611df6b88344ba92e663fe6ccd2b90.png" alt="起飞，会了这4个 Intellij IDEA 调试魔法，阅读源码都简单了"></p><p>然后在弹框中选择 NumberFormatException</p><p><img src="/2021/05/14/idea-debug-magic/03bce91b7f994ec296d846c6d1f8cde1.png" alt="起飞，会了这4个 Intellij IDEA 调试魔法，阅读源码都简单了"></p><p>重新以 Debug 模式运行程序：</p><p><img src="/2021/05/14/idea-debug-magic/daea378523184f2b88ed43717c787860.png" alt="起飞，会了这4个 Intellij IDEA 调试魔法，阅读源码都简单了"></p><p>程序「一路绿灯式」定位到抛出异常的位置，同时指出当时的变量信息，三个字：稳，准，狠，还有谁？</p><h2 id="方法断点"><a href="#方法断点" class="headerlink" title="方法断点"></a>方法断点</h2><p>当阅读源码时，比如 Spring，一个接口的方法可能被多个子类实现，当运行时，需要查看调用栈逐步定位实现类，IDEA 同样支持在接口方法上添加断点（快捷键cmd+F8/ctrl+F8）：</p><ol><li>鼠标左键在方法处点击断点（♦️形状）</li><li>断点上鼠标右键</li></ol><p>勾选上绿色框线上的内容，同样可以自定义跳转条件 Condition</p><p><img src="/2021/05/14/idea-debug-magic/4afab593f7344249b73a65599f65d0b9.png" alt="起飞，会了这4个 Intellij IDEA 调试魔法，阅读源码都简单了"></p><p>当以 Debug 模式运行程序的时候，会自动进入实现类的方法（注意断点形状）：</p><p><img src="/2021/05/14/idea-debug-magic/e14c20113f2543979c55d729d5199044.png" alt="起飞，会了这4个 Intellij IDEA 调试魔法，阅读源码都简单了"></p><p>看到这你应该想到常见的 Runnable 接口中的 run 方法了，同样是有作用的，大家可以自行去尝试了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相信有以上四种调试技巧的加成，无论是工作debug 还是私下阅读源码，都可以轻松驾驭了。最后，来看看 IDEA 支持的各种断点调试类型，如果你只知道红色小圆点，那咱在留言区好好说说吧</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 开启idea远程调试</title>
      <link href="2021/05/11/remotedebug/"/>
      <url>2021/05/11/remotedebug/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器上开启远程调试端口"><a href="#服务器上开启远程调试端口" class="headerlink" title="服务器上开启远程调试端口"></a>服务器上开启远程调试端口</h2><pre class="line-numbers language-shell"><code class="language-shell">nohup java -jar demo.jar -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="idea添加一个Remote"><a href="#idea添加一个Remote" class="headerlink" title="idea添加一个Remote"></a>idea添加一个Remote</h2><p>在开发工具里面新增一个 Remote 配置：</p><p><img src="/2021/05/11/remotedebug/641.png" alt="图片"></p><p>只需要确定 Host、Port 参数即可。</p><ul><li>Host：地址</li></ul><p>localhost：本地启动地址；</p><ul><li>Port：端口</li></ul><p>5005：上面命令行指定的端口；</p><h2 id="3、开始调试"><a href="#3、开始调试" class="headerlink" title="3、开始调试"></a>3、开始调试</h2><p>先启动加了 <code>jvmArguments</code> 参数的 Spring Boot 项目：</p><p><img src="/2021/05/11/remotedebug/642.png" alt="图片"></p><p>程序停在监听端口：5005，再 debug 启动Remote：</p><p><img src="/2021/05/11/remotedebug/643.png" alt="图片"></p><p>再回到项目，开始启动输出日志，然后就可以进行断点调试了。</p>]]></content>
      
      
      <categories>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logback</title>
      <link href="2021/05/07/logback/"/>
      <url>2021/05/07/logback/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"><a href="#SpringBoot系列——Logback日志输出到文件以及实时输出到web页面" class="headerlink" title="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></a>SpringBoot系列——Logback日志输出到文件以及实时输出到web页面</h1><p>huanzi一qch2021-05-01 08:38:00</p><h2 id="前言"><a href="#前言" class="headerlink" title="　　前言"></a>　　前言</h2><p>　　SpringBoot对所有内部日志使用通用日志记录，但保留底层日志实现。为Java Util Logging、Log4J2和Logback提供了默认配置。在不同的情况下，日志记录器都预先配置为使用控制台输出，同时还提供可选的文件输出。默认情况下，SpringBoot使用Logback进行日志记录。</p><p>　　日志级别有（从高到低）：<strong>FATAL</strong>（致命），<strong>ERROR</strong>（错误），<strong>WARN</strong>（警告），<strong>INFO</strong>（信息），<strong>DEBUG</strong>（调试），<strong>TRACE</strong>（跟踪）或者 <strong>OFF</strong>（关闭），默认的日志配置在消息写入时将消息回显到控制台。默认情况下，将记录错误级别、警告级别和信息级别的消息。</p><p>　　PS：Logback does not have a FATAL level. It is mapped to ERROR Logback没有FATAL致命级别。它被映射到ERROR错误级别</p><p>　　详情请戳官方文档：<a href="https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#boot-features-logging">https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#boot-features-logging</a></p><p>　　本文主要记录Logback日志输出到文件以及实时输出到web页面</p><h2 id="输出到文件"><a href="#输出到文件" class="headerlink" title="　　输出到文件"></a>　　输出到文件</h2><p>　　我们创建SpringBoot项目时，spring-boot-starter已经包含了spring-boot-starter-logging，不需要再进行引入依赖</p><h2 id="标准日志格式"><a href="#标准日志格式" class="headerlink" title="　　标准日志格式"></a>　　标准日志格式</h2><pre><code>2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.522014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]</code></pre><ul><li>Date and Time: Millisecond precision and easily sortable. 日期和时间:毫秒精度，易于排序。</li><li>Log Level: ERROR, WARN, INFO, DEBUG, or TRACE. 日志级别:错误、警告、信息、调试或跟踪。</li><li>Process ID. 进程ID。</li><li>A — separator to distinguish the start of actual log messages. 分隔符，用于区分实际日志消息的开始。</li><li>Thread name: Enclosed in square brackets (may be truncated for console output). 线程名称:括在方括号中(可能会被截断以用于控制台输出)。</li><li>Logger name: This is usually the source class name (often abbreviated). 日志程序名称:这通常是源类名称(通常缩写)。</li><li>The log message. 日志消息。</li></ul><p>　　如何打印日志？</p><p>　　方法1</p><pre><code>    /**     * 配置内部类     */    @Controller    @Configuration    class Config {        /**         * 获取日志对象，构造函数传入当前类，查找日志方便定位         */        private final Logger log = LoggerFactory.getLogger(this.getClass());        @Value("${user.home}")        private String userName;        /**         * 端口         */        @Value("${server.port}")        private String port;/**         * 启动成功         */        @Bean        public ApplicationRunner applicationRunner() {            return applicationArguments -&gt; {                try {                    InetAddress ia = InetAddress.getLocalHost();                    //获取本机内网IP                    log.info("启动成功：" + "http://" + ia.getHostAddress() + ":" + port + "/");                    log.info("${user.home} ：" + userName);                } catch (UnknownHostException ex) {                    ex.printStackTrace();                }            };        }    }</code></pre><p>　　方法2 使用lombok的@Slf4j，帮我们创建Logger对象，效果与方法1一样</p><pre><code>    /**     * 配置内部类     */    @Controller    @Configuration    class Config {        /**         * 获取日志对象，构造函数传入当前类，查找日志方便定位         */        private final Logger log = LoggerFactory.getLogger(this.getClass());        @Value("${user.home}")        private String userName;        /**         * 端口         */        @Value("${server.port}")        private String port;/**         * 启动成功         */        @Bean        public ApplicationRunner applicationRunner() {            return applicationArguments -&gt; {                try {                    InetAddress ia = InetAddress.getLocalHost();                    //获取本机内网IP                    log.info("启动成功：" + "http://" + ia.getHostAddress() + ":" + port + "/");                    log.info("${user.home} ：" + userName);                } catch (UnknownHostException ex) {                    ex.printStackTrace();                }            };        }    }</code></pre><p>　　简单配置</p><p>　　如果不需要进行复杂的日志配置，则在配置文件中进行简单的日志配置即可，默认情况下，SpringBoot日志只记录到控制台，不写日志文件。如果希望在控制台输出之外编写日志文件，则需要进行配置</p><pre><code>  logging:    path: /Users/Administrator/Desktop/杂七杂八/ims #日志文件路径    file: ims.log #日志文件名称    level:      root: info #日志级别 root表示所有包，也可以单独配置具体包 fatal error warn info debug trace off</code></pre><p>　　重新启动项目</p><p><img src="/2021/05/07/logback/4d86c1dd47654f87b0e0e630d53098a4" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p>　　打开ims.log</p><p><img src="/2021/05/07/logback/26d546ffbe8042fcb5ab71124009fbcd" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><h2 id="扩展配置"><a href="#扩展配置" class="headerlink" title="　　扩展配置"></a>　　扩展配置</h2><p>　　Spring Boot包含许多Logback扩展，可以帮助进行高级配置。您可以在您的logback-spring.xml配置文件中使用这些扩展。如果需要比较复杂的配置，建议使用扩展配置的方式</p><p>　　PS：SpringBoot推荐我们使用带-spring后缀的 logback-spring.xml 扩展配置，因为默认的的logback.xml标准配置，Spring无法完全控制日志初始化。（spring扩展对springProfile节点的支持）</p><p>　　以下是项目常见的完整logback-spring.xml，SpringBoot默认扫描classpath下面的logback.xml、logback-spring.xml，所以不需要再指定spring.logging.config，当然，你指定也没有问题</p><pre><code>logging:  config: classpath:logback-spring.xml</code></pre><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration debug="false"&gt;    &lt;!--日志文件主目录：这里${user.home}为当前服务器用户主目录--&gt;    &lt;property name="LOG_HOME" value="${user.home}/log"/&gt;    &lt;!--日志文件名称：这里spring.application.name表示工程名称--&gt;    &lt;springProperty scope="context" name="APP_NAME" source="spring.application.name"/&gt;    &lt;!--默认配置--&gt;    &lt;include resource="org/springframework/boot/logging/logback/defaults.xml"/&gt;    &lt;!--配置控制台(Console)--&gt;    &lt;include resource="org/springframework/boot/logging/logback/console-appender.xml"/&gt;    &lt;!--配置日志文件(File)--&gt;    &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;        &lt;!--设置策略--&gt;        &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;            &lt;!--日志文件路径：这里%d{yyyyMMdd}表示按天分类日志--&gt;            &lt;FileNamePattern&gt;${LOG_HOME}/%d{yyyyMMdd}/${APP_NAME}.log&lt;/FileNamePattern&gt;            &lt;!--日志保留天数--&gt;            &lt;MaxHistory&gt;15&lt;/MaxHistory&gt;        &lt;/rollingPolicy&gt;        &lt;!--设置格式--&gt;        &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt;            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt;            &lt;!-- 或者使用默认配置 --&gt;            &lt;!--&lt;pattern&gt;${FILE_LOG_PATTERN}&lt;/pattern&gt;--&gt;            &lt;charset&gt;utf8&lt;/charset&gt;        &lt;/encoder&gt;        &lt;!--日志文件最大的大小--&gt;        &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt;            &lt;MaxFileSize&gt;100MB&lt;/MaxFileSize&gt;        &lt;/triggeringPolicy&gt;    &lt;/appender&gt;    &lt;!-- 多环境配置 按照active profile选择分支 --&gt;    &lt;springProfile name="dev"&gt;        &lt;!--root节点 全局日志级别，用来指定最基础的日志输出级别--&gt;        &lt;root level="INFO"&gt;            &lt;appender-ref ref="FILE"/&gt;            &lt;appender-ref ref="CONSOLE"/&gt;        &lt;/root&gt;        &lt;!-- 子节点向上级传递 局部日志级别--&gt;        &lt;logger level="WARN" name="org.springframework"/&gt;        &lt;logger level="WARN" name="com.netflix"/&gt;        &lt;logger level="DEBUG" name="org.hibernate.SQL"/&gt;    &lt;/springProfile&gt;    &lt;springProfile name="prod"&gt;    &lt;/springProfile&gt;&lt;/configuration&gt;</code></pre><p>　　启动项目，去到${user.home}当前服务器用户主目录，日志按日期进行产生，如果项目产生的日志文件比较大，还可以按照小时进行.log文件的生成　　</p><p><img src="/2021/05/07/logback/eca04244d392432d89bfcb26e9e7abf9" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p><img src="/2021/05/07/logback/80fca921176c47fe99ce8916f2b6953b" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p><img src="/2021/05/07/logback/ac6bedabe7374ecfaa53698ed054f44c" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p>　　2021-02-24更新：</p><p>　　如果需要按日志级别分别输出到对应的日志文件，在appender标签新增filter标签进行指定</p><pre><code>&lt;!-- 时间滚动输出 level为 【debug / info / warn / error】 日志 --&gt;&lt;appender name="【DEBUG / INFO / WARN / ERROR】_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;    &lt;!-- 忽略其他配置 --&gt;    &lt;!-- 此日志文件只记录 【debug / info / warn / error】 级别的 --&gt;    &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt;        &lt;level&gt;【debug / info / warn / error】&lt;/level&gt;        &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;        &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;    &lt;/filter&gt;&lt;/appender&gt;</code></pre><p>　　输出到Web页面</p><p>　　我们已经有日志文件.log了，为什么还要这个功能呢？（滑稽脸）为了偷懒！</p><p>　　当我们把项目部署到Linux服务器，当你想看日志文件，还得打开xshell连接，定位到log文件夹，麻烦；如果我们把日志输出到Web页面，当做超级管理员或者测试账号下面的一个功能，点击就开始实时获取生成的日志并输出在Web页面，是不是爽很多呢？</p><p>　　PS：这个功能可得小心使用，因为日志会暴露很多信息</p><h2 id="LoggingWSServer"><a href="#LoggingWSServer" class="headerlink" title="　　LoggingWSServer"></a>　　LoggingWSServer</h2><p>　　使用WebSocket实现实时获取，建立WebSocket连接后创建一个线程任务，每秒读取一次最新的日志文件，第一次只取后面200行，后面取相比上次新增的行，为了在页面上更加方便的阅读日志，对日志级别单词进行着色（PS：如何创建springboot的websocket，请戳：SpringBoot系列——WebSocket）</p><pre><code>package cn.huanzi.qch.springbootlogback;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import org.thymeleaf.util.StringUtils;import javax.websocket.*;import javax.websocket.server.ServerEndpoint;import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * WebSocket获取实时日志并输出到Web页面 */@Slf4j@Component@ServerEndpoint(value = "/websocket/logging", configurator = MyEndpointConfigure.class)public class LoggingWSServer {    @Value("${spring.application.name}")    private String applicationName;    /**     * 连接集合     */    private static Map&lt;String, Session&gt; sessionMap = new ConcurrentHashMap&lt;String, Session&gt;();    private static Map&lt;String, Integer&gt; lengthMap = new ConcurrentHashMap&lt;String, Integer&gt;();    /**     * 连接建立成功调用的方法     */    @OnOpen    public void onOpen(Session session) {        //添加到集合中        sessionMap.put(session.getId(), session);        lengthMap.put(session.getId(), 1);//默认从第一行开始        //获取日志信息        new Thread(() -&gt; {            log.info("LoggingWebSocketServer 任务开始");            boolean first = true;            while (sessionMap.get(session.getId()) != null) {                BufferedReader reader = null;                try {                    //日志文件路径，获取最新的                    String filePath = System.getProperty("user.home") + "/log/" + new SimpleDateFormat("yyyyMMdd").format(new Date()) + "/"+applicationName+".log";                    //字符流                    reader = new BufferedReader(new FileReader(filePath));                    Object[] lines = reader.lines().toArray();                    //只取从上次之后产生的日志                    Object[] copyOfRange = Arrays.copyOfRange(lines, lengthMap.get(session.getId()), lines.length);                    //对日志进行着色，更加美观  PS：注意，这里要根据日志生成规则来操作                    for (int i = 0; i &lt; copyOfRange.length; i++) {                        String line = (String) copyOfRange[i];                        //先转义                        line = line.replaceAll("&amp;", "&amp;")                                .replaceAll("&lt;", "&lt;")                                .replaceAll("&gt;", "&gt;")                                .replaceAll("\"", """);                        //处理等级                        line = line.replace("DEBUG", "&lt;span style='color: blue;'&gt;DEBUG&lt;/span&gt;");                        line = line.replace("INFO", "&lt;span style='color: green;'&gt;INFO&lt;/span&gt;");                        line = line.replace("WARN", "&lt;span style='color: orange;'&gt;WARN&lt;/span&gt;");                        line = line.replace("ERROR", "&lt;span style='color: red;'&gt;ERROR&lt;/span&gt;");                        //处理类名                        String[] split = line.split("]");                        if (split.length &gt;= 2) {                            String[] split1 = split[1].split("-");                            if (split1.length &gt;= 2) {                                line = split[0] + "]" + "&lt;span style='color: #298a8a;'&gt;" + split1[0] + "&lt;/span&gt;" + "-" + split1[1];                            }                        }                        copyOfRange[i] = line;                    }                    //存储最新一行开始                    lengthMap.put(session.getId(), lines.length);                    //第一次如果太大，截取最新的200行就够了，避免传输的数据太大                    if(first &amp;&amp; copyOfRange.length &gt; 200){                        copyOfRange = Arrays.copyOfRange(copyOfRange, copyOfRange.length - 200, copyOfRange.length);                        first = false;                    }                    String result = StringUtils.join(copyOfRange, "&lt;br/&gt;");                    //发送                    send(session, result);                    //休眠一秒                    Thread.sleep(1000);                } catch (Exception e) {                    //捕获但不处理                    e.printStackTrace();                } finally {                    try {                        reader.close();                    } catch (IOException ignored) {                    }                }            }            log.info("LoggingWebSocketServer 任务结束");        }).start();    }    /**     * 连接关闭调用的方法     */    @OnClose    public void onClose(Session session) {        //从集合中删除        sessionMap.remove(session.getId());        lengthMap.remove(session.getId());    }    /**     * 发生错误时调用     */    @OnError    public void onError(Session session, Throwable error) {        error.printStackTrace();    }    /**     * 服务器接收到客户端消息时调用的方法     */    @OnMessage    public void onMessage(String message, Session session) {    }    /**     * 封装一个send方法，发送消息到前端     */    private void send(Session session, String message) {        try {            session.getBasicRemote().sendText(message);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h2 id="HTML页面"><a href="#HTML页面" class="headerlink" title="　　HTML页面"></a>　　HTML页面</h2><p>　　页面收到数据就追加到div中，为了方便新增了几个功能：</p><p>　　清屏，清空div内容</p><p>　　滚动至底部、将div的滚动条滑到最下面</p><p>　　开启/关闭自动滚动，div新增内容后自动将滚动条滑到最下面，点一下开启，再点关闭，默认关闭</p><p>　　PS：引入公用部分，就是一些jquery等常用静态资源</p><pre><code>&lt;!DOCTYPE&gt;&lt;!--解决idea thymeleaf 表达式模板报红波浪线--&gt;&lt;!--suppress ALL --&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;IMS实时日志&lt;/title&gt;    &lt;!-- 引入公用部分 --&gt;    &lt;script th:replace="head::static"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 标题 --&gt;&lt;h1 style="text-align: center;"&gt;IMS实时日志&lt;/h1&gt;&lt;!-- 显示区 --&gt;&lt;div id="loggingText" contenteditable="true"     style="width:100%;height: 600px;background-color: ghostwhite; overflow: auto;"&gt;&lt;/div&gt;&lt;!-- 操作栏 --&gt;&lt;div style="text-align: center;"&gt;    &lt;button onclick="$('#loggingText').text('')" style="color: green; height: 35px;"&gt;清屏&lt;/button&gt;    &lt;button onclick="$('#loggingText').animate({scrollTop:$('#loggingText')[0].scrollHeight});"            style="color: green; height: 35px;"&gt;滚动至底部    &lt;/button&gt;    &lt;button onclick="if(window.loggingAutoBottom){$(this).text('开启自动滚动');}else{$(this).text('关闭自动滚动');};window.loggingAutoBottom = !window.loggingAutoBottom"            style="color: green; height: 35px; "&gt;开启自动滚动    &lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;script th:inline="javascript"&gt;    //websocket对象    let websocket = null;    //判断当前浏览器是否支持WebSocket    if ('WebSocket' in window) {        websocket = new WebSocket("ws://localhost:10086/websocket/logging");    } else {        console.error("不支持WebSocket");    }    //连接发生错误的回调方法    websocket.onerror = function (e) {        console.error("WebSocket连接发生错误");    };    //连接成功建立的回调方法    websocket.onopen = function () {        console.log("WebSocket连接成功")    };    //接收到消息的回调方法    websocket.onmessage = function (event) {        //追加        if (event.data) {            //日志内容            let $loggingText = $("#loggingText");            $loggingText.append(event.data);            //是否开启自动底部            if (window.loggingAutoBottom) {                //滚动条自动到最底部                $loggingText.scrollTop($loggingText[0].scrollHeight);            }        }    }    //连接关闭的回调方法    websocket.onclose = function () {        console.log("WebSocket连接关闭")    };&lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="　　效果展示"></a>　　效果展示</h2><p><img src="/2021/05/07/logback/c4dcc12ef0e94b808260cf16e9a40833" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><h2 id="后记"><a href="#后记" class="headerlink" title="　　后记"></a>　　后记</h2><p>　　有了日志记录，我们以后写代码时就要注意了，应使用下面的正确示例</p><pre><code>//错误示例，这样写只会输出到控制台，不会输出到日志中System.out.println("XXX");e.printStackTrace();//正确示例，既输出到控制台，又输出到日志log.info("XXX");log.error("XXX报错",e);</code></pre><p>　　SpringBoot日志暂时先记录到这里，点击官网了解更多：<a href="https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#boot-features-logging">https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#boot-features-logging</a></p><h2 id="补充"><a href="#补充" class="headerlink" title="　　补充"></a>　　补充</h2><p>　　2019-07-03补充：我们之前只对日志等级关键字进行着色，还是觉得不够，因此又新增了类名着色跟HTML转义</p><p>　　主要修改：</p><p><img src="/2021/05/07/logback/3c11312fe6664fd3af4a8f707c39a60d" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p>　　效果：</p><p><img src="/2021/05/07/logback/3eee5655c3f84a5688d65281291cd143" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p><img src="/2021/05/07/logback/f252a7bf864543a0bd91aee3cf8a646b" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p>　　2019-08-12补充：我发现有时候显示的时候，换行不太准确，我们原先是在行末追加<br>，但有时候读取出来的一行记录是自动换行后的数据，页面显示效果很丑</p><p><img src="/2021/05/07/logback/e6feb9f33c1544acaef4443690df663b" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p>　　因此我改成用正则（[\d+][\d+][\d+][\d+]-[\d+][\d+]-[\d+][\d+] [\d+][\d+]:[\d+][\d+]:[\d+][\d+]）去匹配日期，然后再对应的起始下标插入<br>，从而达到与控制台输出类似的效果</p><p><img src="/2021/05/07/logback/ca16db25bd71484e95d79dfeecb926c2" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p>　　匹配、插入结果</p><p><img src="/2021/05/07/logback/588557f0651749eead2861e42b0449dc" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p>　　页面效果</p><p><img src="/2021/05/07/logback/f0863c1c02f64b2bacf00242b49ea024" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p>　　异步输出日志</p><p>　　异步输出日志的方式很简单，添加一个基于异步写日志的appender，并指向原先配置的appender即可</p><pre><code>    &lt;!-- 将文件输出设置成异步输出 --&gt;    &lt;appender name="ASYNC-FILE" class="ch.qos.logback.classic.AsyncAppender"&gt;        &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;        &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt;        &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;        &lt;queueSize&gt;256&lt;/queueSize&gt;        &lt;!-- 添加附加的appender,最多只能添加一个 --&gt;        &lt;appender-ref ref="FILE"/&gt;    &lt;/appender&gt;    &lt;!-- 将控制台输出设置成异步输出 --&gt;    &lt;appender name="ASYNC-CONSOLE" class="ch.qos.logback.classic.AsyncAppender"&gt;        &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;        &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt;        &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;        &lt;queueSize&gt;256&lt;/queueSize&gt;        &lt;!-- 添加附加的appender,最多只能添加一个 --&gt;        &lt;appender-ref ref="CONSOLE"/&gt;    &lt;/appender&gt;</code></pre><p>　　原理很简单，主线程将日志扔到阻塞队列中，然后IO操作日志写入文件是通过新起一个线程去完成的</p><p>　　2020-05-26补充</p><p>　　e.printStackTrace();会打出详细异常,异常名称,出错位置,便于调试用，但直接调用会输出到std.err，并没有输出到日志文件中，因此需要先输出到流中再转成字符串</p><p>　　封装工具类</p><pre><code>import java.io.IOException;import java.io.PrintWriter;import java.io.StringWriter;/** * 捕获报错日志处理工具类 */public class ErrorUtil {    /**     * Exception出错的栈信息转成字符串     * 用于打印到日志中     */    public static String errorInfoToString(Throwable e) {        StringWriter sw = null;        PrintWriter pw = null;        try {            sw = new StringWriter();            pw = new PrintWriter(sw);            // 将出错的栈信息输出到printWriter中            e.printStackTrace(pw);            pw.flush();            sw.flush();        } finally {            if (sw != null) {                try {                    sw.close();                } catch (IOException e1) {                    e1.printStackTrace();                }            }            if (pw != null) {                pw.close();            }        }        return sw.toString();    }}</code></pre><p>　　也可以使用骚操作简化代码</p><pre><code>    public static String errorInfoToString(Throwable e) {        //try-with-resource语法糖 处理机制        try(StringWriter sw = new StringWriter();PrintWriter pw = new PrintWriter(sw)){            e.printStackTrace(pw);            pw.flush();            sw.flush();            return sw.toString();        }catch (Exception ignored){            throw new RuntimeException(ignored.getMessage(),ignored);        }    }</code></pre><p>　　使用</p><pre><code>try {            //省略其他代码} catch (Throwable e) {            //之前的操作，输出控制台            e.printStackTrace();            //输出到日志文件中            log.error(ErrorUtil.errorInfoToString(e));}</code></pre><h2 id="配置访问日志"><a href="#配置访问日志" class="headerlink" title="　　配置访问日志"></a>　　配置访问日志</h2><p>　　2020-08-04更新</p><p>　　SpringBoot默认使用内置Tomcat，那么我们如何配置Tomcat的Access Logging呢？</p><p>　　详情可查看官方文档：</p><p>　　SpringBoot配置介绍：<a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#howto-configure-accesslogs">https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#howto-configure-accesslogs</a></p><p>　　Apache Tomcat配置介绍：<a href="https://tomcat.apache.org/tomcat-8.5-doc/config/valve.html#Access_Logging">https://tomcat.apache.org/tomcat-8.5-doc/config/valve.html#Access_Logging</a></p><p>　　SpringBoot对Access Log的默认配置</p><pre><code>server.tomcat.accesslog.buffered=true # Whether to buffer output such that it is flushed only periodically.server.tomcat.accesslog.directory=logs # Directory in which log files are created. Can be absolute or relative to the Tomcat base dir.server.tomcat.accesslog.enabled=false # Enable access log.server.tomcat.accesslog.file-date-format=.yyyy-MM-dd # Date format to place in the log file name.server.tomcat.accesslog.pattern=common # Format pattern for access logs.server.tomcat.accesslog.prefix=access_log # Log file name prefix.server.tomcat.accesslog.rename-on-rotate=false # Whether to defer inclusion of the date stamp in the file name until rotate time.server.tomcat.accesslog.request-attributes-enabled=false # Set request attributes for the IP address, Hostname, protocol, and port used for the request.server.tomcat.accesslog.rotate=true # Whether to enable access log rotation.server.tomcat.accesslog.suffix=.log # Log file name suffix.</code></pre><p>　　日志格式说明（摘自上方Apache Tomcat配置介绍官方文档）</p><p>Values for the pattern attribute are made up of literal text strings, combined with pattern identifiers prefixed by the “%” character to cause replacement by the corresponding variable value from the current request and response. The following pattern codes are supported:</p><ul><li><strong>%a</strong> - Remote IP address</li><li><strong>%A</strong> - Local IP address</li><li><strong>%b</strong> - Bytes sent, excluding HTTP headers, or ‘-‘ if zero</li><li><strong>%B</strong> - Bytes sent, excluding HTTP headers</li><li><strong>%h</strong> - Remote host name (or IP address if enableLookups for the connector is false)</li><li><strong>%H</strong> - Request protocol</li><li><strong>%l</strong> - Remote logical username from identd (always returns ‘-‘)</li><li><strong>%m</strong> - Request method (GET, POST, etc.)</li><li><strong>%p</strong> - Local port on which this request was received. See also %{xxx}p below.</li><li><strong>%q</strong> - Query string (prepended with a ‘?’ if it exists)</li><li><strong>%r</strong> - First line of the request (method and request URI)</li><li><strong>%s</strong> - HTTP status code of the response</li><li><strong>%S</strong> - User session ID</li><li><strong>%t</strong> - Date and time, in Common Log Format</li><li><strong>%u</strong> - Remote user that was authenticated (if any), else ‘-‘</li><li><strong>%U</strong> - Requested URL path</li><li><strong>%v</strong> - Local server name</li><li><strong>%D</strong> - Time taken to process the request in millis. Note: In httpd %D is microseconds. Behaviour will be aligned to httpd in Tomcat 10 onwards.</li><li><strong>%T</strong> - Time taken to process the request, in seconds. Note: This value has millisecond resolution whereas in httpd it has second resolution. Behaviour will be align to httpd in Tomcat 10 onwards.</li><li><strong>%F</strong> - Time taken to commit the response, in millis</li><li><strong>%I</strong> - Current request thread name (can compare later with stacktraces)</li><li><strong>%X</strong> - Connection status when response is completed:X = Connection aborted before the response completed.+ = Connection may be kept alive after the response is sent.- = Connection will be closed after the response is sent.</li></ul><p>There is also support to write information incoming or outgoing headers, cookies, session or request attributes and special timestamp formats. It is modeled after the Apache HTTP Server log configuration syntax. Each of them can be used multiple times with different xxx keys:</p><ul><li><strong>%{xxx}i</strong> write value of incoming header with name xxx</li><li><strong>%{xxx}o</strong> write value of outgoing header with name xxx</li><li><strong>%{xxx}c</strong> write value of cookie with name xxx</li><li><strong>%{xxx}r</strong> write value of ServletRequest attribute with name xxx</li><li><strong>%{xxx}s</strong> write value of HttpSession attribute with name xxx</li><li><strong>%{xxx}p</strong> write local (server) port (xxx==local) or remote (client) port (xxx=remote)</li><li><strong>%{xxx}t</strong> write timestamp at the end of the request formatted using the enhanced SimpleDateFormat pattern xxx</li></ul><p>All formats supported by SimpleDateFormat are allowed in %{xxx}t. In addition the following extensions have been added:</p><ul><li><strong>sec</strong> - number of seconds since the epoch</li><li><strong>msec</strong> - number of milliseconds since the epoch</li><li><strong>msec_frac</strong> - millisecond fraction</li></ul><p>These formats cannot be mixed with SimpleDateFormat formats in the same format token.</p><p>Furthermore one can define whether to log the timestamp for the request start time or the response finish time:</p><ul><li><strong>begin</strong> or prefix <strong>begin:</strong> chooses the request start time</li><li><strong>end</strong> or prefix <strong>end:</strong> chooses the response finish time</li></ul><p>By adding multiple %{xxx}t tokens to the pattern, one can also log both timestamps.</p><p>The shorthand pattern pattern=”common” corresponds to the Common Log Format defined by <strong>‘%h %l %u %t “%r” %s %b’</strong>.</p><p>The shorthand pattern pattern=”combined” appends the values of the Referer and User-Agent headers, each in double quotes, to the common pattern.</p><p>When Tomcat is operating behind a reverse proxy, the client information logged by the Access Log Valve may represent the reverse proxy, the browser or some combination of the two depending on the configuration of Tomcat and the reverse proxy. For Tomcat configuration options see Proxies Support and the Proxy How-To. For reverse proxies that use mod_jk, see the generic proxy documentation. For other reverse proxies, consult their documentation.</p><p>　　我们只需要配置以下几个简单配置即可</p><pre><code>#开启内置Tomcat请求日志 access.logserver.tomcat.accesslog.enabled=true#日志格式server.tomcat.accesslog.pattern=%h %l %u %t "%r" %s %b#日志输出目录server.tomcat.accesslog.directory=${user.home}/log/accesslog/${spring.application.name}#日志文件名server.tomcat.accesslog.prefix=access_logserver.tomcat.accesslog.file-date-format=_yyyy-MM-ddserver.tomcat.accesslog.suffix=.log</code></pre><p>　　效果</p><p><img src="/2021/05/07/logback/df9eaeabde9a49d7a92415c401bed351" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p><img src="/2021/05/07/logback/6011876796624038ba85b98382243e65" alt="SpringBoot系列——Logback日志输出到文件以及实时输出到web页面"></p><p>　　如何接口统计QPS？</p><p>　　如上图中，logging接口，我们只要统计同一秒中，logging接口的请求次数即是该接口的QPS</p><h2 id="代码开源"><a href="#代码开源" class="headerlink" title="　　代码开源"></a>　　代码开源</h2><p>　　代码已经开源、托管到我的GitHub、码云：</p><p>　　GitHub：<a href="https://github.com/huanzi-qch/springBoot">https://github.com/huanzi-qch/springBoot</a></p><p>　　码云：<a href="https://gitee.com/huanzi-qch/springBoot">https://gitee.com/huanzi-qch/springBoot</a></p><h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><p>作者：huanzi-qch</p><p>出处：<br><a href="https://www.cnblogs.com/huanzi-qch">https://www.cnblogs.com/huanzi-qch</a></p><p>若标题中有“转载”字样，则本文版权归原作者所有。若无转载字样，本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，否则保留追究法律责任的权利.</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logback </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dataway</title>
      <link href="2021/04/25/dataway/"/>
      <url>2021/04/25/dataway/</url>
      
        <content type="html"><![CDATA[<h1 id="Dataway介绍"><a href="#Dataway介绍" class="headerlink" title="Dataway介绍"></a>Dataway介绍</h1><blockquote><p>Dataway 是基于 DataQL 服务聚合能力，为应用提供的一个接口配置工具。使得使用者无需开发任何代码就配置一个满足需求的接口。整个接口配置、测试、冒烟、发布。一站式都通过 Dataway 提供的 UI 界面完成。UI 会以 Jar 包方式提供并集成到应用中并和应用共享同一个 http 端口，应用无需单独为 Dataway 开辟新的管理端口。</p><p>这种内嵌集成方式模式的优点是，可以使得大部分老项目都可以在无侵入的情况下直接应用 Dataway。进而改进老项目的迭代效率，大大减少企业项目研发成本。</p><p>Dataway 工具化的提供 DataQL 配置能力。这种研发模式的变革使得，相当多的需求开发场景只需要配置即可完成交付。从而避免了从数据存取到前端接口之间的一系列开发任务，例如：Mapper、BO、VO、DO、DAO、Service、Controller 统统不在需要。</p></blockquote><p>Dataway 是 Hasor 生态中的一员，因此在 Spring 中使用 Dataway 首先要做的就是打通两个生态。</p><p>根据官方文档中推荐的方式我们将 Hasor 和 Spring Boot 整合起来。</p><h1 id="第一步：引入相关依赖"><a href="#第一步：引入相关依赖" class="headerlink" title="第一步：引入相关依赖"></a>第一步：引入相关依赖</h1><pre><code>&lt;dependency&gt;    &lt;groupId&gt;net.hasor&lt;/groupId&gt;    &lt;artifactId&gt;hasor-spring&lt;/artifactId&gt;    &lt;version&gt;4.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;net.hasor&lt;/groupId&gt;    &lt;artifactId&gt;hasor-dataway&lt;/artifactId&gt;    &lt;version&gt;4.1.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>hasor-spring 负责 Spring 和 Hasor 框架之间的整合。</p><p>hasor-dataway 是工作在 Hasor 之上，利用 hasor-spring 我们就可以使用 dataway了。</p><h1 id="第二步：配置-Dataway，并初始化数据表"><a href="#第二步：配置-Dataway，并初始化数据表" class="headerlink" title="第二步：配置 Dataway，并初始化数据表"></a>第二步：配置 Dataway，并初始化数据表</h1><p>dataway 会提供一个界面让我们配置接口，这一点类似 Swagger 只要jar包集成就可以实现接口配置。Spring Boot 基础就不介绍了</p><p>找到我们 springboot 项目的配置文件 **application.properties</p><pre><code># 是否启用 Dataway 功能（必选：默认false）HASOR_DATAQL_DATAWAY=true# 是否开启 Dataway 后台管理界面（必选：默认false）HASOR_DATAQL_DATAWAY_ADMIN=true# dataway  API工作路径（可选，默认：/api/）HASOR_DATAQL_DATAWAY_API_URL=/api/# dataway-ui 的工作路径（可选，默认：/interface-ui/）HASOR_DATAQL_DATAWAY_UI_URL=/interface-ui/# SQL执行器方言设置（可选，建议设置）HASOR_DATAQL_FX_PAGE_DIALECT=mysql</code></pre><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247527378&amp;idx=2&amp;sn=7dd65370cd9ce604592049d119465f9b&amp;chksm=eb50eee4dc2767f2f00bd8ce8af22fa55f068f3669d749c04ffc7ca92c9dc7457b1ac64faa53&amp;scene=21#wechat_redirect">Dataway 一共涉及到 5个可以配置的配置项，但不是所有配置都是必须的。</a></p><p>其中 <strong>HASOR_DATAQL_DATAWAY</strong>、<strong>HASOR_DATAQL_DATAWAY_ADMIN</strong> 两个配置是必须要打开的，默认情况下 Datawaty 是不启用的。</p><p>Dataway 需要两个数据表才能工作，下面是这两个数据表的简表语句。下面这个 SQL 可以在 dataway的依赖 jar 包中 “META-INF/hasor-framework/mysql” 目录下面找到，建表语句是用 mysql 语法写的。</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247524678&amp;idx=3&amp;sn=a153fd4fae16c357d55414e067d7bf25&amp;chksm=eb50e470dc276d6676c923b597cbd28cf29e7a31393f1f03afedaf22f6aaf9e0e5517b9bdb32&amp;scene=21#wechat_redirect">其它数据库的建表语句请参看官方说明手册：https://www.hasor.net/web/dataway/for_boot.html#mysql</a></p><pre><code>CREATE TABLE `interface_info` (    `api_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT 'ID',    `api_method`      varchar(12)  NOT NULL                  COMMENT 'HttpMethod：GET、PUT、POST',    `api_path`        varchar(512) NOT NULL                  COMMENT '拦截路径',    `api_status`      int(2)       NOT NULL                  COMMENT '状态：0草稿，1发布，2有变更，3禁用',    `api_comment`     varchar(255)     NULL                  COMMENT '注释',    `api_type`        varchar(24)  NOT NULL                  COMMENT '脚本类型：SQL、DataQL',    `api_script`      mediumtext   NOT NULL                  COMMENT '查询脚本：xxxxxxx',    `api_schema`      mediumtext       NULL                  COMMENT '接口的请求/响应数据结构',    `api_sample`      mediumtext       NULL                  COMMENT '请求/响应/请求头样本数据',    `api_option`      mediumtext       NULL                  COMMENT '扩展配置信息',    `api_create_time` datetime     DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',    `api_gmt_time`    datetime     DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',    PRIMARY KEY (`api_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT='Dataway 中的API';CREATE TABLE `interface_release` (    `pub_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT 'Publish ID',    `pub_api_id`      int(11)      NOT NULL                  COMMENT '所属API ID',    `pub_method`      varchar(12)  NOT NULL                  COMMENT 'HttpMethod：GET、PUT、POST',    `pub_path`        varchar(512) NOT NULL                  COMMENT '拦截路径',    `pub_status`      int(2)       NOT NULL                  COMMENT '状态：0有效，1无效（可能被下线）',    `pub_type`        varchar(24)  NOT NULL                  COMMENT '脚本类型：SQL、DataQL',    `pub_script`      mediumtext   NOT NULL                  COMMENT '查询脚本：xxxxxxx',    `pub_script_ori`  mediumtext   NOT NULL                  COMMENT '原始查询脚本，仅当类型为SQL时不同',    `pub_schema`      mediumtext       NULL                  COMMENT '接口的请求/响应数据结构',    `pub_sample`      mediumtext       NULL                  COMMENT '请求/响应/请求头样本数据',    `pub_option`      mediumtext       NULL                  COMMENT '扩展配置信息',    `pub_release_time`datetime     DEFAULT CURRENT_TIMESTAMP COMMENT '发布时间（下线不更新）',    PRIMARY KEY (`pub_id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT='Dataway API 发布历史。';create index idx_interface_release on interface_release (pub_api_id);</code></pre><h1 id="第三步：配置数据源"><a href="#第三步：配置数据源" class="headerlink" title="第三步：配置数据源"></a>第三步：配置数据源</h1><p>作为 Spring Boot 项目有着自己完善的数据库方面工具支持。我们这次采用 druid + mysql + spring-boot-starter-jdbc 的方式。<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247527378&amp;idx=2&amp;sn=7dd65370cd9ce604592049d119465f9b&amp;chksm=eb50eee4dc2767f2f00bd8ce8af22fa55f068f3669d749c04ffc7ca92c9dc7457b1ac64faa53&amp;scene=21#wechat_redirect">Spring Boot 学习笔记</a>，分享给你。</p><p>首先引入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.21&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>然后增加数据源的配置</p><pre><code># dbspring.datasource.url=jdbc:mysql://xxxxxxx:3306/examplespring.datasource.username=xxxxxspring.datasource.password=xxxxxspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.type:com.alibaba.druid.pool.DruidDataSource# druidspring.datasource.druid.initial-size=3spring.datasource.druid.min-idle=3spring.datasource.druid.max-active=10spring.datasource.druid.max-wait=60000spring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=adminspring.datasource.druid.filter.stat.log-slow-sql=truespring.datasource.druid.filter.stat.slow-sql-millis=1</code></pre><p>如果项目已经集成了自己的数据源，那么可以忽略第三步。</p><h1 id="第四步：把数据源设置到-Hasor-容器中"><a href="#第四步：把数据源设置到-Hasor-容器中" class="headerlink" title="第四步：把数据源设置到 Hasor 容器中"></a>第四步：把数据源设置到 Hasor 容器中</h1><p>Spring Boot 和 Hasor 本是两个独立的容器框架，我们做整合之后为了使用 Dataway 的能力需要把 Spring 中的数据源设置到 Hasor 中</p><p>首先新建一个 Hasor 的 模块，并且将其交给 Spring 管理。然后把数据源通过 Spring 注入进来。</p><pre><code>@DimModule@Componentpublic class ExampleModule implements SpringModule {    @Autowired    private DataSource dataSource = null;    @Override    public void loadModule(ApiBinder apiBinder) throws Throwable {        // .DataSource form Spring boot into Hasor        apiBinder.installModule(new JdbcModule(Level.Full, this.dataSource));    }}</code></pre><p>Hasor 启动的时候会调用 loadModule 方法，在这里再把 DataSource 设置到 Hasor 中。</p><h1 id="第五步：在SprintBoot-中启用-Hasor"><a href="#第五步：在SprintBoot-中启用-Hasor" class="headerlink" title="第五步：在SprintBoot 中启用 Hasor"></a>第五步：在SprintBoot 中启用 Hasor</h1><pre><code>@EnableHasor()@EnableHasorWeb()@SpringBootApplication(scanBasePackages = { "net.example.hasor" })public class ExampleApplication {    public static void main(String[] args) {        SpringApplication.run(ExampleApplication.class, args);    }}</code></pre><p>这一步非常简单，只需要在 Spring 启动类上增加两个注解即可。Spring Boot 基础就不介绍了</p><h1 id="第六步：启动应用"><a href="#第六步：启动应用" class="headerlink" title="第六步：启动应用"></a>第六步：启动应用</h1><p>应用在启动过程中会看到 Hasor Boot 的欢迎信息</p><pre><code> _    _                        ____              _| |  | |                      |  _             | || |__| | __ _ ___  ___  _ __  | |_) | ___   ___ | |_|  __  |/ _` / __|/ _ | '__| |  _ &lt; / _  / _ | __|| |  | | (_| __  (_) | |    | |_) | (_) | (_) | |_|_|  |_|__,_|___/___/|_|    |____/ ___/ ___/ __|</code></pre><p>在后面的日志中还可以看到类似下面这些日志。</p><pre><code>2020-04-14 13:52:59.696 [main] INFO  n.h.core.context.TemplateAppContext - loadModule class net.hasor.dataway.config.DatawayModule2020-04-14 13:52:59.697 [main] INFO  n.hasor.dataway.config.DatawayModule - dataway api workAt /api/2020-04-14 13:52:59.697 [main] INFO  n.h.c.e.AbstractEnvironment - var -&gt; HASOR_DATAQL_DATAWAY_API_URL = /api/.2020-04-14 13:52:59.704 [main] INFO  n.hasor.dataway.config.DatawayModule - dataway admin workAt /interface-ui/2020-04-14 13:52:59.716 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[901d38f22faa419a8593bb349905ed0e] -&gt; bindType ‘class net.hasor.dataway.web.ApiDetailController’ mappingTo: ‘[/interface-ui/api/api-detail]’.2020-04-14 13:52:59.716 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[c6eb9f3b3d4c4c8d8a4f807435538172] -&gt; bindType ‘class net.hasor.dataway.web.ApiHistoryListController’ mappingTo: ‘[/interface-ui/api/api-history]’.2020-04-14 13:52:59.717 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[eb841dc72ad54023957233ef602c4327] -&gt; bindType ‘class net.hasor.dataway.web.ApiInfoController’ mappingTo: ‘[/interface-ui/api/api-info]’.2020-04-14 13:52:59.717 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[96aebb46265245459ae21d558e530921] -&gt; bindType ‘class net.hasor.dataway.web.ApiListController’ mappingTo: ‘[/interface-ui/api/api-list]’.2020-04-14 13:52:59.718 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[7467c07f160244df8f228321f6262d3d] -&gt; bindType ‘class net.hasor.dataway.web.ApiHistoryGetController’ mappingTo: ‘[/interface-ui/api/get-history]’.2020-04-14 13:52:59.719 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[97d8da5363c741ba99d87c073a344412] -&gt; bindType ‘class net.hasor.dataway.web.DisableController’ mappingTo: ‘[/interface-ui/api/disable]’.2020-04-14 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[8ddc3316ef2642dfa4395ca8ac0fff04] -&gt; bindType ‘class net.hasor.dataway.web.SmokeController’ mappingTo: ‘[/interface-ui/api/smoke]’.2020-04-14 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[cc06c5fb343b471aacedc58fb2fe7bf8] -&gt; bindType ‘class net.hasor.dataway.web.SaveApiController’ mappingTo: ‘[/interface-ui/api/save-api]’.2020-04-14 13:52:59.720 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[7915b2b1f89a4e73891edab0264c9bd4] -&gt; bindType ‘class net.hasor.dataway.web.PublishController’ mappingTo: ‘[/interface-ui/api/publish]’.2020-04-14 13:52:59.721 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[0cfa34586455414591bdc389bff23ccb] -&gt; bindType ‘class net.hasor.dataway.web.PerformController’ mappingTo: ‘[/interface-ui/api/perform]’.2020-04-14 13:52:59.721 [main] INFO  net.hasor.core.binder.ApiBinderWrap - mapingTo[37fe4af3e2994acb8deb72d21f02217c] -&gt; bindType ‘class net.hasor.dataway.web.DeleteController’ mappingTo: ‘[/interface-ui/api/delete]’.</code></pre><p>当看到 “dataway api workAt <strong>/api/**” 、 dataway admin workAt **/interface-ui/</strong> 信息时，就可以确定 Dataway 的配置已经生效了。</p><h1 id="第七步：访问接口管理页面进行接口配置"><a href="#第七步：访问接口管理页面进行接口配置" class="headerlink" title="第七步：访问接口管理页面进行接口配置"></a>第七步：访问接口管理页面进行接口配置</h1><p>在浏览器中输入 “<a href="http://127.0.0.1:8080/interface-ui/%E2%80%9D">http://127.0.0.1:8080/interface-ui/”</a> 就可以看到期待已久的界面了。</p><p><img src="/2021/04/25/dataway/640.png" alt="图片"></p><h1 id="第八步：新建一个接口"><a href="#第八步：新建一个接口" class="headerlink" title="第八步：新建一个接口"></a>第八步：新建一个接口</h1><p>Dataway 提供了2中语言模式，我们可以使用强大的 DataQL 查询语言，也可以直接使用 SQL 语言（在 Dataway 内部 SQL 语言也会被转换为 DataQL 的形式执行。）</p><p><img src="/2021/04/25/dataway/641.png" alt="图片"></p><p>首先我们在 SQL 模式下尝试执行一条 select 查询，立刻就可以看到这条 SQL 的查询结果。</p><p><img src="/2021/04/25/dataway/642-1619491879578.jpg" alt="图片"></p><p>同样的方式我们使用 DataQL 的方式需要这样写：</p><pre><code>var query = @@sql()&lt;%    select * from interface_info%&gt;return query()</code></pre><p>其中 var query = <strong>@@sql()&lt;% … %&gt;</strong> 是用来定义SQL外部代码块，并将这个定义存入 query 变量名中。&lt;% %&gt; 中间的就是 SQL 语句。</p><p>最后在 DataQL 中调用这个代码块，并返回查询结果。</p><p>当接口写好之后就可以保存发布了，为了测试方便，我选用 GET 方式。</p><p><img src="/2021/04/25/dataway/643.jpg" alt="图片"></p><p>接口发布之后我们直接请求：<a href="http://127.0.0.1:8080/api/demos%EF%BC%8C%E5%B0%B1%E7%9C%8B%E5%88%B0%E6%9C%9F%E5%BE%85%E5%B7%B2%E4%B9%85%E7%9A%84%E6%8E%A5%E5%8F%A3%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BA%86%E3%80%82">http://127.0.0.1:8080/api/demos，就看到期待已久的接口返回值了。</a></p><p><img src="/2021/04/25/dataway/644.jpg" alt="图片"></p><h1 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h1><p>经过上面的几个步骤我们介绍了如何基于 Spring Boot 项目使用 Dataway 来简单的配置接口。</p><p>Dataway 的方式确实给人耳目一新，一个接口竟然可以如此简单的配置出来无需开发任何一行代码，也不需要做任何 Mapping 实体映射绑定。最后，关注公众号Java技术栈，在后台回复：面试，可以获取我整理的 Java、Spring 系列面试题和答案，非常齐全。</p><p>最后放几个有用的连接：</p><ul><li><em>Dataway 官方手册：<a href="https://www.hasor.net/web/dataway/about.html">https://www.hasor.net/web/dataway/about.html</a></em></li><li><em>Dataway 在 OSC 上的项目地址：<a href="https://www.oschina.net/p/dataway">https://www.oschina.net/p/dataway</a></em></li><li><em>DataQL 手册地址：<a href="https://www.hasor.net/web/dataql/what_is_dataql.html">https://www.hasor.net/web/dataql/what_is_dataql.html</a></em></li><li><em>Hasor 项目的首页：<a href="https://www.hasor.net/web/index.html">https://www.hasor.net/web/index.html</a></em></li></ul>]]></content>
      
      
      <categories>
          
          <category> dataway </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> dataway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis自定义注解+拦截器优雅的实现敏感数据的加解密</title>
      <link href="2021/04/25/mybatis-zi-ding-yi-zhu-jie-lan-jie-qi-you-ya-de-shi-xian-min-gan-shu-ju-de-jia-jie-mi/"/>
      <url>2021/04/25/mybatis-zi-ding-yi-zhu-jie-lan-jie-qi-you-ya-de-shi-xian-min-gan-shu-ju-de-jia-jie-mi/</url>
      
        <content type="html"><![CDATA[<p>在实际生产项目中，经常需要对如身份证信息、手机号、真实姓名等的敏感数据进行加密数据库存储，但在业务代码中对敏感信息进行手动加解密则十分不优雅，甚至会存在错加密、漏加密、业务人员需要知道实际的加密规则等的情况。</p><p>本文将介绍使用springboot+mybatis拦截器+自定义注解的形式对敏感数据进行存储前拦截加密的详细过程。</p><h2 id="1、什么是Mybatis-Plugin"><a href="#1、什么是Mybatis-Plugin" class="headerlink" title="1、什么是Mybatis Plugin"></a>1、什么是Mybatis Plugin</h2><p>在mybatis官方文档中，对于Mybatis plugin的的介绍是这样的：</p><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><pre><code>//语句执行拦截Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)// 参数获取、设置时进行拦截ParameterHandler (getParameterObject, setParameters)// 对返回结果进行拦截ResultSetHandler (handleResultSets, handleOutputParameters)//sql语句拦截StatementHandler (prepare, parameterize, batch, update, query)</code></pre><p>简而言之，即在执行sql的整个周期中，我们可以任意切入到某一点对sql的参数、sql执行结果集、sql语句本身等进行切面处理。基于这个特性，我们便可以使用其对我们需要进行加密的数据进行切面统一加密处理了（分页插件 pageHelper 就是这样实现数据库分页查询的）。</p><h2 id="2、实现基于注解的敏感信息加解密拦截器"><a href="#2、实现基于注解的敏感信息加解密拦截器" class="headerlink" title="2、实现基于注解的敏感信息加解密拦截器"></a>2、实现基于注解的敏感信息加解密拦截器</h2><h3 id="2-1-实现思路"><a href="#2-1-实现思路" class="headerlink" title="2.1 实现思路"></a><strong>2.1 实现思路</strong></h3><p>对于数据的加密与解密，应当存在两个拦截器对数据进行拦截操作</p><p>参照官方文档，因此此处我们应当使用ParameterHandler拦截器对入参进行加密</p><p>使用ResultSetHandler拦截器对出参进行解密操作。</p><p><img src="/2021/04/25/mybatis-zi-ding-yi-zhu-jie-lan-jie-qi-you-ya-de-shi-xian-min-gan-shu-ju-de-jia-jie-mi/640.jpg" alt="图片"></p><p>目标需要加密、解密的字段可能需要灵活变更，此时我们定义一个注解，对需要加密的字段进行注解，那么便可以配合拦截器对需要的数据进行加密与解密操作了。</p><p>mybatis的interceptor接口有以下方法需要实现。</p><pre><code>public interface Interceptor {  //主要参数拦截方法  Object intercept(Invocation invocation) throws Throwable;  //mybatis插件链  default Object plugin(Object target) {return Plugin.wrap(target, this);}  //自定义插件配置文件方法  default void setProperties(Properties properties) {}}</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="2-2-定义需要加密解密的敏感信息注解"><a href="#2-2-定义需要加密解密的敏感信息注解" class="headerlink" title="2.2 定义需要加密解密的敏感信息注解"></a><strong>2.2 定义需要加密解密的敏感信息注解</strong></h3><p>定义注解敏感信息类（如实体类POJO\PO）的注解</p><pre><code>/** * 注解敏感信息类的注解 */@Inherited@Target({ ElementType.TYPE })@Retention(RetentionPolicy.RUNTIME)public @interface SensitiveData {}</code></pre><p>定义注解敏感信息类中敏感字段的注解</p><pre><code>/** * 注解敏感信息类中敏感字段的注解 */@Inherited@Target({ ElementType.Field })@Retention(RetentionPolicy.RUNTIME)public @interface SensitiveField {}</code></pre><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="2-3-定义加密接口及其实现类"><a href="#2-3-定义加密接口及其实现类" class="headerlink" title="2.3 定义加密接口及其实现类"></a><strong>2.3 定义加密接口及其实现类</strong></h3><p>定义加密接口，方便以后拓展加密方法（如AES加密算法拓展支持PBE算法，只需要注入时指定一下便可）</p><pre><code>public interface EncryptUtil {    /**     * 加密     *     * @param declaredFields paramsObject所声明的字段     * @param paramsObject   mapper中paramsType的实例     * @return T     * @throws IllegalAccessException 字段不可访问异常     */     &lt;T&gt; T encrypt(Field[] declaredFields, T paramsObject) throws IllegalAccessException;}</code></pre><p>EncryptUtil 的AES加密实现类，此处AESUtil为自封装的AES加密工具，需要的小伙伴可以自行封装，本文不提供。</p><pre><code>@Componentpublic class AESEncrypt implements EncryptUtil {    @Autowired    AESUtil aesUtil;    /**     * 加密     *     * @param declaredFields paramsObject所声明的字段     * @param paramsObject   mapper中paramsType的实例     * @return T     * @throws IllegalAccessException 字段不可访问异常     */    @Override    public &lt;T&gt; T encrypt(Field[] declaredFields, T paramsObject) throws IllegalAccessException {        for (Field field : declaredFields) {            //取出所有被EncryptDecryptField注解的字段            SensitiveField sensitiveField = field.getAnnotation(SensitiveField.class);            if (!Objects.isNull(sensitiveField)) {                field.setAccessible(true);                Object object = field.get(paramsObject);                //暂时只实现String类型的加密                if (object instanceof String) {                    String value = (String) object;                    //加密  这里我使用自定义的AES加密工具                    field.set(paramsObject, aesUtil.encrypt(value));                }            }        }        return paramsObject;    }}</code></pre><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="2-4-实现入参加密拦截器"><a href="#2-4-实现入参加密拦截器" class="headerlink" title="2.4 实现入参加密拦截器"></a><strong>2.4 实现入参加密拦截器</strong></h3><p>Myabtis包中的org.apache.ibatis.plugin.Interceptor拦截器接口要求我们实现以下三个方法</p><pre><code>public interface Interceptor {  //核心拦截逻辑  Object intercept(Invocation invocation) throws Throwable;  //拦截器链  default Object plugin(Object target) {return Plugin.wrap(target, this);}  //自定义配置文件操作  default void setProperties(Properties properties) { }}</code></pre><p>因此，参考官方文档的示例，我们自定义一个入参加密拦截器。</p><p>@Intercepts 注解开启拦截器，@Signature 注解定义拦截器的实际类型。</p><p>@Signature中</p><ul><li>type 属性指定当前拦截器使用StatementHandler 、ResultSetHandler、ParameterHandler，Executor的一种</li><li>method 属性指定使用以上四种类型的具体方法（可进入class内部查看其方法）。</li><li>args 属性指定预编译语句</li></ul><p>此处我们使用了 ParameterHandler.setParamters()方法，拦截mapper.xml中paramsType的实例（即在每个含有paramsType属性mapper语句中，都执行该拦截器，对paramsType的实例进行拦截处理）</p><pre><code>/** * 加密拦截器 * 注意@Component注解一定要加上 * * @author : tanzj * @date : 2020/1/19. */@Slf4j@Component@Intercepts({        @Signature(type = ParameterHandler.class, method = "setParameters", args = PreparedStatement.class),})public class EncryptInterceptor implements Interceptor {    private final EncryptDecryptUtil encryptUtil;    @Autowired    public EncryptInterceptor(EncryptDecryptUtil encryptUtil) {        this.encryptUtil = encryptUtil;    }    @Override    @Override    public Object intercept(Invocation invocation) throws Throwable {        //@Signature 指定了 type= parameterHandler 后，这里的 invocation.getTarget() 便是parameterHandler         //若指定ResultSetHandler ，这里则能强转为ResultSetHandler        ParameterHandler parameterHandler = (ParameterHandler) invocation.getTarget();        // 获取参数对像，即 mapper 中 paramsType 的实例        Field parameterField = parameterHandler.getClass().getDeclaredField("parameterObject");        parameterField.setAccessible(true);        //取出实例        Object parameterObject = parameterField.get(parameterHandler);        if (parameterObject != null) {            Class&lt;?&gt; parameterObjectClass = parameterObject.getClass();            //校验该实例的类是否被@SensitiveData所注解            SensitiveData sensitiveData = AnnotationUtils.findAnnotation(parameterObjectClass, SensitiveData.class);            if (Objects.nonNull(sensitiveData)) {                //取出当前当前类所有字段，传入加密方法                Field[] declaredFields = parameterObjectClass.getDeclaredFields();                encryptUtil.encrypt(declaredFields, parameterObject);            }        }        return invocation.proceed();    }    /**     * 切记配置，否则当前拦截器不会加入拦截器链     */    @Override    public Object plugin(Object o) {        return Plugin.wrap(o, this);    }    //自定义配置写入，没有自定义配置的可以直接置空此方法    @Override    public void setProperties(Properties properties) {    }}</code></pre><p>至此完成自定义加密拦截加密。</p><h3 id="2-5-定义解密接口及其实现类"><a href="#2-5-定义解密接口及其实现类" class="headerlink" title="2.5 定义解密接口及其实现类"></a><strong>2.5 定义解密接口及其实现类</strong></h3><p>解密接口，其中result为mapper.xml中resultType的实例。</p><pre><code>public interface DecryptUtil {    /**     * 解密     *     * @param result resultType的实例     * @return T     * @throws IllegalAccessException 字段不可访问异常     */     &lt;T&gt; T decrypt(T result) throws IllegalAccessException;}</code></pre><p>解密接口AES工具解密实现类</p><pre><code>public class AESDecrypt implements DecryptUtil {    @Autowired    AESUtil aesUtil;    /**     * 解密     *     * @param result resultType的实例     * @return T     * @throws IllegalAccessException 字段不可访问异常     */    @Override    public &lt;T&gt; T decrypt(T result) throws IllegalAccessException {        //取出resultType的类        Class&lt;?&gt; resultClass = result.getClass();        Field[] declaredFields = resultClass.getDeclaredFields();        for (Field field : declaredFields) {            //取出所有被EncryptDecryptField注解的字段            SensitiveField sensitiveField = field.getAnnotation(SensitiveField.class);            if (!Objects.isNull(sensitiveField)) {                field.setAccessible(true);                Object object = field.get(result);                //只支持String的解密                if (object instanceof String) {                    String value = (String) object;                    //对注解的字段进行逐一解密                    field.set(result, aesUtil.decrypt(value));                }            }        }        return result;    }}</code></pre><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="2-6-定义出参解密拦截器"><a href="#2-6-定义出参解密拦截器" class="headerlink" title="2.6 定义出参解密拦截器"></a>2.6 定义出参解密拦截器</h3><pre><code>@Slf4j@Component@Intercepts({        @Signature(type = ResultSetHandler.class, method = "handleResultSets", args = {Statement.class})})public class DecryptInterceptor implements Interceptor {    @Autowired    DecryptUtil aesDecrypt;    @Override    public Object intercept(Invocation invocation) throws Throwable {        //取出查询的结果        Object resultObject = invocation.proceed();        if (Objects.isNull(resultObject)) {            return null;        }        //基于selectList        if (resultObject instanceof ArrayList) {            ArrayList resultList = (ArrayList) resultObject;            if (!CollectionUtils.isEmpty(resultList) &amp;&amp; needToDecrypt(resultList.get(0))) {                for (Object result : resultList) {                    //逐一解密                    aesDecrypt.decrypt(result);                }            }        //基于selectOne        } else {            if (needToDecrypt(resultObject)) {                aesDecrypt.decrypt(resultObject);            }        }        return resultObject;    }    private boolean needToDecrypt(Object object) {        Class&lt;?&gt; objectClass = object.getClass();        SensitiveData sensitiveData = AnnotationUtils.findAnnotation(objectClass, SensitiveData.class);        return Objects.nonNull(sensitiveData);    }    @Override    public Object plugin(Object target) {        return Plugin.wrap(target, this);    }    @Override    public void setProperties(Properties properties) {    }}</code></pre><p>至此完成解密拦截器的配置工作。</p><h2 id="3、注解实体类中需要加解密的字段"><a href="#3、注解实体类中需要加解密的字段" class="headerlink" title="3、注解实体类中需要加解密的字段"></a>3、注解实体类中需要加解密的字段</h2><p><img src="/2021/04/25/mybatis-zi-ding-yi-zhu-jie-lan-jie-qi-you-ya-de-shi-xian-min-gan-shu-ju-de-jia-jie-mi/641.jpg" alt="图片"></p><p>此时在mapper中，指定paramType=User resultType=User 便可实现脱离业务层，基于mybatis拦截器的加解密操作。</p>]]></content>
      
      
      <categories>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QPS、TPS、并发用户数、吞吐量的关系</title>
      <link href="2021/04/02/qps-tps-bing-fa-yong-hu-shu-tun-tu-liang-de-guan-xi/"/>
      <url>2021/04/02/qps-tps-bing-fa-yong-hu-shu-tun-tu-liang-de-guan-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h3><p><strong>QPS</strong> <code>Queries Per Second</code> 是每秒查询率 ,是<strong>一台服务器</strong>每秒能够相应的查询次数，是对一个特定的查询服务器<strong>在规定时间内</strong>所处理流量多少的衡量标准, 即每秒的响应请求数，也即是最大吞吐能力。</p><h3 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h3><p><strong>TPS</strong> <code>Transactions Per Second</code> 也就是事务数/秒。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，</p><p><strong>QPS和TPS区别</strong></p><p>个人理解如下：</p><p>1、Tps即每秒处理事务数，包括了</p><p>1）用户请求服务器 2）服务器自己的内部处理 3）服务器返回给用户</p><p>这三个过程，每秒能够完成N个这三个过程，Tps也就是N；</p><p>2、Qps基本类似于Tps，但是不同的是，对于一个页面的一次访问，形成一个Tps；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“Qps”之中。</p><p><strong>例子</strong></p><p>例如：访问一个页面会请求服务器3次，一次放，产生一个“T”，产生3个“Q”</p><p>例如：一个大胃王一秒能吃10个包子，一个女孩子0.1秒能吃1个包子，那么他们是不是一样的呢？答案是否定的，因为这个女孩子不可能在一秒钟吃下10个包子，她可能要吃很久。这个时候这个大胃王就相当于TPS，而这个女孩子则是QPS。虽然很相似，但其实是不同的。</p><h3 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h3><p>并发数（并发度）：指系统同时能处理的请求数量，同样反应了系统的负载能力。这个数值可以分析机器1s内的访问日志数量来得到</p><h3 id="吐吞量"><a href="#吐吞量" class="headerlink" title="吐吞量"></a>吐吞量</h3><p><strong>吐吞量</strong>：吞吐量是指系统在单位时间内处理请求的数量，TPS、QPS都是吞吐量的常用量化指标</p><p><strong>系统吞吐量要素</strong></p><p>一个系统的吞吐量（承压能力）与request（请求）对cpu的消耗，外部接口，IO等等紧密关联。</p><p>单个request 对cpu消耗越高，外部系统接口，IO影响速度越慢，系统吞吐能力越低，反之越高。</p><p><strong>重要参数</strong></p><p>QPS(TPS),并发数，响应时间</p><ol><li>QPS(TPS):每秒钟request/事务 数量</li><li>并发数：系统同时处理的request/事务数</li><li>响应时间：一般取平均响应时间</li></ol><p><strong>关系</strong></p><p>QPS(TPS)=并发数/平均响应时间</p><p>一个系统吞吐量通常有QPS(TPS),并发数两个因素决定，每套系统这个两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换，内存等等其他消耗导致系统性能下降。</p><h3 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h3><p><strong>PV</strong>（Page View）：页面访问量，即页面浏览量或点击量，用户每次刷新即被计算一次。可以统计服务一天的访问日志得到。 </p><h3 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h3><p><strong>UV</strong>（Unique Visitor）：独立访客，统计1天内访问某站点的用户数。可以统计服务一天的访问日志并根据用户的唯一标识去重得到。 响应时间（RT）：响应时间是指系统对请求作出响应的时间，一般取平均响应时间。可以通过Nginx、Apache之类的Web Server得到。 </p><h3 id="DAU"><a href="#DAU" class="headerlink" title="DAU"></a>DAU</h3><p><strong>DAU</strong>(Daily Active User)，日活跃用户数量。常用于反映网站、互联网应用或网络游戏的运营情况。DAU通常统计一日（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户），与UV概念相似 </p><h3 id="MAU"><a href="#MAU" class="headerlink" title="MAU"></a>MAU</h3><p><strong>MAU</strong>(Month Active User)：月活跃用户数量，指网站、app等去重后的月活跃用户数量</p><h2 id="系统吞吐量评估"><a href="#系统吞吐量评估" class="headerlink" title="系统吞吐量评估"></a>系统吞吐量评估</h2><p>我们在做系统设计的时候就需要考虑CPU运算，IO，外部系统响应因素造成的影响以及对系统性能的初步预估。</p><p>而通常情况下，我们面对需求，我们评估出来的出来QPS，并发数之外，还有另外一个维度：日pv。</p><p>通过观察系统的访问日志发现，在用户量很大的情况下，各个时间周期内的同一时间段的访问流量几乎一样。比如工作日的每天早上。只要能拿到日流量图和QPS我们就可以推算日流量。</p><p>通常的技术方法：</p><p>​        \1. 找出系统的最高TPS和日PV，这两个要素有相对比较稳定的关系（除了放假、季节性因素影响之外）</p><p>​        \2. 通过压力测试或者经验预估，得出最高TPS，然后跟进1的关系，计算出系统最高的日吞吐量。B2B中文和淘宝面对的客户群不一样，这两个客户群的网络行为不应用，他们之间的TPS和PV关系比例也不一样。</p><h2 id="软件性能测试的基本概念和计算公式"><a href="#软件性能测试的基本概念和计算公式" class="headerlink" title="软件性能测试的基本概念和计算公式"></a>软件性能测试的基本概念和计算公式</h2><h3 id="软件性能的关注点"><a href="#软件性能的关注点" class="headerlink" title="软件性能的关注点"></a>软件性能的关注点</h3><p>软件做性能测试时需要关注哪些性能呢</p><p>首先，开发软件的目的是为了让用户使用，我们先站在用户的角度分析一下，用户需要关注哪些性能。</p><p>对于用户来说，当点击一个按钮、链接或发出一条指令开始，到系统把结果已用户感知的形式展现出来为止，这个过程所消耗的时间是用户对这个软件性能的直观印 象。也就是我们所说的响应时间，当相应时间较小时，用户体验是很好的，当然用户体验的响应时间包括个人主观因素和客观响应时间，在设计软件时，我们就需要 考虑到如何更好地结合这两部分达到用户最佳的体验。如：用户在大数据量查询时，我们可以将先提取出来的数据展示给用户，在用户看的过程中继续进行数据检 索，这时用户并不知道我们后台在做什么。</p><p>用户关注的是用户操作的相应时间。</p><p><strong>其次，我们站在管理员的角度考虑需要关注的性能点。</strong></p><p>1、 响应时间<br>2、 服务器资源使用情况是否合理<br>3、 应用服务器和数据库资源使用是否合理<br>4、 系统能否实现扩展<br>5、 系统最多支持多少用户访问、系统最大业务处理量是多少<br>6、 系统性能可能存在的瓶颈在哪里<br>7、 更换那些设备可以提高性能<br>8、 系统能否支持7×24小时的业务访问</p><p><strong>再次，站在开发（设计）人员角度去考虑。</strong></p><p>1、 架构设计是否合理<br>2、 数据库设计是否合理<br>3、 代码是否存在性能方面的问题<br>4、 系统中是否有不合理的内存使用方式<br>5、 系统中是否存在不合理的线程同步方式<br>6、 系统中是否存在不合理的资源竞争</p><p>作者：Fysddsw_lc<br>链接：<a href="https://juejin.cn/post/6844904084504313863">https://juejin.cn/post/6844904084504313863</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot缓存应用实践</title>
      <link href="2021/04/02/springboot-huan-cun-ying-yong-shi-jian/"/>
      <url>2021/04/02/springboot-huan-cun-ying-yong-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>缓存是最直接有效提升系统性能的手段之一。个人认为用好用对缓存是优秀程序员的必备基本素质。本文结合实际开发经验，从简单概念原理和代码入手，一步一步搭建一个简单的二级缓存系统。</p><h2 id="一、通用缓存接口"><a href="#一、通用缓存接口" class="headerlink" title="一、通用缓存接口"></a><strong>一、通用缓存接口</strong></h2><h3 id="1、缓存基础算法"><a href="#1、缓存基础算法" class="headerlink" title="1、缓存基础算法"></a>1、缓存基础算法</h3><ul><li><strong>FIFO（First In First Out）</strong>，先进先出，和OS里的FIFO思路相同，如果一个数据最先进入缓存中，当缓存满的时候，应当把最先进入缓存的数据给移除掉。</li><li><strong>LFU（Least Frequently Used）</strong>，最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。</li><li><strong>LRU（Least Recently Used）</strong>，最近最少使用，如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据移除。</li></ul><h3 id="2、接口定义"><a href="#2、接口定义" class="headerlink" title="2、接口定义"></a>2、接口定义</h3><p>简单定义缓存接口，大致可以抽象如下：</p><pre><code>package com.power.demo.cache.contract;import java.util.function.Function;/** * 缓存提供者接口 **/public interface CacheProviderService {    /**     * 查询缓存     *     * @param key 缓存键 不可为空     **/    &lt;T extends Object&gt; T get(String key);    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     **/    &lt;T extends Object&gt; T get(String key, Function&lt;String, T&gt; function);    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     * @param funcParm function函数的调用参数     **/    &lt;T extends Object, M extends Object&gt; T get(String key, Function&lt;M, T&gt; function, M funcParm);    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     * @param expireTime 过期时间（单位：毫秒） 可为空     **/    &lt;T extends Object&gt; T get(String key, Function&lt;String, T&gt; function, Long expireTime);    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     * @param funcParm function函数的调用参数     * @param expireTime 过期时间（单位：毫秒） 可为空     **/    &lt;T extends Object, M extends Object&gt; T get(String key, Function&lt;M, T&gt; function, M funcParm, Long expireTime);    /**     * 设置缓存键值     *     * @param key 缓存键 不可为空     * @param obj 缓存值 不可为空     **/    &lt;T extends Object&gt; void set(String key, T obj);    /**     * 设置缓存键值     *     * @param key 缓存键 不可为空     * @param obj 缓存值 不可为空     * @param expireTime 过期时间（单位：毫秒） 可为空     **/    &lt;T extends Object&gt; void set(String key, T obj, Long expireTime);    /**     * 移除缓存     *     * @param key 缓存键 不可为空     **/    void remove(String key);    /**     * 是否存在缓存     *     * @param key 缓存键 不可为空     **/    boolean contains(String key);}</code></pre><p><em>注意，这里列出的只是常见缓存功能接口，一些在特殊场景下用到的统计类的接口、分布式锁、自增（减）等功能不在讨论范围之内。</em></p><p>Get相关方法，注意多个参数的情况，缓存接口里面传人的Function，这是Java8提供的函数式接口，虽然支持的入参个数有限（这里你会非常怀念.NET下的Func委托），但是仅对Java这个语言来说，这真是一个重大的进步^_^。</p><p>接口定义好了，下面就要实现缓存提供者程序了。按照存储类型的不同，本文简单实现最常用的两种缓存提供者：<strong>本地缓存和分布式缓存</strong>。</p><h2 id="二、本地缓存"><a href="#二、本地缓存" class="headerlink" title="二、本地缓存"></a><strong>二、本地缓存</strong></h2><p>本地缓存，也就是JVM级别的缓存(本地缓存可以认为是直接在进程内通信调用，而分布式缓存则需要通过网络进行跨进程通信调用)，一般有很多种实现方式，比如直接使用Hashtable、ConcurrentHashMap等天生线程安全的集合作为缓存容器，或者使用一些成熟的开源组件，如EhCache、Guava Cache等。本文选择上手简单的Guava缓存。</p><h3 id="1、什么是Guava"><a href="#1、什么是Guava" class="headerlink" title="1、什么是Guava"></a>1、什么是Guava</h3><p>Guava，简单来说就是一个开发类库，且是一个非常丰富强大的开发工具包，号称可以让使用Java语言更令人愉悦，主要包括基本工具类库和接口、缓存、发布订阅风格的事件总线等。在实际开发中，我用的最多的是集合、缓存和常用类型帮助类，很多人都对这个类库称赞有加。</p><h3 id="2、添加依赖"><a href="#2、添加依赖" class="headerlink" title="2、添加依赖"></a>2、添加依赖</h3><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="3、实现接口"><a href="#3、实现接口" class="headerlink" title="3、实现接口"></a>3、实现接口</h3><pre><code>/* * 本地缓存提供者服务 (Guava Cache) * */@Configuration@ComponentScan(basePackages = AppConst.BASE_PACKAGE_NAME)@Qualifier("localCacheService")public class LocalCacheProviderImpl implements CacheProviderService {    private static Map&lt;String, Cache&lt;String, Object&gt;&gt; _cacheMap = Maps.newConcurrentMap();    static {        Cache&lt;String, Object&gt; cacheContainer = CacheBuilder.newBuilder()                .maximumSize(AppConst.CACHE_MAXIMUM_SIZE)                .expireAfterWrite(AppConst.CACHE_MINUTE, TimeUnit.MILLISECONDS)//最后一次写入后的一段时间移出                //.expireAfterAccess(AppConst.CACHE_MINUTE, TimeUnit.MILLISECONDS) //最后一次访问后的一段时间移出                .recordStats()//开启统计功能                .build();        _cacheMap.put(String.valueOf(AppConst.CACHE_MINUTE), cacheContainer);    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     **/    public &lt;T extends Object&gt; T get(String key) {        T obj = get(key, null, null, AppConst.CACHE_MINUTE);        return obj;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     **/    public &lt;T extends Object&gt; T get(String key, Function&lt;String, T&gt; function) {        T obj = get(key, function, key, AppConst.CACHE_MINUTE);        return obj;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     * @param funcParm function函数的调用参数     **/    public &lt;T extends Object, M extends Object&gt; T get(String key, Function&lt;M, T&gt; function, M funcParm) {        T obj = get(key, function, funcParm, AppConst.CACHE_MINUTE);        return obj;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     * @param expireTime 过期时间（单位：毫秒） 可为空     **/    public &lt;T extends Object&gt; T get(String key, Function&lt;String, T&gt; function, Long expireTime) {        T obj = get(key, function, key, expireTime);        return obj;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     * @param funcParm function函数的调用参数     * @param expireTime 过期时间（单位：毫秒） 可为空     **/    public &lt;T extends Object, M extends Object&gt; T get(String key, Function&lt;M, T&gt; function, M funcParm, Long expireTime) {        T obj = null;        if (StringUtils.isEmpty(key) == true) {            return obj;        }        expireTime = getExpireTime(expireTime);        Cache&lt;String, Object&gt; cacheContainer = getCacheContainer(expireTime);        try {            if (function == null) {                obj = (T) cacheContainer.getIfPresent(key);            } else {                final Long cachedTime = expireTime;                obj = (T) cacheContainer.get(key, () -&gt; {                    T retObj = function.apply(funcParm);                    return retObj;                });            }        } catch (Exception e) {            e.printStackTrace();        }        return obj;    }    /**     * 设置缓存键值 直接向缓存中插入值，这会直接覆盖掉给定键之前映射的值     *     * @param key 缓存键 不可为空     * @param obj 缓存值 不可为空     **/    public &lt;T extends Object&gt; void set(String key, T obj) {        set(key, obj, AppConst.CACHE_MINUTE);    }    /**     * 设置缓存键值 直接向缓存中插入值，这会直接覆盖掉给定键之前映射的值     *     * @param key 缓存键 不可为空     * @param obj 缓存值 不可为空     * @param expireTime 过期时间（单位：毫秒） 可为空     **/    public &lt;T extends Object&gt; void set(String key, T obj, Long expireTime) {        if (StringUtils.isEmpty(key) == true) {            return;        }        if (obj == null) {            return;        }        expireTime = getExpireTime(expireTime);        Cache&lt;String, Object&gt; cacheContainer = getCacheContainer(expireTime);        cacheContainer.put(key, obj);    }    /**     * 移除缓存     *     * @param key 缓存键 不可为空     **/    public void remove(String key) {        if (StringUtils.isEmpty(key) == true) {            return;        }        long expireTime = getExpireTime(AppConst.CACHE_MINUTE);        Cache&lt;String, Object&gt; cacheContainer = getCacheContainer(expireTime);        cacheContainer.invalidate(key);    }    /**     * 是否存在缓存     *     * @param key 缓存键 不可为空     **/    public boolean contains(String key) {        boolean exists = false;        if (StringUtils.isEmpty(key) == true) {            return exists;        }        Object obj = get(key);        if (obj != null) {            exists = true;        }        return exists;    }    private static Lock lock = new ReentrantLock();    private Cache&lt;String, Object&gt; getCacheContainer(Long expireTime) {        Cache&lt;String, Object&gt; cacheContainer = null;        if (expireTime == null) {            return cacheContainer;        }        String mapKey = String.valueOf(expireTime);        if (_cacheMap.containsKey(mapKey) == true) {            cacheContainer = _cacheMap.get(mapKey);            return cacheContainer;        }        try {            lock.lock();            cacheContainer = CacheBuilder.newBuilder()                    .maximumSize(AppConst.CACHE_MAXIMUM_SIZE)                    .expireAfterWrite(expireTime, TimeUnit.MILLISECONDS)//最后一次写入后的一段时间移出                    //.expireAfterAccess(AppConst.CACHE_MINUTE, TimeUnit.MILLISECONDS) //最后一次访问后的一段时间移出                    .recordStats()//开启统计功能                    .build();            _cacheMap.put(mapKey, cacheContainer);        } finally {            lock.unlock();        }        return cacheContainer;    }    /**     * 获取过期时间 单位：毫秒     *     * @param expireTime 传人的过期时间 单位毫秒 如小于1分钟，默认为10分钟     **/    private Long getExpireTime(Long expireTime) {        Long result = expireTime;        if (expireTime == null || expireTime &lt; AppConst.CACHE_MINUTE / 10) {            result = AppConst.CACHE_MINUTE;        }        return result;    }}</code></pre><h3 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h3><p>Guava Cache初始化容器时，支持缓存过期策略，类似FIFO、LRU和LFU等算法。</p><ul><li>expireAfterWrite：最后一次写入后的一段时间移出。</li><li>expireAfterAccess：最后一次访问后的一段时间移出。</li></ul><p>Guava Cache对缓存过期时间的设置实在不够友好。常见的应用场景，比如，有些几乎不变的基础数据缓存1天，有些热点数据缓存2小时，有些会话数据缓存5分钟等等。</p><p>通常我们认为设置缓存的时候带上缓存的过期时间是非常容易的，而且只要一个缓存容器实例即可，比如.NET下的ObjectCache、System.Runtime.Cache等等。</p><p>但是Guava Cache不是这个实现思路，如果缓存的过期时间不同，Guava的CacheBuilder要初始化多份Cache实例。</p><p>好在我在实现的时候注意到了这个问题，并且提供了解决方案，可以看到getCacheContainer这个函数，根据过期时长做缓存实例判断，就算不同过期时间的多实例缓存也是完全没有问题的。</p><h2 id="三、分布式缓存"><a href="#三、分布式缓存" class="headerlink" title="三、分布式缓存"></a><strong>三、分布式缓存</strong></h2><p>分布式缓存产品非常多，本文使用应用普遍的Redis，在Spring Boot应用中使用Redis非常简单。</p><h3 id="1、什么是Redis"><a href="#1、什么是Redis" class="headerlink" title="1、什么是Redis"></a>1、什么是Redis</h3><p>Redis是一款开源（BSD许可）的、用C语言写成的高性能的键-值存储（key-value store）。它常被称作是一款数据结构服务器（data structure server）。它可以被用作缓存、消息中间件和数据库，在很多应用中，经常看到有人选择使用Redis做缓存，实现分布式锁和分布式Session等。作为缓存系统时，和经典的KV结构的Memcached非常相似，但又有很多不同。</p><p>Redis支持丰富的数据类型。Redis的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和有序集合（sorted sets）等数据类型。对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（append）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。</p><p><strong>Redis的数据类型：</strong></p><p>Keys：非二进制安全的字符类型（ not binary-safe strings ），由于key不是binary safe的字符串，所以像“my key”和“mykey\n”这样包含空格和换行的key是不允许的。</p><p>Values：Strings、Hash、Lists、 Sets、 Sorted sets。考虑到Redis单线程操作模式，Value的粒度不应该过大，缓存的值越大，越容易造成阻塞和排队。</p><p>为了获得优异的性能，Redis采用了内存中（in-memory）数据集（dataset）的方式。同时，Redis支持数据的持久化，你可以每隔一段时间将数据集转存到磁盘上（snapshot），或者在日志尾部追加每一条操作命令（append only file,aof）。</p><p>Redis同样支持主从复制（master-slave replication），并且具有非常快速的非阻塞首次同步（ non-blocking first synchronization）、网络断开自动重连等功能。</p><p>同时Redis还具有其它一些特性，其中包括简单的事物支持、发布订阅 （ pub/sub）、管道（pipeline）和虚拟内存（vm）等 。</p><h3 id="2、添加依赖-1"><a href="#2、添加依赖-1" class="headerlink" title="2、添加依赖"></a>2、添加依赖</h3><pre><code>&lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="3、配置Redis"><a href="#3、配置Redis" class="headerlink" title="3、配置Redis"></a>3、配置Redis</h3><p>在application.properties配置文件中，配置Redis常用参数：</p><pre><code>## Redis缓存相关配置#Redis数据库索引（默认为0）spring.redis.database=0#Redis服务器地址spring.redis.host=127.0.0.1#Redis服务器端口spring.redis.port=6379#Redis服务器密码（默认为空）spring.redis.password=123321#Redis连接超时时间 默认：5分钟（单位：毫秒）spring.redis.timeout=300000ms#Redis连接池最大连接数（使用负值表示没有限制）spring.redis.jedis.pool.max-active=512#Redis连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=0#Redis连接池中的最大空闲连接spring.redis.jedis.pool.max-idle=8#Redis连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.jedis.pool.max-wait=-1msredisproperties</code></pre><p>常见的需要注意的是最大连接数（spring.redis.jedis.pool.max-active ）和超时时间（spring.redis.jedis.pool.max-wait）。Redis在生产环境中出现故障的频率经常和这两个参数息息相关。</p><p>接着定义一个继承自CachingConfigurerSupport（请注意cacheManager和keyGenerator这两个方法在子类的实现）的RedisConfig类：</p><pre><code>/** * Redis缓存配置类 */@Configuration@EnableCachingpublic class RedisConfig extends CachingConfigurerSupport {    @Bean    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {        return RedisCacheManager.create(connectionFactory);    }    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        //Jedis的Key和Value的序列化器默认值是JdkSerializationRedisSerializer        //经实验，JdkSerializationRedisSerializer通过RedisDesktopManager看到的键值对不能正常解析        //设置key的序列化器        template.setKeySerializer(new StringRedisSerializer());        ////设置value的序列化器 默认值是JdkSerializationRedisSerializer        //使用Jackson序列化器的问题是，复杂对象可能序列化失败，比如JodaTime的DateTime类型        // //使用Jackson2，将对象序列化为JSON        // Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);        // //json转对象类，不设置默认的会将json转成hashmap        // ObjectMapper om = new ObjectMapper();        // om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        // om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        // jackson2JsonRedisSerializer.setObjectMapper(om);        // template.setValueSerializer(jackson2JsonRedisSerializer);        //将redis连接工厂设置到模板类中        template.setConnectionFactory(factory);        return template;    }// //自定义缓存key生成策略// @Bean// public KeyGenerator keyGenerator() {// return new KeyGenerator() {// @Override// public Object generate(Object target, java.lang.reflect.Method method, Object... params) {// StringBuffer sb = new StringBuffer();// sb.append(target.getClass().getName());// sb.append(method.getName());// for (Object obj : params) {// if (obj == null) {// continue;// }// sb.append(obj.toString());// }// return sb.toString();// }// };// }}</code></pre><p>在RedisConfig这个类上加上@EnableCaching这个注解，这个注解会被Spring发现，并且会创建一个切面（aspect） 并触发Spring缓存注解的切点（pointcut）。据所使用的注解以及缓存的状态，这个切面会从缓存中获取数据，将数据添加到缓存之中或者从缓存中移除某个值。</p><p>cacheManager方法，申明一个缓存管理器（CacheManager）的bean，作用就是@EnableCaching这个切面在新增缓存或者删除缓存的时候会调用这个缓存管理器的方法。keyGenerator方法，可以根据需求自定义缓存key生成策略。</p><p>而redisTemplate方法，则主要是设置Redis模板类，比如键和值的序列化器（从这里可以看出，Redis的键值对必须可序列化）、redis连接工厂等。</p><p>RedisTemplate支持的序列化器主要有如下几种：</p><ul><li>JdkSerializationRedisSerializer：使用Java序列化；</li><li>StringRedisSerializer：序列化String类型的key和value；</li><li>GenericToStringSerializer：使用Spring转换服务进行序列化；</li><li>JacksonJsonRedisSerializer：使用Jackson 1，将对象序列化为JSON；</li><li>Jackson2JsonRedisSerializer：使用Jackson 2，将对象序列化为JSON；</li><li>OxmSerializer：使用Spring O/X映射的编排器和解排器（marshaler和unmarshaler）实现序列化，用于XML序列化；</li></ul><p>注意：<em>RedisTemplate的键和值序列化器，默认情况下都是JdkSerializationRedisSerializer，它们都可以自定义设置序列化器。</em></p><p>推荐将字符串键使用StringRedisSerializer序列化器，因为运维的时候好排查问题，JDK序列化器的也能识别，但是可读性稍差(是因为缓存服务器没有JRE吗？)，见如下效果：</p><p><img src="/2021/04/02/springboot-huan-cun-ying-yong-shi-jian/640" alt="图片"></p><p>而值序列化器则要复杂的多，很多人推荐使用Jackson2JsonRedisSerializer序列化器，但是实际开发过程中，经常有人碰到反序列化错误，经过排查多数都和Jackson2JsonRedisSerializer这个序列化器有关。</p><h3 id="4、实现接口"><a href="#4、实现接口" class="headerlink" title="4、实现接口"></a>4、实现接口</h3><p>使用RedisTemplate，在Spring Boot中调用Redis接口比直接调用Jedis简单多了。</p><pre><code>@Configuration@ComponentScan(basePackages = AppConst.BASE_PACKAGE_NAME)@Qualifier("redisCacheService")public class RedisCacheProviderImpl implements CacheProviderService {    @Resource    private RedisTemplate&lt;Serializable, Object&gt; redisTemplate;    /**     * 查询缓存     *     * @param key 缓存键 不可为空     **/    public &lt;T extends Object&gt; T get(String key) {        T obj = get(key, null, null, AppConst.CACHE_MINUTE);        return obj;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     **/    public &lt;T extends Object&gt; T get(String key, Function&lt;String, T&gt; function) {        T obj = get(key, function, key, AppConst.CACHE_MINUTE);        return obj;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     * @param funcParm function函数的调用参数     **/    public &lt;T extends Object, M extends Object&gt; T get(String key, Function&lt;M, T&gt; function, M funcParm) {        T obj = get(key, function, funcParm, AppConst.CACHE_MINUTE);        return obj;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     * @param expireTime 过期时间（单位：毫秒） 可为空     **/    public &lt;T extends Object&gt; T get(String key, Function&lt;String, T&gt; function, Long expireTime) {        T obj = get(key, function, key, expireTime);        return obj;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     * @param funcParm function函数的调用参数     * @param expireTime 过期时间（单位：毫秒） 可为空     **/    public &lt;T extends Object, M extends Object&gt; T get(String key, Function&lt;M, T&gt; function, M funcParm, Long expireTime) {        T obj = null;        if (StringUtils.isEmpty(key) == true) {            return obj;        }        expireTime = getExpireTime(expireTime);        try {            ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();            obj = (T) operations.get(key);            if (function != null &amp;&amp; obj == null) {                obj = function.apply(funcParm);                if (obj != null) {                    set(key, obj, expireTime);//设置缓存信息                }            }        } catch (Exception e) {            e.printStackTrace();        }        return obj;    }    /**     * 设置缓存键值 直接向缓存中插入值，这会直接覆盖掉给定键之前映射的值     *     * @param key 缓存键 不可为空     * @param obj 缓存值 不可为空     **/    public &lt;T extends Object&gt; void set(String key, T obj) {        set(key, obj, AppConst.CACHE_MINUTE);    }    /**     * 设置缓存键值 直接向缓存中插入值，这会直接覆盖掉给定键之前映射的值     *     * @param key 缓存键 不可为空     * @param obj 缓存值 不可为空     * @param expireTime 过期时间（单位：毫秒） 可为空     **/    public &lt;T extends Object&gt; void set(String key, T obj, Long expireTime) {        if (StringUtils.isEmpty(key) == true) {            return;        }        if (obj == null) {            return;        }        expireTime = getExpireTime(expireTime);        ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();        operations.set(key, obj);        redisTemplate.expire(key, expireTime, TimeUnit.MILLISECONDS);    }    /**     * 移除缓存     *     * @param key 缓存键 不可为空     **/    public void remove(String key) {        if (StringUtils.isEmpty(key) == true) {            return;        }        redisTemplate.delete(key);    }    /**     * 是否存在缓存     *     * @param key 缓存键 不可为空     **/    public boolean contains(String key) {        boolean exists = false;        if (StringUtils.isEmpty(key) == true) {            return exists;        }        Object obj = get(key);        if (obj != null) {            exists = true;        }        return exists;    }    /**     * 获取过期时间 单位：毫秒     *     * @param expireTime 传人的过期时间 单位毫秒 如小于1分钟，默认为10分钟     **/    private Long getExpireTime(Long expireTime) {        Long result = expireTime;        if (expireTime == null || expireTime &lt; AppConst.CACHE_MINUTE / 10) {            result = AppConst.CACHE_MINUTE;        }        return result;    }}</code></pre><p>注意：很多教程里都讲到通过注解的方式（@Cacheable，@CachePut、@CacheEvict和@Caching）实现数据缓存，根据实践，我个人是不推崇这种使用方式的。</p><h2 id="四、缓存“及时”过期问题"><a href="#四、缓存“及时”过期问题" class="headerlink" title="四、缓存“及时”过期问题"></a><strong>四、缓存“及时”过期问题</strong></h2><p>这个也是开发和运维过程中非常经典的问题。</p><p>有些公司写缓存客户端的时候，会给每个团队分别定义一个Area，但是这个只能做到缓存键的分布区分，不能保证缓存“实时”有效的过期。</p><p>多年以前我写过一篇结合实际情况的文章，也就是加上缓存版本，请猛击这里 ，算是提供了一种相对有效的方案，不过高并发站点要慎重，防止发生雪崩效应。</p><p>Redis还有一些其他常见问题，比如：Redis的字符串类型Key和Value都有限制，且都是不能超过512M。还有最大连接数和超时时间设置等问题，本文就不再一一列举了。</p><h2 id="五、二级缓存"><a href="#五、二级缓存" class="headerlink" title="五、二级缓存"></a><strong>五、二级缓存</strong></h2><p>在配置文件中，加上缓存提供者开关：</p><pre><code>##是否启用本地缓存spring.power.isuselocalcache=1##是否启用Redis缓存spring.power.isuserediscache=1</code></pre><p>缓存提供者程序都实现好了，我们会再包装一个调用外观类PowerCacheBuilder，加上缓存版本控制，可以轻松自如地控制和切换缓存，code talks:</p><pre><code>/* * 支持多缓存提供程序多级缓存的缓存帮助类 * */@Configuration@ComponentScan(basePackages = AppConst.BASE_PACKAGE_NAME)public class PowerCacheBuilder {    @Autowired    @Qualifier("localCacheService")    private CacheProviderService localCacheService;    @Autowired    @Qualifier("redisCacheService")    private CacheProviderService redisCacheService;    private static List&lt;CacheProviderService&gt; _listCacheProvider = Lists.newArrayList();    private static final Lock providerLock = new ReentrantLock();    /**     * 初始化缓存提供者 默认优先级：先本地缓存，后分布式缓存     **/    private List&lt;CacheProviderService&gt; getCacheProviders() {        if (_listCacheProvider.size() &gt; 0) {            return _listCacheProvider;        }        //线程安全        try {            providerLock.tryLock(1000, TimeUnit.MILLISECONDS);            if (_listCacheProvider.size() &gt; 0) {                return _listCacheProvider;            }            String isUseCache = ConfigUtil.getConfigVal(AppField.IS_USE_LOCAL_CACHE);            CacheProviderService cacheProviderService = null;            //启用本地缓存            if ("1".equalsIgnoreCase(isUseCache)) {                _listCacheProvider.add(localCacheService);            }            isUseCache = ConfigUtil.getConfigVal(AppField.IS_USE_REDIS_CACHE);            //启用Redis缓存            if ("1".equalsIgnoreCase(isUseCache)) {                _listCacheProvider.add(redisCacheService);                resetCacheVersion();//设置分布式缓存版本号            }            PowerLogger.info("初始化缓存提供者成功，共有" + _listCacheProvider.size() + "个");        } catch (Exception e) {            e.printStackTrace();            _listCacheProvider = Lists.newArrayList();            PowerLogger.error("初始化缓存提供者发生异常：{}", e);        } finally {            providerLock.unlock();        }        return _listCacheProvider;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     **/    public &lt;T extends Object&gt; T get(String key) {        T obj = null;        //key = generateVerKey(key);//构造带版本的缓存键        for (CacheProviderService provider : getCacheProviders()) {            obj = provider.get(key);            if (obj != null) {                return obj;            }        }        return obj;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     **/    public &lt;T extends Object&gt; T get(String key, Function&lt;String, T&gt; function) {        T obj = null;        for (CacheProviderService provider : getCacheProviders()) {            if (obj == null) {                obj = provider.get(key, function);            } else if (function != null &amp;&amp; obj != null) {//查询并设置其他缓存提供者程序缓存                provider.get(key, function);            }            //如果callable函数为空 而缓存对象不为空 及时跳出循环并返回            if (function == null &amp;&amp; obj != null) {                return obj;            }        }        return obj;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     * @param funcParm function函数的调用参数     **/    public &lt;T extends Object, M extends Object&gt; T get(String key, Function&lt;M, T&gt; function, M funcParm) {        T obj = null;        for (CacheProviderService provider : getCacheProviders()) {            if (obj == null) {                obj = provider.get(key, function, funcParm);            } else if (function != null &amp;&amp; obj != null) {//查询并设置其他缓存提供者程序缓存                provider.get(key, function, funcParm);            }            //如果callable函数为空 而缓存对象不为空 及时跳出循环并返回            if (function == null &amp;&amp; obj != null) {                return obj;            }        }        return obj;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     * @param expireTime 过期时间（单位：毫秒） 可为空     **/    public &lt;T extends Object&gt; T get(String key, Function&lt;String, T&gt; function, long expireTime) {        T obj = null;        for (CacheProviderService provider : getCacheProviders()) {            if (obj == null) {                obj = provider.get(key, function, expireTime);            } else if (function != null &amp;&amp; obj != null) {//查询并设置其他缓存提供者程序缓存                provider.get(key, function, expireTime);            }            //如果callable函数为空 而缓存对象不为空 及时跳出循环并返回            if (function == null &amp;&amp; obj != null) {                return obj;            }        }        return obj;    }    /**     * 查询缓存     *     * @param key 缓存键 不可为空     * @param function 如没有缓存，调用该callable函数返回对象 可为空     * @param funcParm function函数的调用参数     * @param expireTime 过期时间（单位：毫秒） 可为空     **/    public &lt;T extends Object, M extends Object&gt; T get(String key, Function&lt;M, T&gt; function, M funcParm, long expireTime) {        T obj = null;        for (CacheProviderService provider : getCacheProviders()) {            if (obj == null) {                obj = provider.get(key, function, funcParm, expireTime);            } else if (function != null &amp;&amp; obj != null) {//查询并设置其他缓存提供者程序缓存                provider.get(key, function, funcParm, expireTime);            }            //如果callable函数为空 而缓存对象不为空 及时跳出循环并返回            if (function == null &amp;&amp; obj != null) {                return obj;            }        }        return obj;    }    /**     * 设置缓存键值 直接向缓存中插入或覆盖值     *     * @param key 缓存键 不可为空     * @param obj 缓存值 不可为空     **/    public &lt;T extends Object&gt; void set(String key, T obj) {        //key = generateVerKey(key);//构造带版本的缓存键        for (CacheProviderService provider : getCacheProviders()) {            provider.set(key, obj);        }    }    /**     * 设置缓存键值 直接向缓存中插入或覆盖值     *     * @param key 缓存键 不可为空     * @param obj 缓存值 不可为空     * @param expireTime 过期时间（单位：毫秒） 可为空     **/    public &lt;T extends Object&gt; void set(String key, T obj, Long expireTime) {        //key = generateVerKey(key);//构造带版本的缓存键        for (CacheProviderService provider : getCacheProviders()) {            provider.set(key, obj, expireTime);        }    }    /**     * 移除缓存     *     * @param key 缓存键 不可为空     **/    public void remove(String key) {        //key = generateVerKey(key);//构造带版本的缓存键        if (StringUtils.isEmpty(key) == true) {            return;        }        for (CacheProviderService provider : getCacheProviders()) {            provider.remove(key);        }    }    /**     * 是否存在缓存     *     * @param key 缓存键 不可为空     **/    public boolean contains(String key) {        boolean exists = false;        //key = generateVerKey(key);//构造带版本的缓存键        if (StringUtils.isEmpty(key) == true) {            return exists;        }        Object obj = get(key);        if (obj != null) {            exists = true;        }        return exists;    }    /**     * 获取分布式缓存版本号     **/    public String getCacheVersion() {        String version = "";        boolean isUseCache = checkUseRedisCache();        //未启用Redis缓存        if (isUseCache == false) {            return version;        }        version = redisCacheService.get(AppConst.CACHE_VERSION_KEY);        return version;    }    /**     * 重置分布式缓存版本 如果启用分布式缓存，设置缓存版本     **/    public String resetCacheVersion() {        String version = "";        boolean isUseCache = checkUseRedisCache();        //未启用Redis缓存        if (isUseCache == false) {            return version;        }        //设置缓存版本        version = String.valueOf(Math.abs(UUID.randomUUID().hashCode()));        redisCacheService.set(AppConst.CACHE_VERSION_KEY, version);        return version;    }    /**     * 如果启用分布式缓存，获取缓存版本，重置查询的缓存key，可以实现相对实时的缓存过期控制     * &lt;p&gt;     * 如没有启用分布式缓存，缓存key不做修改，直接返回     **/    public String generateVerKey(String key) {        String result = key;        if (StringUtils.isEmpty(key) == true) {            return result;        }        boolean isUseCache = checkUseRedisCache();        //没有启用分布式缓存，缓存key不做修改，直接返回        if (isUseCache == false) {            return result;        }        String version = redisCacheService.get(AppConst.CACHE_VERSION_KEY);        if (StringUtils.isEmpty(version) == true) {            return result;        }        result = String.format("%s_%s", result, version);        return result;    }    /**     * 验证是否启用分布式缓存     **/    private boolean checkUseRedisCache() {        boolean isUseCache = false;        String strIsUseCache = ConfigUtil.getConfigVal(AppField.IS_USE_REDIS_CACHE);        isUseCache = "1".equalsIgnoreCase(strIsUseCache);        return isUseCache;    }}</code></pre><p>单元测试如下：</p><pre><code>@Testpublic void testCacheVerson() throws Exception {        String version = cacheBuilder.getCacheVersion();        System.out.println(String.format("当前缓存版本：%s", version));        String cacheKey = cacheBuilder.generateVerKey("goods778899");        GoodsVO goodsVO = new GoodsVO();        goodsVO.setGoodsId(UUID.randomUUID().toString());        goodsVO.setCreateTime(new Date());        goodsVO.setCreateDate(new DateTime(new Date()));        goodsVO.setGoodsType(1024);        goodsVO.setGoodsCode("123456789");        goodsVO.setGoodsName("我的测试商品");        cacheBuilder.set(cacheKey, goodsVO);        GoodsVO goodsVO1 = cacheBuilder.get(cacheKey);        Assert.assertNotNull(goodsVO1);        version = cacheBuilder.resetCacheVersion();        System.out.println(String.format("重置后的缓存版本：%s", version));        cacheKey = cacheBuilder.generateVerKey("goods112233");        cacheBuilder.set(cacheKey, goodsVO);        GoodsVO goodsVO2 = cacheBuilder.get(cacheKey);        Assert.assertNotNull(goodsVO2);        Assert.assertTrue("两个缓存对象的主键相同", goodsVO1.getGoodsId().equals(goodsVO2.getGoodsId()));    }</code></pre><p>一个满足基本功能的多级缓存系统就好了。</p><p>在Spring Boot应用中使用缓存则非常简洁，选择调用上面包装好的缓存接口即可。</p><pre><code>String cacheKey = _cacheBuilder.generateVerKey("com.power.demo.apiservice.impl.getgoodsbyid." + request.getGoodsId());GoodsVO goodsVO = _cacheBuilder.get(cacheKey, _goodsService::getGoodsByGoodsId, request.getGoodsId());</code></pre><p>到这里Spring Boot业务系统开发中最常用到的ORM，缓存和队列三板斧就介绍完了。</p><p>在开发的过程中你会发现，Java真的是非常非常中规中矩的语言，你需要不断折腾并熟悉常见的开源中间件和工具，开源的轮子实在是太丰富，多尝试几个，实践出真知。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><blockquote><p><a href="http://ifeve.com/google-guava/">http://ifeve.com/google-guava/</a> <a href="http://www.cnblogs.com/luochengqiuse/p/4640932.html">http://www.cnblogs.com/luochengqiuse/p/4640932.html</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一文读懂 Java 动态代理，那些面试中你容易忽略的细节</title>
      <link href="2021/04/02/yi-wen-du-dong-dong-tai-dai-li/"/>
      <url>2021/04/02/yi-wen-du-dong-dong-tai-dai-li/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本来是打算把java代理模式给写一下的，但是整理思路的时候发现这是一个庞大的工程，我需要讲清楚什么是代理模式；它的应用场景有哪些；代理又分为静态代理和动态代理，它们分别是如何实现的，区别又是什么，我还要举例，分析源码，emm。显然，我现在的时间安排是无法完成这个庞大的工程的，所以我就讲一下目前解决问题中遇到的动态代理吧（默认你大致了解代理模式）</p><h3 id="为什么要写这篇文章"><a href="#为什么要写这篇文章" class="headerlink" title="为什么要写这篇文章"></a>为什么要写这篇文章</h3><p>我最近在学习Retrofit2源码，而这个框架比较核心的一点就是动态代理，所以在这里把我学习过程中的一些我认为比较关键的地方整理出来，分享给有需要的童鞋。</p><p>Retrofit2的动态代理到底体现在哪里？请看下面代码</p><pre><code>//retrofit的API接口对象ApiService apiService;//创建代理对象 apiService = retrofit.create(ApiService.class);//调用代理类中的方法apiService.xxx();</code></pre><p>这是<code>retrofit.create</code>方法的源码，很明显的动态代理</p><p><img src="/2021/04/02/yi-wen-du-dong-dong-tai-dai-li/640" alt="图片"></p><h3 id="动态代理的本质是什么？"><a href="#动态代理的本质是什么？" class="headerlink" title="动态代理的本质是什么？"></a>动态代理的本质是什么？</h3><p>我的理解：</p><ul><li>提供一个代理来控制对象的访问；</li><li>程序运行时动态生成代理类，这个代理类继承于Proxy，并且实现自定义的委托类的接口；</li><li>丰富原始类的操作</li></ul><h3 id="动态代理的具体实现"><a href="#动态代理的具体实现" class="headerlink" title="动态代理的具体实现"></a>动态代理的具体实现</h3><p>本来是不想写一堆代码来说动态代理的代码是如何实现的，但是没办法，有些问题不通过举例无法说清楚，下面一起来看一个简单的例子吧：</p><p>学生每学期都需要参加期末考试的</p><pre><code>public interface Student {    //参加考试    void exam();}</code></pre><p>学生分为很多专业的，其中计算机专业的学生需要参加计算机专业考试</p><pre><code>public class ComputerStudent implements Student {    private String name;    public ComputerStudent(String name) {        this.name = name;    }    @Override    public void exam() {        System.out.println(name + " 参加计算机专业考试");    }}</code></pre><p>由于每个学生的专业能力不一致，有的需要在考试前刷刷题，有的需要去找学霸辅导一下（抱大腿），等等，总之每个学生在考试前都需要做一些事情。</p><p>如果现在需要定义很多不同特点的学生，你怎么做呢？如果去一个个定义不同的行为的话，那将是非常庞大的工作量，那有没有简单的办法呢？答案是有的，通过代理类就可以实现。</p><p>事实上我们没有必要去定义每个学生，因为每个学生的行为是没办法确定的，我们可以通过动态代理在它做这个动作的时候去实现他的特定行为。</p><pre><code>public class Test {    public static void main(String[] args){        //生成$Proxy0的class文件        //System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");        //被代理类        final Student jack =new ComputerStudent("jack");        //生成代理对象     Student jackProxy= (Student) Proxy.newProxyInstance(jack.getClass().getClassLoader(),                jack.getClass().getInterfaces(),                new InvocationHandler() {                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                        System.out.println("before exam do something");                        //通过反射调用对象的方法                        method.invoke(jack,args);                        System.out.println("after exam do something");                        return null;                    }                });        //代理方法调用        jackProxy.exam();    }}</code></pre><p>当调用代理类的<code>exam()</code>方法，程序运行结果如下</p><p><img src="/2021/04/02/yi-wen-du-dong-dong-tai-dai-li/640" alt="图片">img</p><p>这里有个重点，通过代理类对象jackProxy去调用方法和接口实现类对象jack去调用方法是有明显区别的,通过代理方式去调用，可以在原来方法执行前后做一些其它操作，这就是代理模式的特点</p><h3 id="那些你容易忽略的细节"><a href="#那些你容易忽略的细节" class="headerlink" title="那些你容易忽略的细节"></a>那些你容易忽略的细节</h3><p>首先回顾一下动态代理的实现流程：</p><ul><li>1、通过<code>Proxy.newProxyInstance</code>方法创建一个代理对象；</li><li>2、在内部类<code>InvocationHandler</code>的<code>invoke()</code>方法中做一些操作：利用反射调用被代理类（这里是ComputerStudent）中的方法，通常在这个调用方法前后还会做一些其它操作；</li><li>3、代理对象jackProxy调用方法 对整个流程有个了解之后，下面来看一些细节问题。</li></ul><h5 id="Q1：Proxy-newProxyInstance中的3个参数到底是什么？为什么要穿入这3个参数？"><a href="#Q1：Proxy-newProxyInstance中的3个参数到底是什么？为什么要穿入这3个参数？" class="headerlink" title="Q1：Proxy.newProxyInstance中的3个参数到底是什么？为什么要穿入这3个参数？"></a>Q1：Proxy.newProxyInstance中的3个参数到底是什么？为什么要穿入这3个参数？</h5><p>系统接口定义如下：</p><pre><code>public static Object newProxyInstance(ClassLoader loader,                                          Class&lt;?&gt;[] interfaces,                                          InvocationHandler h)</code></pre><ul><li><code>loader</code> :定义代理类的类加载器，这里要代理的是jack,所以用jack的类加载器</li><li><code>interfaces</code> :是一个接口类的集合，具体来说是代理类实现的接口的集合，也是被代理类实现的接口的集合；</li><li><code>h</code> :代理类对象调用方法时需要用到的一个接口对象，在系统生成的代理类内部会用到它。</li></ul><p>到这里，我想细心的童鞋会想这个代理类到底是什么？似乎从头到尾没有露面过。的确是这样，即使你去翻遍源码你也找不到这个代理类，因为在动态代理模式中它是在运行时生成的，所以你在源码甚至<code>.class</code>中都找不到他的影子。</p><p><strong>我先说结论：运行时动态生成的代理类叫做$Proxy0，关于这个类怎么看源码，很多介绍代理的文章都没有说清楚，读者也是一脸懵逼；如果你想要看它的内容，可以通过如下方法</strong></p><pre><code>public class Test {    public static void main(String[] args){        //生成$Proxy0的class文件        System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");        //被代理类     Student jack =new ComputerStudent("jack");        //生成代理对象     Student jackProxy= (Student) Proxy.newProxyInstance();}</code></pre><p>在运行方法中添加这一行代码，在运行后会自动在项目根目录生成com文件夹，其中<code>...\IdeaProjects\com\sun\proxy下会生成$Proxy0.class</code>文件。注意：我是在IDEA上调试成功的，我在Android Studio上测试是没有生成的。暂时不知道原理，有了解的大佬可以科普一下。<code>System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");</code></p><p>代理类$Proxy0源码如下：</p><pre><code>package com.sun.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import student.Student;public final class $Proxy0 extends Proxy implements Student {    private static Method m1;    private static Method m3;    private static Method m2;    private static Method m0;    public $Proxy0(InvocationHandler var1) throws  {        super(var1);    }    public final boolean equals(Object var1) throws  {        try {            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});        } catch (RuntimeException | Error var3) {            throw var3;        } catch (Throwable var4) {            throw new UndeclaredThrowableException(var4);        }    }    public final void exam() throws  {        try {            super.h.invoke(this, m3, (Object[])null);        } catch (RuntimeException | Error var2) {            throw var2;        } catch (Throwable var3) {            throw new UndeclaredThrowableException(var3);        }    }    public final String toString() throws  {        try {            return (String)super.h.invoke(this, m2, (Object[])null);        } catch (RuntimeException | Error var2) {            throw var2;        } catch (Throwable var3) {            throw new UndeclaredThrowableException(var3);        }    }    public final int hashCode() throws  {        try {            return (Integer)super.h.invoke(this, m0, (Object[])null);        } catch (RuntimeException | Error var2) {            throw var2;        } catch (Throwable var3) {            throw new UndeclaredThrowableException(var3);        }    }    static {        try {            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));            m3 = Class.forName("student.Student").getMethod("exam");            m2 = Class.forName("java.lang.Object").getMethod("toString");            m0 = Class.forName("java.lang.Object").getMethod("hashCode");        } catch (NoSuchMethodException var2) {            throw new NoSuchMethodError(var2.getMessage());        } catch (ClassNotFoundException var3) {            throw new NoClassDefFoundError(var3.getMessage());        }    }}</code></pre><p>关于$Proxy0先说几个结论：</p><ul><li><code>$Proxy0</code> 继承了Proxy,实现了自定义的目标接口Student；</li><li><code>$Proxy0</code>定义了接口Student中的方法exam(),以及Object对象的几个方法equals()、toString()、hashCode()</li><li>构造方法中传了<code>InvocationHandler</code>对象，并且在定义的方法中调用了它的invoke()方法</li></ul><p>回到刚才的问题，<code>Proxy.newProxyInstance</code>为什么要穿入这3个参数？</p><pre><code>        //生成代理对象     Student jackProxy= (Student) Proxy.newProxyInstance(jack.getClass().getClassLoader(),                jack.getClass().getInterfaces(),                new InvocationHandler() );</code></pre><p>因为代理对象是基于自定义接口Student和jack类加载器代理出来的。</p><h5 id="Q2：InvocationHandler的作用及其invoke-方法等解释"><a href="#Q2：InvocationHandler的作用及其invoke-方法等解释" class="headerlink" title="Q2：InvocationHandler的作用及其invoke()方法等解释"></a>Q2：InvocationHandler的作用及其invoke()方法等解释</h5><p>当代理对象调用方法时，会回调执行刚才new出来的InvocationHandler中的<code>invoke()</code>方法。</p><p>关于invoke()方法，在看了源码和反复代码验证之后，我做出的解释如下：</p><pre><code> /**     * 这个方法不是我们显示的去调用,是系统生成的代理类$Proxy0中调用的     *     * @param proxy  代理对象：也就是Proxy.newProxyInstance返回的对象     * @param method 要调用的方法     * @param args   调用方法的参数     * @return     * @throws Throwable     */    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {}</code></pre><p><strong>注意：</strong> <code>invoke()</code>不是显示调用的，是在代理类中去调用的。比如调用exam()方法时， 该方法中会调用<code>super.h.invoke(this, m3, null);</code>，就是调用父类的h的invoke()，它的父类是Proxy，h是一个<code>InvocationHandler</code>对象；所以说当调用exam()方法时最后回调到刚才new出来的<code>InvocationHandler</code>的invoke方法。</p><pre><code>public final void exam() throws  {        try {            super.h.invoke(this, m3, (Object[])null);        } catch (RuntimeException | Error var2) {            throw var2;        } catch (Throwable var3) {            throw new UndeclaredThrowableException(var3);        }    }</code></pre><p>下面再来看一个问题</p><pre><code>public class Test {    public static void main(String[] args){        //生成$Proxy0的class文件        //System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");        //被代理类        final Student jack =new ComputerStudent("jack");        //生成代理对象     Student jackProxy= (Student) Proxy.newProxyInstance(jack.getClass().getClassLoader(),                jack.getClass().getInterfaces(),                new InvocationHandler() {                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                        System.out.println("before exam do something");                        //通过反射调用对象的方法                        method.invoke(jack,args);                        System.out.println("after exam do something");                        return null;                    }                });        //方法调用        jackProxy.exam();    }}</code></pre><p>看一下<code>InvocationHandler</code>中invoke()方法内部的调用</p><pre><code>  //通过反射调用对象的方法  method.invoke(jack,args);</code></pre><p>这句代码的作用是通过反射调用一个方法，如果把实现类对象jack换成代理类对象proxy会发生什么？</p><p><strong>结论：会循环报错，停不下来那种。因为proxy是代理实例，也就是这里的jackProxy，当这个对象的方法被调用的时候会触发InvocationHandler中invoke()方法，而InvocationHandler内部又再次调用proxy的方法，如此不停循环。</strong></p><h3 id="动态代理的使用场景"><a href="#动态代理的使用场景" class="headerlink" title="动态代理的使用场景"></a>动态代理的使用场景</h3><p><code>优点：</code>在运行时切入原始类，改变类的方法，这样可以丰富该方法的操作，比如在方法之前、之后做一些其它操作。</p><p>应用的话，比如Retrofit框架、AOP（面向切面编程）等等。</p>]]></content>
      
      
      <categories>
          
          <category> 动态代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea高效实践</title>
      <link href="2021/03/29/idea-gao-xiao-shi-jian/"/>
      <url>2021/03/29/idea-gao-xiao-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>IDEA（IntelliJ IDEA）是业界公认的最好开发工具之一，当然好不好也因人而异，也不要刻意去争谁强谁弱，高手往往不在乎手中的兵器是什么的。个人而言，更高效的工具适合每个开发人员，在编写代码的时候花的时间少，就有更多的时间去设计代码，当然，使用一个陌生的IDE，效率肯定是比不上自己熟练的IDE的，所以为了节省诸君的学习成本，也为了更快地去接纳和熟练IDEA，所以周末之余，故作此文。—- 一品江南</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>所有的电脑软件都有着相同的UI框架、菜单结构，对于每一个开发人员来说，基本的文件操作、项目操作、工作空间操作不成问题，不会讲到。<br>涉及的其他工具（Maven、Git等）不会详细讲，只会讲到如何操作，想要深入学习，关注其他博文。</p><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>在安装软件（JDK、Maven、Git、IDEA）搭建好环境后，要对IDEA进行一番配置，才能开始开发，每个人都有每个人的配置习惯，可以自己研究自己喜欢的配置，进入IDEA的配置 File | Settings（Ctrl+Alt+S）开始配置。</p><p>选择菜单或设置步骤使用 “|” 分开，后面操作一样</p><ol><li><h3 id="主题与行为"><a href="#主题与行为" class="headerlink" title="主题与行为"></a>主题与行为</h3><p>选择自己喜欢的主题：Appearance &amp; Behavior | Appearance | Theme</p></li></ol><p>配置骚气的背景图片：Appearance &amp; Behavior | Appearance | UI Options | Background Image…</p><p>在配置中选择合适的窗口选项：Appearance &amp; Behavior | Appearance | Window Options</p><p> Animate windows：关闭动画效果<br> Show memory indicator：显示内存使用情况<br> Show tool window bars：关闭工具栏显示，按两次Alt键可以显示<br> Small labels in editor tabs：编辑器显示小标签<br>配置自己想看到的菜单项和工具栏：Appearance &amp; Behavior | Menus and Toolbars</p><p>配置启动退出和保存同步：Appearance &amp; Behavior | System Settings</p><ol start="2"><li><h3 id="快捷键与编辑器"><a href="#快捷键与编辑器" class="headerlink" title="快捷键与编辑器"></a>快捷键与编辑器</h3><p>配置快捷键：Keymap</p></li></ol><p>配置Git的Pull操作快捷键：Version Control Systems | Git | Repository | Pull 添加Alt+P<br>配置Maven窗口显示快捷键：Tool Windows | Maven 添加 Alt+3</p><p>优化导包：Editor | General | Auto Import | Java</p><p>Insert imports on paste: All：粘贴的时候导入全部包</p><p> Add unambiguous imports on the fly<br> Optimize imports on the fly (for current project)<br>配置显示行号和方法分隔线：Editor | General | Appearance</p><p> Show line numbers<br> Show method separators<br>配置代码折叠规则：Editor | General | Code Folding</p><p>配置编辑器标签页：Editor | General | Editor Tabs</p><p> Show tabs in one row：多行显示标签<br>配置高效的智能键：Editor | General | Smart Keys</p><p> Insert paired brackets (), [], &lt;&gt;：成双成对输入<br> Reformat block on typing ‘}’：输入’}’后格式化代码<br> Use “CamelHumps” words：使用驼峰词，使用Ctrl+Righ/Left可以词内移动</p><p> Jump outside closing bracket/quote with Tab：使用Tab键跳到括号/引号外面<br>配置牛逼的字体：Editor | Font</p><p> Enable font ligatures：使用连字符<br>推荐字段：Fira Code，使用连字符输入&gt;=,&lt;=,==,!=,=&gt;等符号有惊喜。</p><p>配置文件和代码模板：Editor | File and Code Templates</p><p>配置文件编码：Editor | File Encodings</p><p>建议全部配置成 UTF-8</p><p>配置代码片段：Editor | Live Templates</p><p>添加高效的代码片段可以提高效率</p><h3 id="编译构建"><a href="#编译构建" class="headerlink" title="编译构建"></a>编译构建</h3><p>配置JDK环境：File | Other Settings | Structure for New Projects… | Project | Project SDK</p><p>配置Maven构建：Build, Execution, Deployment | Maven</p><p>配置Maven主目录：D:/apache-maven-3.5.4</p><p>配置用户Maven设置文件：D:\apache-maven-3.5.4\conf\settings.xml</p><p>配置本地仓库：D:\apache-maven-3.5.4\repo</p><p> Always update snapshots：构建时总是更新依赖快照版本</p><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>配置Git管理：Version Control | Git</p><p>配置Git路径：D:\Program Files\Git\bin\git.exe</p><h3 id="运行内存"><a href="#运行内存" class="headerlink" title="运行内存"></a>运行内存</h3><p>编辑IDEA安装目录下bin目录：D:\IntelliJ IDEA\bin\idea64.exe.vmoptions文件</p><pre class="line-numbers language-properties"><code class="language-properties">-Xms750m-Xmx750m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行内存配置可以配置IDEA初时内存大小和最大内存数，根据自己电脑配置优化</p><h2 id="三、视图"><a href="#三、视图" class="headerlink" title="三、视图"></a>三、视图</h2><p>好的界面布局和主题，会让开发者更舒适。快速地能看到想要的信息，会让开发者事半功倍。</p><h3 id="1-0-工具"><a href="#1-0-工具" class="headerlink" title="1.0 工具"></a>1.0 工具</h3><p>常用的工具栏默认位于IDEA界面的左、右、下三侧，也可以用鼠标悬停界面左下角图标弹出所有工具栏，你如果在前面主题与行为中配置隐藏工具栏显示，可以按两次 Alt 键显示。按键Esc可以帮助你从任何激活的工具栏返回到代码编辑。每个工具栏窗口顶部都会有一个Toolbar，可快速实现某些常用功能以及配置。</p><p>推荐使用快捷键弹出想要使用的工具栏，不建议修改默认快捷键，但常用的工具栏如果没有快捷键，应当自定义：</p><p>Alt+1：Project<br>Alt+2：Favorites<br>Alt+3：Maven（自定义）<br>Alt+4：Run<br>Alt+5：Debug<br>Alt+6：TODO<br>Alt+7：Structure<br>Alt+9：Version Control<br>Alt+F12：Terminal</p><h4 id="1-1-Project"><a href="#1-1-Project" class="headerlink" title="1.1 Project"></a>1.1 Project</h4><p>Project工具栏主要是管理项目文件和目录，所有的项目资源都能在些找到，而且它可以有多种管理形式，可以更好聚焦于当前工作。</p><p>管理形式</p><p>Project：显示项目所有资源<br>Packages：显示项目所有包，适合开发模式<br>Tests：显示项目所有测试资源，适合测试模式<br>Problems：显示项目所有问题，所有存在问题的代码都会列举<br>Changed Files：显示项目所有修改资源，VCS中修改未提交的代码<br>Toolbar：<br>Scroll form source：从当前打开的文件定位文件树位置<br>Collapse All：折叠所有目录（Ctrl+-）<br>Setting：打开工具栏设置<br> Flatten Packages：平铺展示所有包<br> Compact Middle Packages：折叠包名显示<br>Hide：隐藏工具栏（Shift+Esc）<br>由于所有的工具栏都会有Setting和Hide，所以后面不会再说，在Setting里面会挑选几个常用的设置说。在Setting中的View Mode配置工具栏的显示模式：</p><p>Dock Pinned：钉住停靠显示<br>Dock Unpinned：不钉信停靠显示，激活其他工具栏隐藏<br>Undock：不停靠显示，类似Dock Unpinned<br>Float：浮动显示<br>Window：窗口模式显示，在全屏查看日志时非常有用<br>技巧</p><p>在展开的文件树中，可以直接输入字母对类或包进行模糊搜索，快速定位目标。</p><p>在很多的窗口都可以这样进行模糊搜索，可以自己大胆尝试，效率大大地提高，不过注意要使用英文输入法。</p><p>使用 Left/Right 键可以快速折叠/展开当前目录<br>使用 Alt+Home 可以导航当前项目</p><h4 id="1-2-Favorites"><a href="#1-2-Favorites" class="headerlink" title="1.2 Favorites"></a>1.2 Favorites</h4><p>Favorites可以用来管理开发人员高频使用的目录或文件，可以是包和类，或者是类中的某一行，它分为三类：</p><p>项目：在Project工具栏中对包或类右击选择 Add Favorites 添加</p><p>书签：在Project工具栏中对包或类或者代码某行，按 F11 添加书签</p><p>断点：打断点就会创建</p><p>在很多地方使用 F4 快捷键可以快速跳转到源码或目录位置。比如选中 Favorites 中的某个书签或断点，选中 VCS 中的某个记录文件。</p><h4 id="1-3-Maven"><a href="#1-3-Maven" class="headerlink" title="1.3. Maven"></a>1.3. Maven</h4><p>Maven是管理Maven项目的工具集合，可以执行Maven的生命周期和插件，可以查看依赖等。<br>Toolbar：</p><p>Reimport All Maven Projects：重新导入Maven项目和依赖<br>Generate Sources and Update Folders For All Projects：创建源码更新目录<br>Download Sources and/or Documentation：下载源码或文档<br>Add Maven Projects：添加Maven项目<br>Run Maven Build：运行Maven生命周期或插件Goal<br>Execute Maven Goal：运行Maven插件Goal<br>Toggle Offline Mode：切换离线模式<br>Toggle ‘Skip Tests’ Mode：是否跳过测试<br>Setting</p><p> Group Modules：Maven模块分组展示<br> Always Show ArtifactId：总是展示项目ArtifactId<br>Profiles</p><p>选择激活Maven配置的Profile</p><h4 id="1-4-TODO"><a href="#1-4-TODO" class="headerlink" title="1.4 TODO"></a>1.4 TODO</h4><p>TODO是管理项目代码中所有含有 // TODO 注释以及 // FIXME 注释的代码，这类特殊注释可以帮助开发人员处理事务。</p><h4 id="1-5-Structure"><a href="#1-5-Structure" class="headerlink" title="1.5 Structure"></a>1.5 Structure</h4><p>Structure可以管理文件结构，包括类、接口等源文件的属性、方法等。<br>Toolbar：</p><p>Sort by Visibility：按可见性排序<br>Sort Alphabetically：按字母排序<br>Group Methods by Defining Type：方法按类型分组<br>Show Properties：显示属性<br>Show Fields：显示字段<br>Show non-public：显示非公共的<br>Show Inherited：显示继承的<br>Show Anonymous Classes：显示匿名类<br>Show Lambdas：显示Lambda<br>Autoscroll to Source：自动定位到源码<br>Autoscroll from Source：自动从源码定位</p><h4 id="1-6-Version-Control"><a href="#1-6-Version-Control" class="headerlink" title="1.6 Version Control"></a>1.6 Version Control</h4><p>Version Control是版本管理工具，这里使用Git为例，它一般会有两个固定标签页 Local Changes 和 Log，用来管理本地修改和提交日志。<br>Toolbar：</p><p>Refresh：刷新本地修改列表<br>Commit：提交（Ctrl+K）<br>Revert：撤消选中的修改（Ctrl+Alt+Z）<br>Show Diff：查看修改源文件的Diff（Ctrl+D）<br>Changelists：把修改源文件分组<br>Shelve Silently：搁置修改源文件（Ctrl+Alt+H）<br>Group By：分组方式：Directory、Repository、Module<br>Ignored Files：忽略的文件<br>Expand All：展开所有目录（Ctrl++）<br>Collapse All：折叠所有目录（Ctrl+-）<br>Preview Diff：预览修改源文件的Diff<br>技巧</p><p>查看Diff或者合并冲突的时候使用 F7/Shift+F7 查看下一个/上一个修改或冲突。<br>在提交代码的时候，可以查看历史的Commit信息。</p><p>在提交代码的时候可以配置提交方式和提交前置事件。<br>提交方式：</p><p>Amend commit：和上一次提交合并，等于命令 git commit –amend<br>Sign-off commit：在提交信息后面追加用户签名<br>提交前置事件：</p><p> Alibaba Code Guidelines：阿里开发规约检测（插件）<br> Reformat code：格式化代码<br> Optimize imports：优化包的导入<br> Perform code analyses：代码分析<br> Check TODO（Show All）：检查TODO<br>前置事件非常有用，在提交代码前会自动优化代码的格式以及检查出不合格的代码。</p><p>在推送（Ctrl+Shift+K）代码到远程仓库的时候，可以配置推送Tag以及强推。<br>在IDEA状态栏右边可以操作Git仓库的分支，包括本地仓库和远程仓库。</p><h4 id="1-7-Event-Log"><a href="#1-7-Event-Log" class="headerlink" title="1.7 Event Log"></a>1.7 Event Log</h4><p>Event Log 查看IDEA全局操作的所有日志，当某些操作异常了，可以在此找到答案。</p><h4 id="1-8-Spring"><a href="#1-8-Spring" class="headerlink" title="1.8 Spring"></a>1.8 Spring</h4><p>Spring可以根据当前的Spring框架管理Bean和MVC，对于使用Spring框架的开发人员来说，非常方便。</p><p>技巧</p><p>在Spring项目中，在自己创建的properties配置文件，在添加配置的时候，只有默认的application.properties文件才会有上下文提示，可以在项目右击菜单中 Open Module Settings （F4）中将properties文件添加到Spring上下文环境中。</p><h4 id="1-9-Terminal"><a href="#1-9-Terminal" class="headerlink" title="1.9 Terminal"></a>1.9 Terminal</h4><p>Terminal是IDEA的集成终端，方便执行命令行。</p><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><p>Windows系统的开发人员会觉得CMD的功能太弱鸡，所以会使用Git软件自带的Bash，可以将Bash集成到IDEA中。<br>IDEA集成终端配置Bash：File | Settings | Tools | Terminal | Application settings</p><p>Shell path：D:\Program Files\Git\bin\bash.exe</p><p>NOTE：如果终端出现乱码问题，可以百度解决，很简单。</p><h3 id="2-0-Web"><a href="#2-0-Web" class="headerlink" title="2.0 Web"></a>2.0 Web</h3><p>Web工具栏和Java Enterprise工具栏有点类似，在Web项目中，会管理Servlet、Filter、Listener，当然，如果我们的项目中只用到SpringMVC，而不是自己编写Servlet的话，这工具似乎没有太多的作用。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>在代码视图中，主要是使用快捷键快速浏览一些代码的信息，这些快捷键在开发过程中也是大有用处的。</p><p>查看当前变量、方法、类等的定义：Ctrl+Shift+I<br>查看当前变量、方法、类等的文档注释：Ctrl+Q<br>查看当前方法的参数信息：Ctrl+P<br>查看当前输入表达式信息：Ctrl+Shift+P<br>查看当前上下文信息：Alt+Q（可以查看当前类文件类定义信息）</p><p>技巧</p><p>使用Ctrl+Shift+I快速查看当前枚举、常量的信息<br>调用方法的时候使用Ctrl+P查看当前参数输入情况，由其是重载方法的情况<br>使用Ctrl+Shift+P快速修改某段代码</p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>在文件视图中，可以导航最近修改的文件或位置。</p><p>查看最近修改的文件：Ctrl+E<br>查看最近修改的位置：Ctrl+Shift+E</p><h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><p>窗口视图可以设置IDEA主界面的显示方式。</p><p>演示模式：View | Enter Presentation Mode<br>专注模式：View | Enter Distraction Mode<br>全屏模式：View | Enter Full Mode</p><h1 id="四、导航"><a href="#四、导航" class="headerlink" title="四、导航"></a>四、导航</h1><p>想去哪儿就去哪儿，定位问题与查阅代码都很方便。</p><h3 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h3><p>类全局查找：Ctrl+N<br>文件全局查找：Ctrl+Shift+N<br>符号全局查找：Ctrl+Alt+Shift+N<br>行/列定位：Ctrl+G<br>退回上/下一个位置：Ctrl+Alt + Left/Right<br>跳转到文件上/下一个修改的位置：Ctrl+Alt+Shift + Top/Bottom<br>切换文件标签页：Ctrl+Tab和Ctrl+Shift+Tab</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>跳转到属性、方法、类定义的位置：Ctrl+B<br>跳转到接口、方法实现的位置：Ctrl+Alt+B<br>跳转到类型定义的位置：Ctrl+Shift+B<br>跳转到父类，父方法的位置：Ctrl+U<br>跳转类测试类、方法的位置：Ctrl+Shift+T<br>跳转到下一个错误位置：F2<br>跳转到上一个错误位置：Shift+F2<br>跳转到上/下一个方法位置：Alt + Top/Bottom<br>跳转到大括号开头/结尾：Ctrl + [/]<br>在代码编辑器的左侧会存在Gutter图标，在设置 File | Settings | Editor | General | Gutter Icons 中我们可以看到这些图标的含义，单击图标也可以跳转到对应的位置。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>查看文件结构：Ctrl+F12<br>查看文件路径：Ctrl+Alt+F12<br>查看类型层次结构：Ctrl+H<br>查看方法层次结构：Ctrl+Shift+H<br>查看调用层次结构：Ctrl+Alt+H</p><h3 id="技巧-1"><a href="#技巧-1" class="headerlink" title="技巧"></a>技巧</h3><p>在查找类、文件的时候可以通过特殊符号定位到类中的某个方法或某行。<br>这个方法在定位问题的时候大有用处，而且只需简单的规则，就可以形成代码的坐标。</p><p>使用#标记类或文件中的某个方法或属性：HttpProxy#get<br>使用:标记类或文件中的某行某列：HttpProxy:37:10<br>在团队之间发送代码位置的时候，使用右击菜单中 Copy Reference（Ctrl+Alt+Shift+C）来复制某个类、方法、属性等的唯一坐标，然后开发人员可以使用Ctrl+N输入坐标来定位代码。</p><p>查看类型层次结构的时候可以使用 Ctrl+Alt+U 来显示类的UML图。<br>在Project文件树中也可以选择类使用 Ctrl+Alt+U生成UML图。</p><h1 id="五、代码"><a href="#五、代码" class="headerlink" title="五、代码"></a>五、代码</h1><p>高效编辑代码，节省苦力活，缩短开发时间，今天不加班。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>重写父类方法：Ctrl+O<br>实现父类接口：Ctrl+I<br>生成代理方法：Code | Delegate Methods<br>生成多种代码：Alt+Insert<br>Constructor：构造方法<br>Getter：Get方法<br>Setter：Set方法<br>Getter and Setter：Get方法和Set方法<br>equals() and hashCode()：equals方法和hashCode方法<br>toString()：toString方法<br>Test：测试类或测试方法<br>Copyright：版权信息<br>@Autowired Dependency：注入Spring Bean<br>插入包围代码：Ctrl+Alt+T<br>if / else / while / for<br>try / catch / finally<br>synchronized / Runnable<br>region…endregion Comments<br>去除包围代码：Ctrl+Shift+Delete<br>补全当前词语：Alt+/或Alt+Shift+/<br>当前行前面插入一行：Ctrl+Alt+Enter<br>当前行后面插入一行：Shift+Enter<br>删除当前行或选中行：Ctrl+Y<br>重复插入当前行或选中行：Ctrl+D<br>在编写代码的时候，经常会要记录一些非代码文件，可以使用 Ctrl+Alt+Shift+Insert 来新建草稿文件，支持多种格式，新建好的草稿文件会保存在 Project 文件树的/Scratches and Consoles/Scratches目录下。</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>选择当前光标所在区域：Ctrl+W，重复使用扩大选择范围<br>缩小当前选择范围：Ctrl+Shift+W<br>选择当前光标所在表达式：Ctrl+Shift+P</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>插入行注释：Ctrl+/<br>插入块注释：Ctrl+Shift+/<br>格式化代码：Ctrl+Alt+L<br>自动缩进对齐：Ctrl+Alt+I<br>生动优化导包：Ctrl+Alt+O<br>列自动对齐：Code | Align to Columns<br>代码折叠<br>折叠/展开当前代码段：Ctrl + -/+<br>折叠/展开全部代码：Ctrl+Shift + -/+<br>折叠全部文档注释：Code | Folding | Collapse doc comments<br>展开全部文档注释：Code | Folding | Expand doc comments</p><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>代码语句上/下移动：Ctrl+Shift + Up/Bottom，可以简单移动方法的位置<br>代码行上/下移动：Alt+Shift + Up/Bottom</p><h3 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h3><p>在快捷键与编辑器配置中说到了如何配置代码片段，代码片段可以明显地提高编辑代码的速度，由其插入高频代码。</p><p>智能片段：可以直接输入，也可以使用Ctrl+J来选择</p><p>包围片段：可以选中一段代码使用Ctrl+Alt+J插入，也可以使用Ctrl+Alt+T</p><h3 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h3><p>在代码中存在红色波浪线的代码都是有问题的代码<br>右侧滚动条上方图标不为绿色的对钩时表示该文件中存在有问题的代码<br>可以点击滚动条的彩色条来定位有问题的代码<br>也可以使用F2和Shift+F2来快速定位有问题的代码<br>滚动条的彩色条颜色决定着问题的严重性，例：警告、错误等<br>光标置于错误代码的时候，左侧会出现电灯泡，单击它有解决办法<br>使用快捷键 Alt+Enter 和单击电灯泡的功能一样<br>不管代码有什么问题，使用 Alt+Enter 总能找到解决办法。</p><p>不要轻易关闭代码的错误提示，级别较低的警告可以酌情处理</p><p>网上有许多坑人的教程，解决报红的错误的办法就是把错误提示关掉，万不可取。</p><h3 id="技巧-2"><a href="#技巧-2" class="headerlink" title="技巧"></a>技巧</h3><p>在接口名称AE选择 Implement interface 快速添加接口的实现类。<br>在抽象类名称AE选择 Implement abstract class 快速添加抽象类的实现类。<br>在类名称AE选择 Create subclass 快速添加该类的子类。<br>在接口、抽象类、类名称AE选择 Create Test 快速添加类的测试类。<br>在方法名称AE选择 Generate missed test methods 创建测试方法。<br>在方法名称AE选择 Generate overloaded method with default parameter values 创建当前方法的重载方法。<br>在属性、方法、类名称AE选择 Add Javadoc 快速添加文档注释。<br>在正则表达式字符串AE选择 Check RegExp 校验正则表达式。<br>AE表示使用Alt+Enter快捷键</p><p>在光标拖动选择的时候按住Alt键可以垂直选择进行多行编辑。<br>按住 Alt+Shift 键使用光标单击可以进行多个位置编辑。<br>在使用Ctrl+F的时候，想要编辑所有的结果可以使用Ctrl+Alt+Shift+J。</p><h1 id="六、分析"><a href="#六、分析" class="headerlink" title="六、分析"></a>六、分析</h1><p>分析项目，分析代码，才能分析设计。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>检查代码：Analyze | Inspect Code<br>检查代码并修复：Analyze | Code Cleanup</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>分析依赖信息：Analyze | Analyze Dependencies<br>分析被依赖信息：Analyze | Analyze Backward Dependencies<br>分析Module依赖信息：Analyze | Analyze Module Dependencies<br>分析依赖矩阵：Analyze | Analyze Dependency Matrix</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>分析传递到当前的数据流：Analyze | Analyze Data Flow to Here<br>分析从当前开始传递的数据流：Analyze | Analyze Data Flow from Here<br>分析异常堆栈信息：Analyze | Analyze Stack Trace</p><h3 id="技巧-3"><a href="#技巧-3" class="headerlink" title="技巧"></a>技巧</h3><p>分析数据流可以追踪方法调用关系。</p><p>可以使用分析异常堆栈信息来处理异常日志。</p><h1 id="七、重构"><a href="#七、重构" class="headerlink" title="七、重构"></a>七、重构</h1><p>珍惜每一次重构的机会，尽量把项目设计的更好。</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>重构当前代码：Ctrl+Alt+Shift+T<br>重命名：Shift+F6<br>修改类或方法签名：Ctrl+F6<br>修改定义类型：Ctrl+Shift+F6<br>修改成静态定义：Refactor | Make Static<br>修改成实例方法：Refactor | Convert To Instance Method<br>移动/复制：F6/F5（可以移动静态变量或方法）<br>安全删除：Alt+Delete<br>提取方法生成代理类：Refactor | Extract | Delegate<br>提取方法生成接口：Refactor | Extract | Interface<br>提取方法生成父类：Refactor | Extract | Superclass</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>对当前表达式提取并封装：Refactor | Extract<br>提取为变量：Ctrl+Alt+V<br>提取为常量：Ctrl+Alt+C<br>提取为类属性：Ctrl+Alt+F<br>提取为方法参数：Ctrl+Alt+P<br>提取为函数式参数：Ctrl+Alt+Shift+P<br>提取为函数式变量：Refactor | Extract | Functional Variable<br>提取方法的多个参数封装为对象：Refactor | Extract | Parameter Object<br>提取为方法：Ctrl+Alt+M<br>提取为方法并封装成对象：Refactor | Extract | Method Object<br>对当前表达式去除封装：Refactor | Inline<br>查找并封装重复代码：Refactor | Find and Replace Code Duplicates<br>倒置布尔类型：Refactor | Invert Boolean<br>去除中介调用：Refactor | Remove Middleman<br>包装方法返回结果：Refactor | Wrap Method Return Value<br>使用方法概括属性：Refactor | Encapsulate Fields<br>变量的初始化提取为方法：Refactor | Replace Temp with Query<br>使用工厂方法替换构造方法：Refactor | Replace Constructor with Factory Method<br>使用构建器替换构造方法：Refactor | Replace Constructor with Builder<br>使用安全的类型填充泛型：Refactor | Generify</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>将类成员推送到父类：Refactor | Pull Members Up<br>将类成员拉取到子类：Refactor | Push Members Dowm<br>使用接口替换类定义：Refactor | Use Interface Where Possible<br>使用代理来替换继承：Refactor | Replace Inheritance with Delegation<br>匿名类替换成内部类：Refactor | Convert Anonymous to Inner</p><h3 id="技巧-4"><a href="#技巧-4" class="headerlink" title="技巧"></a>技巧</h3><p>在Controller方法中，使用 Refactor | Extract | Parameter Object 把多个接收表单的参数封装成VO类。</p><p>灵活运用好重构技能，编码速度可以提高几个档。</p><h1 id="八、构建"><a href="#八、构建" class="headerlink" title="八、构建"></a>八、构建</h1><p>蛋变成鸡的一步，怎样处理好一个蛋，一窝蛋？</p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>构建项目：Build | Build Project （Ctrl+F9）<br>重新构建项目：Build | Rebuild Project （Ctrl+Shift+F9）<br>构建Module：Build | Build Module</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>在菜单 Run 下面会有相关运行的操作，可以在 Run | Edit Configurations 中管理配置各种运行方式。</p><p>运行/调试：Shift + F10/F9<br>运行/调试列表：Alt+Shift + F10/F9<br>停止/重启：Ctrl + F2/F5</p><h4 id="2-1-Main"><a href="#2-1-Main" class="headerlink" title="2.1 Main"></a>2.1 Main</h4><p>如果代码中存在Main方法，并以Main方法形式启动，打开Main方法所有类，除了使用 Alt+F10 或 Alt+Shift+F10 启动之外，也可以单击类名或方法名所在的运行Gutter图标。</p><p>如果想要全屏或者分屏显示运行日志，可以把运行工具窗口的 View Mode 设置成 Window 模式。</p><h4 id="2-2-Tomcat"><a href="#2-2-Tomcat" class="headerlink" title="2.2 Tomcat"></a>2.2 Tomcat</h4><p>如果Web项目要使用Tomcat启动，则先要配置Tomcat Server运行方式，在 Run | Edit Configurations 添加该运行方式，在添加列表中选择 Tomcat Server | Local，配置好后即可运行。</p><p>在配置之前需要在本地下载Tomcat，在 Edit Configurations 配置中可以不仅可以添加运行方式，还可以对每个运行方式进行其他配置，比如：VM Options 等。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>使用Debug启动可以快速定位问题，打断点步进调试是每个开发人员必备的技能，这里不多说，常用快捷键：</p><p>每行执行：F8<br>进入方法：F7<br>跳出方法：Shift+F8<br>执行到下一个断点：F9<br>跳转到当前执行的断点位置：Alt+F10<br>计算表达式：Alt+F8<br>技巧</p><p>在断点停止的时候可以使用计算表达式来调试断点前的数据。</p><p>不小心跳过了自己想要调试的断点，可以使用 Drop Frame 来删除当前栈帧，来重新执行方法。</p><p>在栈帧窗口（Frames）右击，可以使用 Force Return 来强制返回当前方法，或使用 Throw Exception 来抛出异常。</p><h1 id="九、工具"><a href="#九、工具" class="headerlink" title="九、工具"></a>九、工具</h1><p>IDEA不仅仅只是一个写代码的软件，还拥有开发过程中经常使用的工具。</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>在视图工具栏 View | Tool Windows | Database 中可以找到Database工具，点击Toolbar上的加号可以添加数据源，配置好服务器和驱动后就可以使用了，打开 Console 输入SQL，使用 Ctrl+Enter 执行。</p><h3 id="服务器管理"><a href="#服务器管理" class="headerlink" title="服务器管理"></a>服务器管理</h3><p>在工具栏 Tools | Deployment | Browse Remote Host 菜单打开Remote Host工具，点击 … 配置服务器，配置好了之后就可以操作 Remote Host 的文件树了。</p><h3 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h3><p>在任何目录下都可以右击新建文件的时候创建 New HTTP Request 文件来编写HTTP报文来请求和测试HTTP接口，推荐在test目录下创建。创建测试文件如下：</p><pre><code>GET http://localhost:80/api/item?id=99Accept: application/json</code></pre><p>点击每个请求报文左侧的运行Gutter图标就可以发送请求，同样创建POST请求：</p><pre><code>POST http://localhost:80/api/item?id=99Content-Type: application/x-www-form-urlencodedid=1&amp;name=2&amp;gender=1&amp;mobile=1413131212</code></pre><p>可以在请求报文中使用环境变量，使用来引用变量，变量可以在配置文件（http-client.env.json或rest-client.env.json）中定义：</p><pre><code>{  "local": {    "host": "http://localhost:8080",    "x_token": "token"  },  "test": {    "host": "http://10.250.1.122:8087",    "x_token": "token"  }}</code></pre><p>在运行的时候选择不同的环境使用不同的变量：</p><pre><code>POST {{host}}/api/itemContent-Type: application/json{  "name": "ajn",  "age": 24}</code></pre><p>变量也可以在响应脚本中使用client.global.set设置和使用client.global.get获取。</p><p>可以使用响应脚本来测试HTTP请求，脚本使用Javascript语言编写：</p><pre><code>GET https://httpbin.org/status/404Accept: application/json{%client.test("Request executed successfully", function() {client.assert(response.status === 200, "Response status is not 200");});%}</code></pre><p>响应脚本API详解：</p><p>client：客户端对象<br>global：全局变量属性<br>set(string, object)：设置变量<br>get(string)：获取变量<br>isEmpty()：判断全局变量是否为空<br>clear(string)：清除某个变量<br>clearAll()：清除所有变量<br>test(string, function)：测试函数<br>assert(boolean, string)：断言函数<br>log(string)：输出日志函数<br>response：响应对象<br>body：响应体<br>headers：响应头<br>status：响应状态码<br>contentType：响应的ContentType头<br>4. SSH会话<br>在工具栏 Tool | Start SSH session 菜单可以新建SSH会话，在前面服务器管理中如果创建了服务器，会自动添加该服务器的SSH会话。</p><h1 id="十、插件"><a href="#十、插件" class="headerlink" title="十、插件"></a>十、插件</h1><p>强大的功能，还远远不够，一个合格的软件，都应支持功能自由地扩展。</p><ol><li>Lombok<br>Lombok插件支持代码中使用Lombok注解编译生成Get和Set等方法，该插件不仅支持注解，它在菜单中添加了两个功能：</li></ol><p>Refactor | Lombok：插入Lombok注解<br>Refactor | Delombok：将Lombok注解生成代码<br>更多设置：File | Settings | Other Settings | Lombok plugin</p><ol start="2"><li>Alibaba Java Coding Guidelines<br>该插件是结合阿里巴巴Java开发规约而出的，主要功能用于检测代码是否条例阿里开发规范，它结合了IDEA的纠错功能可以快速定位问题和修复问题，在菜单中添加的功能有：</li></ol><p>Tool | 阿里编码规约<br>阿里规约插件提示的问题也可以使用 Alt+Enter 来寻找解决办法。</p><p>技巧</p><p>根据阿里规约，快速分析代码并一键修复。</p><ol start="3"><li>CamelCase<br>CamelCase添加一个快捷键 Alt+Shift+U来修改标识符的下划线、小驼峰、大驼峰等格式，并支持批量转换。</li></ol><p>按住 Alt+Shift 使用鼠标单击可以选择多选编辑。</p><ol start="4"><li>Easy Code<br>Easy Code插件可以根据数据库表和模板来生成代码，可以解决编写重复底层代码的问题。添加的设置项有：</li></ol><p>配置编码和作者名称：Other Settings | Easy Code<br>配置类型映射：Other Settings | Easy Code | Type Mapper<br>配置模板：Other Settings | Easy Code | Template Setting<br>配置全局模板：Other Settings | Easy Code | Global Config<br>只需在 Database 工具栏选中一个或多个表，右击 EasyCode | Generate Code 就可以生成代码，针对单表配置类型映射可以右击 EasyCode | Config Table 来配置。</p><ol start="5"><li>GenerateAllSetter<br>该插件可以一键调用对象的所有Setter方法，在新建对象实例后使用 Alt+Enter 弹出面板中菜单：</li></ol><p>创建似有Setter不带默认值：Generate all setter no default value<br>创建似有Setter带默认值：Generate all setter with default value</p><ol start="6"><li>Maven Helper<br>该插件用于Maven管理，可以分析Maven依赖结构和执行Maven生命周期，添加快捷键 Ctrl+Alt+R 来运行Maven生命周期，可以在 File | Settings | Other Settings | Maven Helper 中进行设置，另外一个功能就是在pom.xml文件下方添加了一个Dependency Analyzer标签，可以用来分析Maven依赖，可以查看和解决Maven依赖冲突。</li></ol><ol start="7"><li>MyBatisX<br>MyBatisX插件主要增强了IDEA对MyBatis框架的支持，可以在 File | Settings | Other Settings | Mybatis 进行设置，它添加的功能有：</li></ol><p>检验Mapper层的代码逻辑<br>添加Mapper层接口与XML文件跳转功能的Gutter图标<br>快速根据接口生成XML标签<br>接口参数生成 @Param 注解</p><ol start="8"><li>RestfulToolkit<br>该插件是管理Restful接口的工具集，它提供的功能有：</li></ol><p>使用快捷键 Ctrl+\ 来根据URL来跳转到方法定义<br>提供了一个接口的树形窗口<br>提供了一个简单的HTTP请求工具<br>在请求方法上生成特殊字符串并复制的功能<br>复制K-V形式的QueryString：Generate &amp; Copy Query Param (Key value)<br>复制JSON形式的请求体：Generate &amp; Copy RequestBody (JSON)<br>复制相对路径URL：Generate &amp; Copy Relation URL<br>复制全路径URL：Generate &amp; Copy Full URL<br>在Java类上生成JSON并复制的功能<br>复制压缩格式的JSON：Convert to JSON(Compressed)<br>复制JSON：Convert to JSON</p><p>参考文献</p><p>IDEA快捷键手册：Help | Keymap Reference<br>IDEA 2019.1 官方文档：<a href="https://www.jetbrains.com/help/idea/2019.1/">https://www.jetbrains.com/help/idea/2019.1/</a></p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缓存雪崩、击穿、穿透</title>
      <link href="2021/03/26/huan-cun-xue-beng-ji-chuan-chuan-tou/"/>
      <url>2021/03/26/huan-cun-xue-beng-ji-chuan-chuan-tou/</url>
      
        <content type="html"><![CDATA[<h1 id="再也不怕，缓存雪崩、击穿、穿透！"><a href="#再也不怕，缓存雪崩、击穿、穿透！" class="headerlink" title="再也不怕，缓存雪崩、击穿、穿透！"></a>再也不怕，缓存雪崩、击穿、穿透！</h1><p>用户的数据一般都是存储于数据库，数据库的数据是落在磁盘上的，磁盘的读写速度可以说是计算机里最慢的硬件了。</p><p>当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就奔溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层，因为 Redis 是内存数据库，我们可以将数据库的数据缓存在 Redis 里，相当于数据缓存在内存，内存的读写速度比硬盘快好几个数量级，这样大大提高了系统性能。</p><p><img src="/2021/03/26/huan-cun-xue-beng-ji-chuan-chuan-tou/9213770f60764317bb29f508e712c6ef~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>引入了缓存层，就会有缓存异常的三个问题，分别是<strong>缓存雪崩、缓存击穿、缓存穿透</strong>。</p><p>这三个问题也是面试中很常考察的问题，我们不光要清楚地知道它们是怎么发生，还需要知道如何解决它们。</p><p>话不多说，<strong>发车！</strong></p><p><img src="/2021/03/26/huan-cun-xue-beng-ji-chuan-chuan-tou/46952feda8364dcc92ed898d5724b0e2~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><hr><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>通常我们为了保证缓存中的数据与数据库中的数据一致性，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里。</p><p><img src="/2021/03/26/huan-cun-xue-beng-ji-chuan-chuan-tou/f8f4f7d39e2f4849bceaaeece0df2bfd~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>那么，当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong>的问题。</p><p>可以看到，发生缓存雪崩有两个原因：</p><ul><li>大量数据同时过期；</li><li>Redis 故障宕机；</li></ul><p>不同的诱因，应对的策略也会不同。</p><h4 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h4><p>针对大量数据同时过期而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li>均匀设置过期时间；</li><li>互斥锁；</li><li>双 key 策略；</li><li>后台更新缓存；</li></ul><p><em>1. 均匀设置过期时间</em></p><p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p><p><em>2. 互斥锁</em></p><p>当业务线程在处理用户请求时，如果发现访问的数据不在 Redis 里，就<strong>加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p><p>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p><p><em>3. 双 key 策略</em></p><p>我们对缓存数据可以使用两个 key，一个是<strong>主 key，会设置过期时间</strong>，一个是<strong>备 key，不会设置过期</strong>，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。</p><p>当业务线程访问不到「主 key 」的缓存数据时，就直接返回「备 key 」的缓存数据，然后在更新缓存的时候，<strong>同时更新「主 key 」和「备 key 」的数据</strong>。</p><p><em>4. 后台更新缓存</em></p><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</strong>。</p><p>事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为<strong>当系统内存紧张的时候，有些缓存数据会被“淘汰”</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p><p>解决上面的问题的方式有两种。</p><p>第一种方式，后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新致缓存。</p><p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p><p>第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</p><p>在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的<strong>缓存预热</strong>，后台更新缓存的机制刚好也适合干这个事情。</p><h4 id="Redis-故障宕机"><a href="#Redis-故障宕机" class="headerlink" title="Redis 故障宕机"></a>Redis 故障宕机</h4><p>针对 Redis 故障宕机而引发的缓存雪崩问题，常见的应对方法有下面这几种：</p><ul><li>服务熔断或请求限流机制；</li><li>构建 Redis 缓存高可靠集群；</li></ul><p><em>1. 服务熔断或请求限流机制</em></p><p>因为 Redis 故障宕机而导致缓存雪崩问题时，我们可以启动<strong>服务熔断</strong>机制，暂停业务应用对缓存服务的访问，直接返回错误，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p><p>服务熔断机制是保护数据库的正常允许，但是暂停了业务应用访问缓存服系统，全部业务都无法正常工作</p><p>为了减少对业务的影响，我们可以启用<strong>请求限流</strong>机制，只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p><p><em>2. 构建 Redis 缓存高可靠集群</em></p><p>服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过<strong>主从节点的方式构建 Redis 缓存高可靠集群</strong>。</p><p>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</p><hr><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。</p><p>如果缓存中的<strong>某个热点数据过期</strong>了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是<strong>缓存击穿</strong>的问题。</p><p><img src="/2021/03/26/huan-cun-xue-beng-ji-chuan-chuan-tou/c2139bf6993048f7ac769c85623c10ed~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>可以发现缓存击穿跟缓存雪崩很相似，你可以认为缓存击穿是缓存雪崩的一个子集。</p><p>应对缓存击穿可以采取前面说到两种方案：</p><ul><li>互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li></ul><hr><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>当发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力，而缓存穿透就不一样了。</p><p>当用户访问的数据，<strong>既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是<strong>缓存穿透</strong>的问题。</p><p><img src="/2021/03/26/huan-cun-xue-beng-ji-chuan-chuan-tou/e59ab0deee5a4a92945e97e1da84b616~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>缓存穿透的发生一般有这两种情况：</p><ul><li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li><li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li></ul><p>应对缓存穿透的方案，常见的方案有三种。</p><ul><li>第一种方案，非法请求的限制；</li><li>第二种方案，缓存空值或者默认值；</li><li>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在；</li></ul><p><em>第一种方案，非法请求的限制</em></p><p>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p><p><em>第二种方案，缓存空值或者默认值</em></p><p>当我们线上业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</p><p><em>第三种方案，使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。</em></p><p>我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。</p><p>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p><p>那问题来了，布隆过滤器是如何工作的呢？接下来，我介绍下。</p><p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。</p><p>布隆过滤器会通过 3 个操作完成标记：</p><ul><li>第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li><li>第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li><li>第三步，将每个哈希值在位图数组的对应位置的值设置为 1；</li></ul><p>举个例子，假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。</p><p>在数据库写入数据 x 后，把数据 x 标记在布隆过滤器时，数据 x 会被 3 个哈希函数分别计算出 3 个哈希值，然后在对这 3 个哈希值对 8 取模，假设取模的结果为 1、4、6，然后把位图数组的第 1、4、6 位置的值设置为 1。<strong>当应用要查询数据 x 是否在数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中</strong>。</p><p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p><p>所以，<strong>查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据</strong>。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>缓存异常会面临的三个问题：缓存雪崩、击穿和穿透。</p><p>其中，缓存雪崩和缓存击穿主要原因是数据不在缓存中，而导致大量请求访问了数据库，数据库压力骤增，容易引发一系列连锁反应，导致系统奔溃。不过，一旦数据被重新加载回缓存，应用又可以从缓存快速读取数据，不再继续访问数据库，数据库的压力也会瞬间降下来。因此，缓存雪崩和缓存击穿应对的方案比较类似。</p><p>而缓存穿透主要原因是数据既不在缓存也不在数据库中。因此，缓存穿透与缓存雪崩、击穿应对的方案不太一样。</p><p>我这里整理了表格，你可以从下面这张表格很好的知道缓存雪崩、击穿和穿透的区别以及应对方案。</p><p><img src="/2021/03/26/huan-cun-xue-beng-ji-chuan-chuan-tou/9db79d7d14484b71bcd8503b724e725d~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><hr><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ol><li>《极客时间：Redis核心技术与实战》</li></ol>]]></content>
      
      
      <categories>
          
          <category> cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx体系化全面认识</title>
      <link href="2021/03/26/nginx-ti-xi-hua-quan-mian-ren-shi/"/>
      <url>2021/03/26/nginx-ti-xi-hua-quan-mian-ren-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一名前端开发人员，你是不是经常碰到领导让你上服务器去修改 <code>Nginx</code> 配置，然而你会以“我是前端，这个我不会”为理由搪塞过去呢！今天就让我们一起告别这种尴尬，向“真正”的程序员迈进！！！</p><p>如果本文对你有所帮助，请点个👍 👍 👍 吧！</p><h1 id="Nginx-概述"><a href="#Nginx-概述" class="headerlink" title="Nginx 概述"></a>Nginx 概述</h1><p><img src="/2021/03/26/nginx-ti-xi-hua-quan-mian-ren-shi/ac3508ff464e4e379969a7fbca0e6d32~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><p><code>Nginx</code> 是开源、高性能、高可靠的 <code>Web</code> 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 <code>Nginx</code> 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是， <code>Nginx</code> 是免费的并可以商业化，配置使用也比较简单。</p><h1 id="Nginx-特点"><a href="#Nginx-特点" class="headerlink" title="Nginx 特点"></a>Nginx 特点</h1><ul><li>高并发、高性能；</li><li>模块化架构使得它的扩展性非常好；</li><li>异步非阻塞的事件驱动模型这点和 <code>Node.js</code> 相似；</li><li>相对于其它服务器来说它可以连续几个月甚至更长而不需要重启服务器使得它具有高可靠性；</li><li>热部署、平滑升级；</li><li>完全开源，生态繁荣；</li></ul><h1 id="Nginx-作用"><a href="#Nginx-作用" class="headerlink" title="Nginx 作用"></a>Nginx 作用</h1><p>Nginx 的最重要的几个使用场景：</p><ol><li>静态资源服务，通过本地文件系统提供服务；</li><li>反向代理服务，延伸出包括缓存、负载均衡等；</li><li><code>API</code> 服务， <code>OpenResty</code> ；</li></ol><p>对于前端来说 <code>Node.js</code> 并不陌生， <code>Nginx</code> 和 <code>Node.js</code> 的很多理念类似， <code>HTTP</code> 服务器、事件驱动、异步非阻塞等，且 <code>Nginx</code> 的大部分功能使用 <code>Node.js</code> 也可以实现，但 <code>Nginx</code> 和 <code>Node.js</code> 并不冲突，都有自己擅长的领域。 <code>Nginx</code> 擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等）， <code>Node.js</code> 更擅长上层具体业务逻辑的处理，两者可以完美组合。</p><p>用一张图表示：<br><img src="/2021/03/26/nginx-ti-xi-hua-quan-mian-ren-shi/070a90dae22c4693858f367bc60934b2~tplv-k3u1fbpfcp-zoom-1.image" alt="未命名文件.png"></p><h1 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h1><p>本文演示的是 <code>Linux</code> <code>centOS 7.x</code> 的操作系统上安装 <code>Nginx</code> ，至于在其它操作系统上进行安装可以网上自行搜索，都非常简单的。</p><p>使用  <code>yum</code> 安装 <code>Nginx</code> ：</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> nginx -y复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装完成后，通过 <code>rpm -ql nginx</code> 命令查看 <code>Nginx</code> 的安装信息：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Nginx配置文件</span>/etc/nginx/nginx.conf <span class="token comment" spellcheck="true"># nginx 主配置文件</span>/etc/nginx/nginx.conf.default<span class="token comment" spellcheck="true"># 可执行程序文件</span>/usr/bin/nginx-upgrade/usr/sbin/nginx<span class="token comment" spellcheck="true"># nginx库文件</span>/usr/lib/systemd/system/nginx.service <span class="token comment" spellcheck="true"># 用于配置系统守护进程</span>/usr/lib64/nginx/modules <span class="token comment" spellcheck="true"># Nginx模块目录</span><span class="token comment" spellcheck="true"># 帮助文档</span>/usr/share/doc/nginx-1.16.1/usr/share/doc/nginx-1.16.1/CHANGES/usr/share/doc/nginx-1.16.1/README/usr/share/doc/nginx-1.16.1/README.dynamic/usr/share/doc/nginx-1.16.1/UPGRADE-NOTES-1.6-to-1.10<span class="token comment" spellcheck="true"># 静态资源目录</span>/usr/share/nginx/html/404.html/usr/share/nginx/html/50x.html/usr/share/nginx/html/index.html<span class="token comment" spellcheck="true"># 存放Nginx日志文件</span>/var/log/nginx复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要关注的文件夹有两个：</p><ol><li><code>/etc/nginx/conf.d/</code> 是子配置项存放处， <code>/etc/nginx/nginx.conf</code> 主配置文件会默认把这个文件夹中所有子配置项都引入；</li><li><code>/usr/share/nginx/html/</code> 静态文件都放在这个文件夹，也可以根据你自己的习惯放在其他地方；</li></ol><h1 id="Nginx-常用命令"><a href="#Nginx-常用命令" class="headerlink" title="Nginx 常用命令"></a>Nginx 常用命令</h1><p><code>systemctl</code> 系统命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 开机配置</span>systemctl <span class="token function">enable</span> nginx <span class="token comment" spellcheck="true"># 开机自动启动</span>systemctl disable nginx <span class="token comment" spellcheck="true"># 关闭开机自动启动</span><span class="token comment" spellcheck="true"># 启动Nginx</span>systemctl start nginx <span class="token comment" spellcheck="true"># 启动Nginx成功后，可以直接访问主机IP，此时会展示Nginx默认页面</span><span class="token comment" spellcheck="true"># 停止Nginx</span>systemctl stop nginx<span class="token comment" spellcheck="true"># 重启Nginx</span>systemctl restart nginx<span class="token comment" spellcheck="true"># 重新加载Nginx</span>systemctl reload nginx<span class="token comment" spellcheck="true"># 查看 Nginx 运行状态</span>systemctl status nginx<span class="token comment" spellcheck="true"># 查看Nginx进程</span><span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> nginx<span class="token comment" spellcheck="true"># 杀死Nginx进程</span><span class="token function">kill</span> -9 pid <span class="token comment" spellcheck="true"># 根据上面查看到的Nginx进程号，杀死Nginx进程，-9 表示强制结束进程</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Nginx</code> 应用程序命令：</p><pre class="line-numbers language-bash"><code class="language-bash">nginx -s reload  <span class="token comment" spellcheck="true"># 向主进程发送信号，重新加载配置文件，热重启</span>nginx -s reopen     <span class="token comment" spellcheck="true"># 重启 Nginx</span>nginx -s stop    <span class="token comment" spellcheck="true"># 快速关闭</span>nginx -s quit    <span class="token comment" spellcheck="true"># 等待工作进程处理完成后关闭</span>nginx -T         <span class="token comment" spellcheck="true"># 查看当前 Nginx 最终的配置</span>nginx -t         <span class="token comment" spellcheck="true"># 检查配置是否有问题</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Nginx-核心配置"><a href="#Nginx-核心配置" class="headerlink" title="Nginx 核心配置"></a>Nginx 核心配置</h1><h2 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h2><p><code>Nginx</code> 的典型配置示例：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># main段配置信息</span>user  nginx<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true"># 运行用户，默认即是nginx，可以不进行设置</span>worker_processes  auto<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true"># Nginx 进程数，一般设置为和 CPU 核数一样</span>error_log  /var/log/nginx/error.log warn<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># Nginx 的错误日志存放目录</span>pid        /var/run/nginx.pid<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true"># Nginx 服务启动时的 pid 存放位置</span><span class="token comment" spellcheck="true"># events段配置信息</span>events <span class="token punctuation">{</span>    use epoll<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true"># 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的)</span>    worker_connections 1024<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># 每个进程允许最大并发数</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># http段配置信息</span><span class="token comment" spellcheck="true"># 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置</span>http <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true"># 设置日志模式</span>    log_format  main  <span class="token string">'<span class="token variable">$remote_addr</span> - <span class="token variable">$remote_user</span> [<span class="token variable">$time_local</span>] "<span class="token variable">$request</span>" '</span>                      <span class="token string">'<span class="token variable">$status</span> <span class="token variable">$body_bytes_sent</span> "<span class="token variable">$http_referer</span>" '</span>                      <span class="token string">'"<span class="token variable">$http_user_agent</span>" "<span class="token variable">$http_x_forwarded_for</span>"'</span><span class="token punctuation">;</span>    access_log  /var/log/nginx/access.log  main<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># Nginx访问日志存放位置</span>    sendfile            on<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># 开启高效传输模式</span>    tcp_nopush          on<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># 减少网络报文段的数量</span>    tcp_nodelay         on<span class="token punctuation">;</span>    keepalive_timeout   65<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># 保持连接的时间，也叫超时时间，单位秒</span>    types_hash_max_size 2048<span class="token punctuation">;</span>    include             /etc/nginx/mime.types<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true"># 文件扩展名与类型映射表</span>    default_type        application/octet-stream<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># 默认文件类型</span>    include /etc/nginx/conf.d/*.conf<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># 加载子配置项</span>    <span class="token comment" spellcheck="true"># server段配置信息</span>    server <span class="token punctuation">{</span>        listen       80<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true"># 配置监听的端口</span>        server_name  localhost<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true"># 配置的域名</span>        <span class="token comment" spellcheck="true"># location段配置信息</span>        location / <span class="token punctuation">{</span>            root   /usr/share/nginx/html<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># 网站根目录</span>            index  index.html index.htm<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># 默认首页文件</span>            deny 172.168.22.11<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># 禁止访问的ip地址，可以为all</span>            allow 172.168.33.44；<span class="token comment" spellcheck="true"># 允许访问的ip地址，可以为all</span>        <span class="token punctuation">}</span>        error_page 500 502 503 504 /50x.html<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># 默认50x对应的访问页面</span>        error_page 400 404 error.html<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># 同上</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>main</code> 全局配置，对全局生效；</li><li><code>events</code> 配置影响 <code>Nginx</code> 服务器与用户的网络连接；</li><li><code>http</code> 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置；</li><li><code>server</code> 配置虚拟主机的相关参数，一个 <code>http</code> 块中可以有多个 <code>server</code> 块；</li><li><code>location</code> 用于配置匹配的 <code>uri</code> ；</li><li><code>upstream</code> 配置后端服务器具体地址，负载均衡配置不可或缺的部分；</li></ul><p>用一张图清晰的展示它的层级结构：<br><img src="/2021/03/26/nginx-ti-xi-hua-quan-mian-ren-shi/87fffe0360aa4f34adb6258a955aad38~tplv-k3u1fbpfcp-zoom-1.image" alt="未命名文件 (4).png"></p><h2 id="配置文件-main-段核心参数"><a href="#配置文件-main-段核心参数" class="headerlink" title="配置文件 main 段核心参数"></a>配置文件 main 段核心参数</h2><h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>指定运行 <code>Nginx</code> 的 <code>woker</code> 子进程的属主和属组，其中组可以不指定。</p><pre class="line-numbers language-bash"><code class="language-bash">user USERNAME <span class="token punctuation">[</span>GROUP<span class="token punctuation">]</span>user nginx lion<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 用户是nginx;组是lion</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h3><p>指定运行 <code>Nginx</code> <code>master</code> 主进程的 <code>pid</code> 文件存放路径。</p><pre class="line-numbers language-bash"><code class="language-bash">pid /opt/nginx/logs/nginx.pid <span class="token comment" spellcheck="true"># master主进程的的pid存放在nginx.pid的文件</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="worker-rlimit-nofile-number"><a href="#worker-rlimit-nofile-number" class="headerlink" title="worker_rlimit_nofile_number"></a>worker_rlimit_nofile_number</h3><p>指定 <code>worker</code> 子进程可以打开的最大文件句柄数。</p><pre class="line-numbers language-bash"><code class="language-bash">worker_rlimit_nofile 20480<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 可以理解成每个worker子进程的最大连接数量。</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="worker-rlimit-core"><a href="#worker-rlimit-core" class="headerlink" title="worker_rlimit_core"></a>worker_rlimit_core</h3><p>指定 <code>worker</code> 子进程异常终止后的 <code>core</code> 文件，用于记录分析问题。</p><pre class="line-numbers language-bash"><code class="language-bash">worker_rlimit_core 50M<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 存放大小限制</span>working_directory /opt/nginx/tmp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 存放目录</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="worker-processes-number"><a href="#worker-processes-number" class="headerlink" title="worker_processes_number"></a>worker_processes_number</h3><p>指定 <code>Nginx</code> 启动的 <code>worker</code> 子进程数量。</p><pre class="line-numbers language-bash"><code class="language-bash">worker_processes 4<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 指定具体子进程数量</span>worker_processes auto<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 与当前cpu物理核心数一致</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="worker-cpu-affinity"><a href="#worker-cpu-affinity" class="headerlink" title="worker_cpu_affinity"></a>worker_cpu_affinity</h3><p>将每个 <code>worker</code> 子进程与我们的 <code>cpu</code> 物理核心绑定。</p><pre class="line-numbers language-bash"><code class="language-bash">worker_cpu_affinity 0001 0010 0100 1000<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 4个物理核心，4个worker子进程</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>![未命名文件 (1).png](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>将每个 <code>worker</code> 子进程与特定 <code>CPU</code> 物理核心绑定，优势在于，避免同一个 <code>worker</code> 子进程在不同的 <code>CPU</code> 核心上切换，缓存失效，降低性能。但其并不能真正的避免进程切换。</p><h3 id="worker-priority"><a href="#worker-priority" class="headerlink" title="worker_priority"></a>worker_priority</h3><p>指定 <code>worker</code> 子进程的 <code>nice</code> 值，以调整运行 <code>Nginx</code> 的优先级，通常设定为负值，以优先调用 <code>Nginx</code> 。</p><pre class="line-numbers language-bash"><code class="language-bash">worker_priority -10<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 120-10=110，110就是最终的优先级</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>Linux</code> 默认进程的优先级值是120，值越小越优先； <code>nice</code> 定范围为 <code>-20</code> 到 <code>+19</code> 。</p><p>[备注] 应用的默认优先级值是120加上 <code>nice</code> 值等于它最终的值，这个值越小，优先级越高。</p><h3 id="worker-shutdown-timeout"><a href="#worker-shutdown-timeout" class="headerlink" title="worker_shutdown_timeout"></a>worker_shutdown_timeout</h3><p>指定 <code>worker</code> 子进程优雅退出时的超时时间。</p><pre class="line-numbers language-bash"><code class="language-bash">worker_shutdown_timeout 5s<span class="token punctuation">;</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="timer-resolution"><a href="#timer-resolution" class="headerlink" title="timer_resolution"></a>timer_resolution</h3><p><code>worker</code> 子进程内部使用的计时器精度，调整时间间隔越大，系统调用越少，有利于性能提升；反之，系统调用越多，性能下降。</p><pre class="line-numbers language-bash"><code class="language-bash">timer_resolution 100ms<span class="token punctuation">;</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在 <code>Linux</code> 系统中，用户需要获取计时器时需要向操作系统内核发送请求，有请求就必然会有开销，因此这个间隔越大开销就越小。</p><h3 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h3><p>指定 <code>Nginx</code> 的运行方式，前台还是后台，前台用于调试，后台用于生产。</p><pre class="line-numbers language-bash"><code class="language-bash">daemon off<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 默认是on，后台运行模式</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="配置文件-events-段核心参数"><a href="#配置文件-events-段核心参数" class="headerlink" title="配置文件 events 段核心参数"></a>配置文件 events 段核心参数</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p><code>Nginx</code> 使用何种事件驱动模型。</p><pre class="line-numbers language-bash"><code class="language-bash">use method<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 不推荐配置它，让nginx自己选择</span>method 可选值为：select、poll、kqueue、epoll、/dev/poll、eventport复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="worker-connections"><a href="#worker-connections" class="headerlink" title="worker_connections"></a>worker_connections</h3><p><code>worker</code> 子进程能够处理的最大并发连接数。</p><pre class="line-numbers language-bash"><code class="language-bash">worker_connections 1024 <span class="token comment" spellcheck="true"># 每个子进程的最大连接数为1024</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="accept-mutex"><a href="#accept-mutex" class="headerlink" title="accept_mutex"></a>accept_mutex</h3><p>是否打开负载均衡互斥锁。</p><pre class="line-numbers language-bash"><code class="language-bash">accept_mutex on <span class="token comment" spellcheck="true"># 默认是off关闭的，这里推荐打开</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="server-name-指令"><a href="#server-name-指令" class="headerlink" title="server_name 指令"></a>server_name 指令</h2><p>指定虚拟主机域名。</p><pre class="line-numbers language-bash"><code class="language-bash">server_name name1 name2 name3<span class="token comment" spellcheck="true"># 示例：</span>server_name www.nginx.com<span class="token punctuation">;</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>域名匹配的四种写法：</p><ul><li>精确匹配： <code>server_name www.nginx.com</code> ;</li><li>左侧通配： <code>server_name *.nginx.com</code> ;</li><li>右侧统配： <code>server_name  www.nginx.*</code> ;</li><li>正则匹配： <code>server_name ~^www\.nginx\.*$</code> ;</li></ul><p>匹配优先级：<strong>精确匹配 &gt; 左侧通配符匹配 &gt; 右侧通配符匹配 &gt; 正则表达式匹配</strong></p><p><code>server_name</code> 配置实例：</p><p>1、配置本地  <code>DNS</code> 解析 <code>vim /etc/hosts</code> （ <code>macOS</code> 系统）</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 添加如下内容，其中 121.42.11.34 是阿里云服务器IP地址</span>121.42.11.34 www.nginx-test.com121.42.11.34 mail.nginx-test.com121.42.11.34 www.nginx-test.org121.42.11.34 doc.nginx-test.com121.42.11.34 www.nginx-test.cn121.42.11.34 fe.nginx-test.club复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[注意] 这里使用的是虚拟域名进行测试，因此需要配置本地 <code>DNS</code> 解析，如果使用阿里云上购买的域名，则需要在阿里云上设置好域名解析。</p><p>2、配置阿里云 <code>Nginx</code> ，<code>vim /etc/nginx/nginx.conf</code> </p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 这里只列举了http端中的sever端配置</span><span class="token comment" spellcheck="true"># 左匹配</span>server <span class="token punctuation">{</span>    listen    80<span class="token punctuation">;</span>    server_name    *.nginx-test.com<span class="token punctuation">;</span>    root    /usr/share/nginx/html/nginx-test/left-match/<span class="token punctuation">;</span>    location / <span class="token punctuation">{</span>        index index.html<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 正则匹配</span>server <span class="token punctuation">{</span>    listen    80<span class="token punctuation">;</span>    server_name    ~^.*\.nginx-test\<span class="token punctuation">..</span>*$<span class="token punctuation">;</span>    root    /usr/share/nginx/html/nginx-test/reg-match/<span class="token punctuation">;</span>    location / <span class="token punctuation">{</span>        index index.html<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 右匹配</span>server <span class="token punctuation">{</span>    listen    80<span class="token punctuation">;</span>    server_name    www.nginx-test.*<span class="token punctuation">;</span>    root    /usr/share/nginx/html/nginx-test/right-match/<span class="token punctuation">;</span>    location / <span class="token punctuation">{</span>        index index.html<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 完全匹配</span>server <span class="token punctuation">{</span>    listen    80<span class="token punctuation">;</span>    server_name    www.nginx-test.com<span class="token punctuation">;</span>    root    /usr/share/nginx/html/nginx-test/all-match/<span class="token punctuation">;</span>    location / <span class="token punctuation">{</span>        index index.html<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、访问分析</p><ul><li>当访问 <code>www.nginx-test.com</code> 时，都可以被匹配上，因此选择优先级最高的“完全匹配”；</li><li>当访问 <code>mail.nginx-test.com</code> 时，会进行“左匹配”；</li><li>当访问 <code>www.nginx-test.org</code> 时，会进行“右匹配”；</li><li>当访问 <code>doc.nginx-test.com</code> 时，会进行“左匹配”；</li><li>当访问 <code>www.nginx-test.cn</code> 时，会进行“右匹配”；</li><li>当访问 <code>fe.nginx-test.club</code> 时，会进行“正则匹配”；</li></ul><h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>指定静态资源目录位置，它可以写在 <code>http</code> 、 <code>server</code> 、 <code>location</code> 等配置中。</p><pre class="line-numbers language-bash"><code class="language-bash">root path例如：location /image <span class="token punctuation">{</span>    root /opt/nginx/static<span class="token punctuation">;</span><span class="token punctuation">}</span>当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[注意] <code>root</code> 会将定义路径与 <code>URI</code> 叠加， <code>alias</code> 则只取定义路径。</p><h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>它也是指定静态资源目录位置，它只能写在 <code>location</code> 中。</p><pre class="line-numbers language-bash"><code class="language-bash">location /image <span class="token punctuation">{</span>    <span class="token function">alias</span> /opt/nginx/static/image/<span class="token punctuation">;</span><span class="token punctuation">}</span>当用户访问 www.test.com/image/1.png 时，实际在服务器找的路径是 /opt/nginx/static/image/1.png复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[注意] 使用 alias 末尾一定要添加 <code>/</code> ，并且它只能位于 <code>location</code> 中。</p><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>配置路径。</p><pre class="line-numbers language-bash"><code class="language-bash">location <span class="token punctuation">[</span> <span class="token operator">=</span> <span class="token operator">|</span> ~ <span class="token operator">|</span> ~* <span class="token operator">|</span> ^~ <span class="token punctuation">]</span> uri <span class="token punctuation">{</span>    <span class="token punctuation">..</span>.<span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>匹配规则：</p><ul><li><code>=</code> 精确匹配；</li><li><code>~</code> 正则匹配，区分大小写；</li><li><code>~*</code> 正则匹配，不区分大小写；</li><li><code>^~</code> 匹配到即停止搜索；</li></ul><p>匹配优先级： <code>=</code> &gt; <code>^~</code> &gt;  <code>~</code> &gt; <code>~*</code> &gt; 不带任何字符。</p><p>实例：</p><pre class="line-numbers language-bash"><code class="language-bash">server <span class="token punctuation">{</span>  listen    80<span class="token punctuation">;</span>  server_name    www.nginx-test.com<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># 只有当访问 www.nginx-test.com/match_all/ 时才会匹配到/usr/share/nginx/html/match_all/index.html</span>  location <span class="token operator">=</span> /match_all/ <span class="token punctuation">{</span>      root    /usr/share/nginx/html      index index.html  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true"># 当访问 www.nginx-test.com/1.jpg 等路径时会去 /usr/share/nginx/images/1.jpg 找对应的资源</span>  location ~ \.<span class="token punctuation">(</span>jpeg<span class="token operator">|</span>jpg<span class="token operator">|</span>png<span class="token operator">|</span>svg<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>      root /usr/share/nginx/images<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true"># 当访问 www.nginx-test.com/bbs/ 时会匹配上 /usr/share/nginx/html/bbs/index.html</span>  location ^~ /bbs/ <span class="token punctuation">{</span>      root /usr/share/nginx/html<span class="token punctuation">;</span>    index index.html index.htm<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="location-中的反斜线"><a href="#location-中的反斜线" class="headerlink" title="location 中的反斜线"></a>location 中的反斜线</h3><pre class="line-numbers language-bash"><code class="language-bash">location /test <span class="token punctuation">{</span>    <span class="token punctuation">..</span>.<span class="token punctuation">}</span>location /test/ <span class="token punctuation">{</span>    <span class="token punctuation">..</span>.<span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>不带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找 <code>test</code> 目录下的 <code>index.html</code> ；如果没有 <code>test</code> 目录， <code>nginx</code> 则会找是否有 <code>test</code> 文件。</li><li>带 <code>/</code> 当访问 <code>www.nginx-test.com/test</code> 时， <code>Nginx</code> 先找是否有 <code>test</code> 目录，如果有则找 <code>test</code> 目录下的 <code>index.html</code> ，如果没有它也不会去找是否存在 <code>test</code> 文件。</li></ul><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>停止处理请求，直接返回响应码或重定向到其他 <code>URL</code> ；执行 <code>return</code> 指令后， <code>location</code> 中后续指令将不会被执行。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">return</span> code <span class="token punctuation">[</span>text<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> code URL<span class="token punctuation">;</span><span class="token keyword">return</span> URL<span class="token punctuation">;</span>例如：location / <span class="token punctuation">{</span>    <span class="token keyword">return</span> 404<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 直接返回状态码</span><span class="token punctuation">}</span>location / <span class="token punctuation">{</span>    <span class="token keyword">return</span> 404 <span class="token string">"pages not found"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 返回状态码 + 一段文本</span><span class="token punctuation">}</span>location / <span class="token punctuation">{</span>    <span class="token keyword">return</span> 302 /bbs <span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 返回状态码 + 重定向地址</span><span class="token punctuation">}</span>location / <span class="token punctuation">{</span>    <span class="token keyword">return</span> https://www.baidu.com <span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 返回重定向地址</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><p>根据指定正则表达式匹配规则，重写 <code>URL</code> 。</p><pre class="line-numbers language-bash"><code class="language-bash">语法：rewrite 正则表达式 要替换的内容 <span class="token punctuation">[</span>flag<span class="token punctuation">]</span><span class="token punctuation">;</span>上下文：server、location、if示例：rewirte /images/<span class="token punctuation">(</span>.*\.jpg<span class="token punctuation">)</span>$ /pic/<span class="token variable">$1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># $1是前面括号(.*\.jpg)的反向引用</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>flag</code> 可选值的含义：</p><ul><li><code>last</code> 重写后的 <code>URL</code> 发起新请求，再次进入 <code>server</code> 段，重试 <code>location</code> 的中的匹配；</li><li><code>break</code> 直接使用重写后的 <code>URL</code> ，不再匹配其它 <code>location</code> 中语句；</li><li><code>redirect</code> 返回302临时重定向；</li><li><code>permanent</code> 返回301永久重定向；</li></ul><pre class="line-numbers language-bash"><code class="language-bash">server<span class="token punctuation">{</span>  listen 80<span class="token punctuation">;</span>  server_name fe.lion.club<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 要在本地hosts文件进行配置</span>  root html<span class="token punctuation">;</span>  location /search <span class="token punctuation">{</span>      rewrite ^/<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> https://www.baidu.com redirect<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  location /images <span class="token punctuation">{</span>      rewrite /images/<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> /pics/<span class="token variable">$1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  location /pics <span class="token punctuation">{</span>      rewrite /pics/<span class="token punctuation">(</span>.*<span class="token punctuation">)</span> /photos/<span class="token variable">$1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  location /photos <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按照这个配置我们来分析：</p><ul><li>当访问 <code>fe.lion.club/search</code> 时，会自动帮我们重定向到 <code>https://www.baidu.com</code>。</li><li>当访问 <code>fe.lion.club/images/1.jpg</code> 时，第一步重写 <code>URL</code> 为 <code>fe.lion.club/pics/1.jpg</code> ，找到 <code>pics</code> 的 <code>location</code> ，继续重写 <code>URL</code> 为 <code>fe.lion.club/photos/1.jpg</code> ，找到 <code>/photos</code> 的 <code>location</code> 后，去 <code>html/photos</code> 目录下寻找 <code>1.jpg</code> 静态资源。</li></ul><h2 id="if-指令"><a href="#if-指令" class="headerlink" title="if 指令"></a>if 指令</h2><pre class="line-numbers language-bash"><code class="language-bash">语法：if <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>上下文：server、location示例：if<span class="token punctuation">(</span><span class="token variable">$http_user_agent</span> ~ Chrome<span class="token punctuation">)</span><span class="token punctuation">{</span>  rewrite /<span class="token punctuation">(</span>.*<span class="token punctuation">)</span>/browser/<span class="token variable">$1</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>condition</code> 判断条件：</p><ul><li><code>$variable</code> 仅为变量时，值为空或以0开头字符串都会被当做 <code>false</code> 处理；</li><li><code>=</code> 或 <code>!=</code> 相等或不等；</li><li><code>~</code> 正则匹配；</li><li><code>! ~</code> 非正则匹配；</li><li><code>~*</code> 正则匹配，不区分大小写；</li><li><code>-f</code> 或 <code>! -f</code> 检测文件存在或不存在；</li><li><code>-d</code> 或 <code>! -d</code> 检测目录存在或不存在；</li><li><code>-e</code> 或 <code>! -e</code> 检测文件、目录、符号链接等存在或不存在；</li><li><code>-x</code> 或 <code>! -x</code> 检测文件可以执行或不可执行；</li></ul><p>实例：</p><pre class="line-numbers language-bash"><code class="language-bash">server <span class="token punctuation">{</span>  listen 8080<span class="token punctuation">;</span>  server_name localhost<span class="token punctuation">;</span>  root html<span class="token punctuation">;</span>  location / <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token variable">$uri</span> <span class="token operator">=</span> <span class="token string">"/images/"</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        rewrite <span class="token punctuation">(</span>.*<span class="token punctuation">)</span> /pics/ <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当访问 <code>localhost:8080/images/</code> 时，会进入 <code>if</code> 判断里面执行 <code>rewrite</code> 命令。</p><h2 id="autoindex"><a href="#autoindex" class="headerlink" title="autoindex"></a>autoindex</h2><p>用户请求以 <code>/</code> 结尾时，列出目录结构，可以用于快速搭建静态资源下载网站。</p><p><code>autoindex.conf</code> 配置信息：</p><pre class="line-numbers language-bash"><code class="language-bash">server <span class="token punctuation">{</span>  listen 80<span class="token punctuation">;</span>  server_name fe.lion-test.club<span class="token punctuation">;</span>  location /download/ <span class="token punctuation">{</span>    root /opt/source<span class="token punctuation">;</span>    autoindex on<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 打开 autoindex，，可选参数有 on | off</span>    autoindex_exact_size on<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 修改为off，以KB、MB、GB显示文件大小，默认为on，以bytes显示出⽂件的确切⼤⼩</span>    autoindex_format html<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 以html的方式进行格式化，可选参数有 html | json | xml</span>    autoindex_localtime off<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 显示的⽂件时间为⽂件的服务器时间。默认为off，显示的⽂件时间为GMT时间</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当访问 <code>fe.lion.com/download/</code> 时，会把服务器 <code>/opt/source/download/</code> 路径下的文件展示出来，如下图所示：</p><p>![image.png](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>Nginx</code> 提供给使用者的变量非常多，但是终究是一个完整的请求过程所产生数据， <code>Nginx</code> 将这些数据以变量的形式提供给使用者。</p><p>下面列举些项目中常用的变量：</p><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td><code>remote_addr</code></td><td>客户端 <code>IP</code> 地址</td></tr><tr><td><code>remote_port</code></td><td>客户端端口</td></tr><tr><td><code>server_addr</code></td><td>服务端 <code>IP</code> 地址</td></tr><tr><td><code>server_port</code></td><td>服务端端口</td></tr><tr><td><code>server_protocol</code></td><td>服务端协议</td></tr><tr><td><code>binary_remote_addr</code></td><td>二进制格式的客户端 <code>IP</code> 地址</td></tr><tr><td><code>connection</code></td><td><code>TCP</code> 连接的序号，递增</td></tr><tr><td><code>connection_request</code></td><td><code>TCP</code> 连接当前的请求数量</td></tr><tr><td><code>uri</code></td><td>请求的URL，不包含参数</td></tr><tr><td><code>request_uri</code></td><td>请求的URL，包含参数</td></tr><tr><td><code>scheme</code></td><td>协议名， <code>http</code> 或 <code>https</code></td></tr><tr><td><code>request_method</code></td><td>请求方法</td></tr><tr><td><code>request_length</code></td><td>全部请求的长度，包含请求行、请求头、请求体</td></tr><tr><td><code>args</code></td><td>全部参数字符串</td></tr><tr><td><code>arg_参数名</code></td><td>获取特定参数值</td></tr><tr><td><code>is_args</code></td><td><code>URL</code> 中是否有参数，有的话返回 <code>?</code> ，否则返回空</td></tr><tr><td><code>query_string</code></td><td>与 <code>args</code> 相同</td></tr><tr><td><code>host</code></td><td>请求信息中的 <code>Host</code> ，如果请求中没有 <code>Host</code> 行，则在请求头中找，最后使用 <code>nginx</code> 中设置的 <code>server_name</code> 。</td></tr><tr><td><code>http_user_agent</code></td><td>用户浏览器</td></tr><tr><td><code>http_referer</code></td><td>从哪些链接过来的请求</td></tr><tr><td><code>http_via</code></td><td>每经过一层代理服务器，都会添加相应的信息</td></tr><tr><td><code>http_cookie</code></td><td>获取用户 <code>cookie</code></td></tr><tr><td><code>request_time</code></td><td>处理请求已消耗的时间</td></tr><tr><td><code>https</code></td><td>是否开启了 <code>https</code> ，是则返回 <code>on</code> ，否则返回空</td></tr><tr><td><code>request_filename</code></td><td>磁盘文件系统待访问文件的完整路径</td></tr><tr><td><code>document_root</code></td><td>由 <code>URI</code> 和 <code>root/alias</code> 规则生成的文件夹路径</td></tr><tr><td><code>limit_rate</code></td><td>返回响应时的速度上限值</td></tr></tbody></table><p>实例演示 <code>var.conf</code> ：</p><pre class="line-numbers language-bash"><code class="language-bash">server<span class="token punctuation">{</span>    listen 8081<span class="token punctuation">;</span>    server_name var.lion-test.club<span class="token punctuation">;</span>    root /usr/share/nginx/html<span class="token punctuation">;</span>    location / <span class="token punctuation">{</span>        <span class="token keyword">return</span> 200 <span class="token string">"remote_addr: <span class="token variable">$remote_addr</span>remote_port: <span class="token variable">$remote_port</span>server_addr: <span class="token variable">$server_addr</span>server_port: <span class="token variable">$server_port</span>server_protocol: <span class="token variable">$server_protocol</span>binary_remote_addr: <span class="token variable">$binary_remote_addr</span>connection: <span class="token variable">$connection</span>uri: <span class="token variable">$uri</span>request_uri: <span class="token variable">$request_uri</span>scheme: <span class="token variable">$scheme</span>request_method: <span class="token variable">$request_method</span>request_length: <span class="token variable">$request_length</span>args: <span class="token variable">$args</span>arg_pid: <span class="token variable">$arg_pid</span>is_args: <span class="token variable">$is_args</span>query_string: <span class="token variable">$query_string</span>host: <span class="token variable">$host</span>http_user_agent: <span class="token variable">$http_user_agent</span>http_referer: <span class="token variable">$http_referer</span>http_via: <span class="token variable">$http_via</span>request_time: <span class="token variable">$request_time</span>https: <span class="token variable">$https</span>request_filename: <span class="token variable">$request_filename</span>document_root: <span class="token variable">$document_root</span>"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们访问 <code>http://var.lion-test.club:8081/test?pid=121414&amp;cid=sadasd</code> 时，由于 <code>Nginx</code> 中写了 <code>return</code> 方法，因此 <code>chrome</code> 浏览器会默认为我们下载一个文件，下面展示的就是下载的文件内容：</p><pre class="line-numbers language-bash"><code class="language-bash">remote_addr: 27.16.220.84remote_port: 56838server_addr: 172.17.0.2server_port: 8081server_protocol: HTTP/1.1binary_remote_addr: 茉connection: 126uri: /test/request_uri: /test/?pid<span class="token operator">=</span>121414<span class="token operator">&amp;</span>cid<span class="token operator">=</span>sadasdscheme: httprequest_method: GETrequest_length: 518args: pid<span class="token operator">=</span>121414<span class="token operator">&amp;</span>cid<span class="token operator">=</span>sadasdarg_pid: 121414is_args: ?query_string: pid<span class="token operator">=</span>121414<span class="token operator">&amp;</span>cid<span class="token operator">=</span>sadasdhost: var.lion-test.clubhttp_user_agent: Mozilla/5.0 <span class="token punctuation">(</span>Macintosh<span class="token punctuation">;</span> Intel Mac OS X 10_14_0<span class="token punctuation">)</span> AppleWebKit/537.36 <span class="token punctuation">(</span>KHTML, like Gecko<span class="token punctuation">)</span> Chrome/88.0.4324.182 Safari/537.36http_referer: http_via: request_time: 0.000https: request_filename: /usr/share/nginx/html/test/document_root: /usr/share/nginx/html复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Nginx</code> 的配置还有非常多，以上只是罗列了一些常用的配置，在实际项目中还是要学会查阅文档。</p><h1 id="Nginx-应用核心概念"><a href="#Nginx-应用核心概念" class="headerlink" title="Nginx 应用核心概念"></a>Nginx 应用核心概念</h1><p>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</p><p>不管是正向代理还是反向代理，实现的都是上面的功能。</p><p>![image.png](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><blockquote><p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p></blockquote><p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p><p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><blockquote><ul><li>反向代理*（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</li></ul></blockquote><p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p><p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p><p>反向代理的优势：</p><ul><li>隐藏真实服务器；</li><li>负载均衡便于横向扩充后端动态服务；</li><li>动静分离，提升系统健壮性；</li></ul><p>那么“动静分离”是什么？负载均衡又是什么？</p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>动静分离是指在 <code>web</code> 服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提示整个服务的访问性和可维护性。</p><p>![未命名文件.png](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>一般来说，都需要将动态资源和静态资源分开，由于 <code>Nginx</code> 的高并发和静态资源缓存等特性，经常将静态资源部署在 <code>Nginx</code> 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。</p><p>使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。</p><p>这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。</p><p>很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。</p><p>请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是负载均衡，核心是「分摊压力」。 <code>Nginx</code> 实现负载均衡，一般来说指的是将请求转发给服务器集群。</p><p>举个具体的例子，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 <code>B</code> 口， <code>B</code> 口人少车空….”，这个工作人员的作用就是负载均衡。<br>![未命名文件 (3).png](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p><code>Nginx</code> 实现负载均衡的策略：</p><ul><li>轮询策略：默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</li><li>最小连接数策略：将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。</li><li>最快响应时间策略：优先分配给响应时间最短的服务器。</li><li>客户端 <code>ip</code> 绑定策略：来自同一个 <code>ip</code> 的请求永远只分配一台服务器，有效解决了动态网页存在的 <code>session</code> 共享问题。</li></ul><h1 id="Nginx-实战配置"><a href="#Nginx-实战配置" class="headerlink" title="Nginx 实战配置"></a>Nginx 实战配置</h1><p>在配置反向代理和负载均衡等等功能之前，有两个核心模块是我们必须要掌握的，这两个模块应该说是 <code>Nginx</code> 应用配置中的核心，它们分别是： <code>upstream</code> 、<code>proxy_pass</code> 。</p><h2 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h2><p>用于定义上游服务器（指的就是后台提供的应用服务器）的相关信息。</p><p>![未命名文件 (2).png](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><pre class="line-numbers language-bash"><code class="language-bash">语法：upstream name <span class="token punctuation">{</span>    <span class="token punctuation">..</span>.<span class="token punctuation">}</span>上下文：http示例：upstream back_end_server<span class="token punctuation">{</span>  server 192.168.100.33:8081<span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>upstream</code> 内可使用的指令：</p><ul><li><code>server</code> 定义上游服务器地址；</li><li><code>zone</code> 定义共享内存，用于跨 <code>worker</code> 子进程；</li><li><code>keepalive</code> 对上游服务启用长连接；</li><li><code>keepalive_requests</code> 一个长连接最多请求 <code>HTTP</code> 的个数；</li><li><code>keepalive_timeout</code> 空闲情形下，一个长连接的超时时长；</li><li><code>hash</code> 哈希负载均衡算法；</li><li><code>ip_hash</code> 依据 <code>IP</code> 进行哈希计算的负载均衡算法；</li><li><code>least_conn</code> 最少连接数负载均衡算法；</li><li><code>least_time</code> 最短响应时间负载均衡算法；</li><li><code>random</code> 随机负载均衡算法；</li></ul><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>定义上游服务器地址。</p><pre class="line-numbers language-bash"><code class="language-bash">语法：server address <span class="token punctuation">[</span>parameters<span class="token punctuation">]</span>上下文：upstream复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>parameters</code> 可选值：</p><ul><li><code>weight=number</code> 权重值，默认为1；</li><li><code>max_conns=number</code> 上游服务器的最大并发连接数；</li><li><code>fail_timeout=time</code> 服务器不可用的判定时间；</li><li><code>max_fails=numer</code> 服务器不可用的检查次数；</li><li><code>backup</code> 备份服务器，仅当其他服务器都不可用时才会启用；</li><li><code>down</code> 标记服务器长期不可用，离线维护；</li></ul><h3 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h3><p>限制每个 <code>worker</code> 子进程与上游服务器空闲长连接的最大数量。</p><pre class="line-numbers language-bash"><code class="language-bash">keepalive connections<span class="token punctuation">;</span>上下文：upstream示例：keepalive 16<span class="token punctuation">;</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="keepalive-requests"><a href="#keepalive-requests" class="headerlink" title="keepalive_requests"></a>keepalive_requests</h3><p>单个长连接可以处理的最多 <code>HTTP</code> 请求个数。</p><pre class="line-numbers language-bash"><code class="language-bash">语法：keepalive_requests number<span class="token punctuation">;</span>默认值：keepalive_requests 100<span class="token punctuation">;</span>上下文：upstream复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="keepalive-timeout"><a href="#keepalive-timeout" class="headerlink" title="keepalive_timeout"></a>keepalive_timeout</h3><p>空闲长连接的最长保持时间。</p><pre class="line-numbers language-bash"><code class="language-bash">语法：keepalive_timeout <span class="token function">time</span><span class="token punctuation">;</span>默认值：keepalive_timeout 60s<span class="token punctuation">;</span>上下文：upstream复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><pre class="line-numbers language-bash"><code class="language-bash">upstream back_end<span class="token punctuation">{</span>    server 127.0.0.1:8081 weight<span class="token operator">=</span>3 max_conns<span class="token operator">=</span>1000 fail_timeout<span class="token operator">=</span>10s max_fails<span class="token operator">=</span>2<span class="token punctuation">;</span>  keepalive 32<span class="token punctuation">;</span>  keepalive_requests 50<span class="token punctuation">;</span>  keepalive_timeout 30s<span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p>用于配置代理服务器。</p><pre class="line-numbers language-bash"><code class="language-bash">语法：proxy_pass URL<span class="token punctuation">;</span>上下文：location、if、limit_except示例：proxy_pass http://127.0.0.1:8081proxy_pass http://127.0.0.1:8081/proxy复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>URL</code> 参数原则</p><ol><li><code>URL</code> 必须以 <code>http</code> 或 <code>https</code> 开头；</li><li><code>URL</code> 中可以携带变量；</li><li><code>URL</code> 中是否带 <code>URI</code> ，会直接影响发往上游请求的 <code>URL</code> ；</li></ol><p>接下来让我们来看看两种常见的 <code>URL</code> 用法：</p><ol><li><code>proxy_pass http://192.168.100.33:8081</code> </li><li><code>proxy_pass http://192.168.100.33:8081/</code></li></ol><p>这两种用法的区别就是带 <code>/</code> 和不带 <code>/</code> ，在配置代理时它们的区别可大了：</p><ul><li>不带 <code>/</code> 意味着 <code>Nginx</code> 不会修改用户 <code>URL</code> ，而是直接透传给上游的应用服务器；</li><li>带 <code>/</code> 意味着 <code>Nginx</code> 会修改用户 <code>URL</code> ，修改方法是将 <code>location</code> 后的 <code>URL</code> 从用户 <code>URL</code> 中删除；</li></ul><p>不带 <code>/</code> 的用法：</p><pre class="line-numbers language-bash"><code class="language-bash">location /bbs/<span class="token punctuation">{</span>  proxy_pass http://127.0.0.1:8080<span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>分析：</p><ol><li>用户请求 <code>URL</code> ： <code>/bbs/abc/test.html</code> </li><li>请求到达 <code>Nginx</code> 的 <code>URL</code> ： <code>/bbs/abc/test.html</code> </li><li>请求到达上游应用服务器的 <code>URL</code> ： <code>/bbs/abc/test.html</code> </li></ol><p>带 <code>/</code> 的用法：</p><pre class="line-numbers language-bash"><code class="language-bash">location /bbs/<span class="token punctuation">{</span>  proxy_pass http://127.0.0.1:8080/<span class="token punctuation">;</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>分析：</p><ol><li>用户请求 <code>URL</code> ： <code>/bbs/abc/test.html</code> </li><li>请求到达 <code>Nginx</code> 的 <code>URL</code> ： <code>/bbs/abc/test.html</code> </li><li>请求到达上游应用服务器的 <code>URL</code> ： <code>/abc/test.html</code> </li></ol><p>并没有拼接上 <code>/bbs</code> ，这点和 <code>root</code> 与 <code>alias</code> 之间的区别是保持一致的。</p><h2 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h2><p>这里为了演示更加接近实际，作者准备了两台云服务器，它们的公网 <code>IP</code> 分别是： <code>121.42.11.34</code> 与 <code>121.5.180.193</code> 。</p><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># /etc/nginx/conf.d/proxy.conf</span>server<span class="token punctuation">{</span>  listen 8080<span class="token punctuation">;</span>  server_name localhost<span class="token punctuation">;</span>  location /proxy/ <span class="token punctuation">{</span>    root /usr/share/nginx/html/proxy<span class="token punctuation">;</span>    index index.html<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true"># /usr/share/nginx/html/proxy/index.html</span><span class="token operator">&lt;</span>h1<span class="token operator">></span> 121.42.11.34 proxy html <span class="token operator">&lt;</span>/h1<span class="token operator">></span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成后重启 <code>Nginx</code> 服务器 <code>nginx -s reload</code> 。</p><p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># /etc/nginx/conf.d/proxy.conf</span>upstream back_end <span class="token punctuation">{</span>  server 121.42.11.34:8080 weight<span class="token operator">=</span>2 max_conns<span class="token operator">=</span>1000 fail_timeout<span class="token operator">=</span>10s max_fails<span class="token operator">=</span>3<span class="token punctuation">;</span>  keepalive 32<span class="token punctuation">;</span>  keepalive_requests 80<span class="token punctuation">;</span>  keepalive_timeout 20s<span class="token punctuation">;</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>  listen 80<span class="token punctuation">;</span>  server_name proxy.lion.club<span class="token punctuation">;</span>  location /proxy <span class="token punctuation">{</span>      proxy_pass http://back_end/proxy<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本地机器要访问 <code>proxy.lion.club</code> 域名，因此需要配置本地 <code>hosts</code> ，通过命令：<code>vim /etc/hosts</code> 进入配置文件，添加如下内容：</p><pre class="line-numbers language-bash"><code class="language-bash">121.5.180.193 proxy.lion.club复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>![image.png](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>分析：</p><ol><li>当访问 <code>proxy.lion.club/proxy</code> 时通过 <code>upstream</code> 的配置找到 <code>121.42.11.34:8080</code> ；</li><li>因此访问地址变为 <code>http://121.42.11.34:8080/proxy</code> ；</li><li>连接到 <code>121.42.11.34</code> 服务器，找到 <code>8080</code> 端口提供的 <code>server</code> ；</li><li>通过 <code>server</code> 找到 <code>/usr/share/nginx/html/proxy/index.html</code> 资源，最终展示出来。</li></ol><h2 id="配置负载均衡"><a href="#配置负载均衡" class="headerlink" title="配置负载均衡"></a>配置负载均衡</h2><p>配置负载均衡主要是要使用 <code>upstream</code> 指令。</p><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code> ）：</p><pre class="line-numbers language-bash"><code class="language-bash">server<span class="token punctuation">{</span>  listen 8020<span class="token punctuation">;</span>  location / <span class="token punctuation">{</span>      <span class="token keyword">return</span> 200 <span class="token string">'return 8020 \n'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>server<span class="token punctuation">{</span>  listen 8030<span class="token punctuation">;</span>  location / <span class="token punctuation">{</span>      <span class="token keyword">return</span> 200 <span class="token string">'return 8030 \n'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>server<span class="token punctuation">{</span>  listen 8040<span class="token punctuation">;</span>  location / <span class="token punctuation">{</span>      <span class="token keyword">return</span> 200 <span class="token string">'return 8040 \n'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成后：</p><ol><li><code>nginx -t</code> 检测配置是否正确；</li><li><code>nginx -s reload</code> 重启 <code>Nginx</code> 服务器；</li><li>执行 <code>ss -nlt</code> 命令查看端口是否被占用，从而判断 <code>Nginx</code> 服务是否正确启动。</li></ol><p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/balance.conf</code> ）：</p><pre class="line-numbers language-bash"><code class="language-bash">upstream demo_server <span class="token punctuation">{</span>  server 121.42.11.34:8020<span class="token punctuation">;</span>  server 121.42.11.34:8030<span class="token punctuation">;</span>  server 121.42.11.34:8040<span class="token punctuation">;</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>  listen 80<span class="token punctuation">;</span>  server_name balance.lion.club<span class="token punctuation">;</span>  location /balance/ <span class="token punctuation">{</span>      proxy_pass http://demo_server<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置完成后重启 <code>Nginx</code> 服务器。并且在需要访问的客户端配置好 <code>ip</code> 和域名的映射关系。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># /etc/hosts</span>121.5.180.193 balance.lion.club复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在客户端机器执行 <code>curl http://balance.lion.club/balance/</code> 命令：</p><p>![image.png](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>不难看出，负载均衡的配置已经生效了，每次给我们分发的上游服务器都不一样。就是通过简单的轮询策略进行上游服务器分发。</p><p>接下来，我们再来了解下 <code>Nginx</code> 的其它分发策略。</p><h3 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h3><p>通过制定关键字作为 <code>hash key</code> ，基于 <code>hash</code> 算法映射到特定的上游服务器中。关键字可以包含有变量、字符串。</p><pre class="line-numbers language-bash"><code class="language-bash">upstream demo_server <span class="token punctuation">{</span>  <span class="token function">hash</span> <span class="token variable">$request_uri</span><span class="token punctuation">;</span>  server 121.42.11.34:8020<span class="token punctuation">;</span>  server 121.42.11.34:8030<span class="token punctuation">;</span>  server 121.42.11.34:8040<span class="token punctuation">;</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>  listen 80<span class="token punctuation">;</span>  server_name balance.lion.club<span class="token punctuation">;</span>  location /balance/ <span class="token punctuation">{</span>      proxy_pass http://demo_server<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>hash $request_uri</code> 表示使用 <code>request_uri</code> 变量作为 <code>hash</code> 的 <code>key</code> 值，只要访问的 <code>URI</code> 保持不变，就会一直分发给同一台服务器。</p><h3 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h3><p>根据客户端的请求 <code>ip</code> 进行判断，只要 <code>ip</code> 地址不变就永远分配到同一台主机。它可以有效解决后台服务器 <code>session</code> 保持的问题。</p><pre class="line-numbers language-bash"><code class="language-bash">upstream demo_server <span class="token punctuation">{</span>  ip_hash<span class="token punctuation">;</span>  server 121.42.11.34:8020<span class="token punctuation">;</span>  server 121.42.11.34:8030<span class="token punctuation">;</span>  server 121.42.11.34:8040<span class="token punctuation">;</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>  listen 80<span class="token punctuation">;</span>  server_name balance.lion.club<span class="token punctuation">;</span>  location /balance/ <span class="token punctuation">{</span>      proxy_pass http://demo_server<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最少连接数算法"><a href="#最少连接数算法" class="headerlink" title="最少连接数算法"></a>最少连接数算法</h3><p>各个 <code>worker</code> 子进程通过读取共享内存的数据，来获取后端服务器的信息。来挑选一台当前已建立连接数最少的服务器进行分配请求。</p><pre class="line-numbers language-bash"><code class="language-bash">语法：least_conn<span class="token punctuation">;</span>上下文：upstream<span class="token punctuation">;</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-bash"><code class="language-bash">upstream demo_server <span class="token punctuation">{</span>  zone <span class="token function">test</span> 10M<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># zone可以设置共享内存空间的名字和大小</span>  least_conn<span class="token punctuation">;</span>  server 121.42.11.34:8020<span class="token punctuation">;</span>  server 121.42.11.34:8030<span class="token punctuation">;</span>  server 121.42.11.34:8040<span class="token punctuation">;</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>  listen 80<span class="token punctuation">;</span>  server_name balance.lion.club<span class="token punctuation">;</span>  location /balance/ <span class="token punctuation">{</span>      proxy_pass http://demo_server<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后你会发现，负载均衡的配置其实一点都不复杂。</p><h2 id="配置缓存"><a href="#配置缓存" class="headerlink" title="配置缓存"></a>配置缓存</h2><p>缓存可以非常有效的提升性能，因此不论是客户端（浏览器），还是代理服务器（ <code>Nginx</code> ），乃至上游服务器都多少会涉及到缓存。可见缓存在每个环节都是非常重要的。下面让我们来学习 <code>Nginx</code> 中如何设置缓存策略。</p><h3 id="proxy-cache"><a href="#proxy-cache" class="headerlink" title="proxy_cache"></a>proxy_cache</h3><p>存储一些之前被访问过、而且可能将要被再次访问的资源，使用户可以直接从代理服务器获得，从而减少上游服务器的压力，加快整个访问速度。</p><pre class="line-numbers language-bash"><code class="language-bash">语法：proxy_cache zone <span class="token operator">|</span> off <span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># zone 是共享内存的名称</span>默认值：proxy_cache off<span class="token punctuation">;</span>上下文：http、server、location复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="proxy-cache-path"><a href="#proxy-cache-path" class="headerlink" title="proxy_cache_path"></a>proxy_cache_path</h3><p>设置缓存文件的存放路径。</p><pre class="line-numbers language-bash"><code class="language-bash">语法：proxy_cache_path path <span class="token punctuation">[</span>level<span class="token operator">=</span>levels<span class="token punctuation">]</span> <span class="token punctuation">..</span>.可选参数省略，下面会详细列举默认值：proxy_cache_path off上下文：http复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数含义：</p><ul><li><code>path</code> 缓存文件的存放路径；</li><li><code>level path</code> 的目录层级；</li><li><code>keys_zone</code> 设置共享内存；</li><li><code>inactive</code> 在指定时间内没有被访问，缓存会被清理，默认10分钟；</li></ul><h3 id="proxy-cache-key"><a href="#proxy-cache-key" class="headerlink" title="proxy_cache_key"></a>proxy_cache_key</h3><p>设置缓存文件的 <code>key</code> 。</p><pre class="line-numbers language-bash"><code class="language-bash">语法：proxy_cache_key默认值：proxy_cache_key <span class="token variable">$scheme</span><span class="token variable">$proxy_host</span><span class="token variable">$request_uri</span><span class="token punctuation">;</span>上下文：http、server、location复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="proxy-cache-valid"><a href="#proxy-cache-valid" class="headerlink" title="proxy_cache_valid"></a>proxy_cache_valid</h3><p>配置什么状态码可以被缓存，以及缓存时长。</p><pre class="line-numbers language-bash"><code class="language-bash">语法：proxy_cache_valid <span class="token punctuation">[</span>code<span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">time</span><span class="token punctuation">;</span>上下文：http、server、location配置示例：proxy_cache_valid 200 304 2m<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 说明对于状态为200和304的缓存文件的缓存时间是2分钟</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="proxy-no-cache"><a href="#proxy-no-cache" class="headerlink" title="proxy_no_cache"></a>proxy_no_cache</h3><p>定义相应保存到缓存的条件，如果字符串参数的至少一个值不为空且不等于“ 0”，则将不保存该响应到缓存。</p><pre class="line-numbers language-bash"><code class="language-bash">语法：proxy_no_cache string<span class="token punctuation">;</span>上下文：http、server、location示例：proxy_no_cache <span class="token variable">$http_pragma</span>    <span class="token variable">$http_authorization</span><span class="token punctuation">;</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="proxy-cache-bypass"><a href="#proxy-cache-bypass" class="headerlink" title="proxy_cache_bypass"></a>proxy_cache_bypass</h3><p>定义条件，在该条件下将不会从缓存中获取响应。</p><pre class="line-numbers language-bash"><code class="language-bash">语法：proxy_cache_bypass string<span class="token punctuation">;</span>上下文：http、server、location示例：proxy_cache_bypass <span class="token variable">$http_pragma</span>    <span class="token variable">$http_authorization</span><span class="token punctuation">;</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="upstream-cache-status-变量"><a href="#upstream-cache-status-变量" class="headerlink" title="upstream_cache_status 变量"></a>upstream_cache_status 变量</h3><p>它存储了缓存是否命中的信息，会设置在响应头信息中，在调试中非常有用。</p><pre class="line-numbers language-bash"><code class="language-bash">MISS: 未命中缓存HIT： 命中缓存EXPIRED: 缓存过期STALE: 命中了陈旧缓存REVALIDDATED: Nginx验证陈旧缓存依然有效UPDATING: 内容陈旧，但正在更新BYPASS: X响应从原始服务器获取复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置实例-1"><a href="#配置实例-1" class="headerlink" title="配置实例"></a>配置实例</h3><p>我们把 <code>121.42.11.34</code> 服务器作为上游服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code> ）：</p><pre class="line-numbers language-bash"><code class="language-bash">server <span class="token punctuation">{</span>  listen 1010<span class="token punctuation">;</span>  root /usr/share/nginx/html/1010<span class="token punctuation">;</span>  location / <span class="token punctuation">{</span>      index index.html<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>  listen 1020<span class="token punctuation">;</span>  root /usr/share/nginx/html/1020<span class="token punctuation">;</span>  location / <span class="token punctuation">{</span>      index index.html<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把 <code>121.5.180.193</code> 服务器作为代理服务器，做如下配置（ <code>/etc/nginx/conf.d/cache.conf</code> ）：</p><pre class="line-numbers language-bash"><code class="language-bash">proxy_cache_path /etc/nginx/cache_temp levels<span class="token operator">=</span>2:2 keys_zone<span class="token operator">=</span>cache_zone:30m max_size<span class="token operator">=</span>2g inactive<span class="token operator">=</span>60m use_temp_path<span class="token operator">=</span>off<span class="token punctuation">;</span>upstream cache_server<span class="token punctuation">{</span>  server 121.42.11.34:1010<span class="token punctuation">;</span>  server 121.42.11.34:1020<span class="token punctuation">;</span><span class="token punctuation">}</span>server <span class="token punctuation">{</span>  listen 80<span class="token punctuation">;</span>  server_name cache.lion.club<span class="token punctuation">;</span>  location / <span class="token punctuation">{</span>    proxy_cache cache_zone<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 设置缓存内存，上面配置中已经定义好的</span>    proxy_cache_valid 200 5m<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 缓存状态为200的请求，缓存时长为5分钟</span>    proxy_cache_key <span class="token variable">$request_uri</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 缓存文件的key为请求的URI</span>    add_header Nginx-Cache-Status <span class="token variable">$upstream_cache_status</span> <span class="token comment" spellcheck="true"># 把缓存状态设置为头部信息，响应给客户端</span>    proxy_pass http://cache_server<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 代理转发</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>缓存就是这样配置，我们可以在 <code>/etc/nginx/cache_temp</code> 路径下找到相应的缓存文件。</p><p><strong>对于一些实时性要求非常高的页面或数据来说，就不应该去设置缓存，下面来看看如何配置不缓存的内容。</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">..</span>.server <span class="token punctuation">{</span>  listen 80<span class="token punctuation">;</span>  server_name cache.lion.club<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true"># URI 中后缀为 .txt 或 .text 的设置变量值为 "no cache"</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request_uri</span> ~ \.<span class="token punctuation">(</span>txt<span class="token operator">|</span>text<span class="token punctuation">)</span>$<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">set</span> <span class="token variable">$cache_name</span> <span class="token string">"no cache"</span>  <span class="token punctuation">}</span>  location / <span class="token punctuation">{</span>    proxy_no_cache <span class="token variable">$cache_name</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 判断该变量是否有值，如果有值则不进行缓存，如果没有值则进行缓存</span>    proxy_cache cache_zone<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 设置缓存内存</span>    proxy_cache_valid 200 5m<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 缓存状态为200的请求，缓存时长为5分钟</span>    proxy_cache_key <span class="token variable">$request_uri</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 缓存文件的key为请求的URI</span>    add_header Nginx-Cache-Status <span class="token variable">$upstream_cache_status</span> <span class="token comment" spellcheck="true"># 把缓存状态设置为头部信息，响应给客户端</span>    proxy_pass http://cache_server<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 代理转发</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>在学习如何配置 <code>HTTPS</code> 之前，我们先来简单回顾下 <code>HTTPS</code> 的工作流程是怎么样的？它是如何进行加密保证安全的？</p><h3 id="HTTPS-工作流程"><a href="#HTTPS-工作流程" class="headerlink" title="HTTPS 工作流程"></a>HTTPS 工作流程</h3><ol><li>客户端（浏览器）访问 <code>https://www.baidu.com</code> 百度网站；</li><li>百度服务器返回 <code>HTTPS</code> 使用的 <code>CA</code> 证书；</li><li>浏览器验证 <code>CA</code> 证书是否为合法证书；</li><li>验证通过，证书合法，生成一串随机数并使用公钥（证书中提供的）进行加密；</li><li>发送公钥加密后的随机数给百度服务器；</li><li>百度服务器拿到密文，通过私钥进行解密，获取到随机数（公钥加密，私钥解密，反之也可以）；</li><li>百度服务器把要发送给浏览器的内容，使用随机数进行加密后传输给浏览器；</li><li>此时浏览器可以使用随机数进行解密，获取到服务器的真实传输内容；</li></ol><p>这就是 <code>HTTPS</code> 的基本运作原理，使用对称加密和非对称机密配合使用，保证传输内容的安全性。</p><p><a href="https://juejin.cn/post/6844904148601667598#heading-37">关于HTTPS更多知识，可以查看作者的另外一篇文章《学习 HTTP 协议》</a>。</p><h3 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h3><p>下载证书的压缩文件，里面有个 <code>Nginx</code> 文件夹，把 <code>xxx.crt</code> 和 <code>xxx.key</code> 文件拷贝到服务器目录，再进行如下配置：</p><pre class="line-numbers language-bash"><code class="language-bash">server <span class="token punctuation">{</span>  listen 443 ssl http2 default_server<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># SSL 访问端口号为 443</span>  server_name lion.club<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true"># 填写绑定证书的域名(我这里是随便写的)</span>  ssl_certificate /etc/nginx/https/lion.club_bundle.crt<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true"># 证书地址</span>  ssl_certificate_key /etc/nginx/https/lion.club.key<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true"># 私钥地址</span>  ssl_session_timeout 10m<span class="token punctuation">;</span>  ssl_protocols TLSv1 TLSv1.1 TLSv1.2<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 支持ssl协议版本，默认为后三个，主流版本是[TLSv1.2]</span>  location / <span class="token punctuation">{</span>    root         /usr/share/nginx/html<span class="token punctuation">;</span>    index        index.html index.htm<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如此配置后就能正常访问 <code>HTTPS</code> 版的网站了。</p><h2 id="配置跨域-CORS"><a href="#配置跨域-CORS" class="headerlink" title="配置跨域 CORS"></a>配置跨域 CORS</h2><p>先简单回顾下跨域究竟是怎么回事。</p><h3 id="跨域的定义"><a href="#跨域的定义" class="headerlink" title="跨域的定义"></a>跨域的定义</h3><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。</p><h3 id="同源的定义"><a href="#同源的定义" class="headerlink" title="同源的定义"></a>同源的定义</h3><p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p><p>下面给出了与 URL <code>http://store.company.com/dir/page.html</code> 的源进行对比的示例:</p><pre class="line-numbers language-bash"><code class="language-bash">http://store.company.com/dir2/other.html 同源https://store.company.com/secure.html 不同源，协议不同http://store.company.com:81/dir/etc.html 不同源，端口不同http://news.company.com/dir/other.html 不同源，主机不同复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同源会有如下限制：</p><ul><li><code>Web</code> 数据层面，同源策略限制了不同源的站点读取当前站点的 <code>Cookie</code> 、 <code>IndexDB</code> 、 <code>LocalStorage</code> 等数据。</li><li><code>DOM</code> 层面，同源策略限制了来自不同源的 <code>JavaScript</code> 脚本对当前 <code>DOM</code> 对象读和写的操作。</li><li>网络层面，同源策略限制了通过 <code>XMLHttpRequest</code> 等方式将站点的数据发送给不同源的站点。</li></ul><h3 id="Nginx-解决跨域的原理"><a href="#Nginx-解决跨域的原理" class="headerlink" title="Nginx 解决跨域的原理"></a>Nginx 解决跨域的原理</h3><p>例如：</p><ul><li>前端 <code>server</code> 的域名为： <code>fe.server.com</code> </li><li>后端服务的域名为： <code>dev.server.com</code> </li></ul><p>现在我在 <code>fe.server.com</code> 对 <code>dev.server.com</code> 发起请求一定会出现跨域。</p><p>现在我们只需要启动一个 <code>Nginx</code> 服务器，将 <code>server_name</code> 设置为 <code>fe.server.com</code> 然后设置相应的 <code>location</code> 以拦截前端需要跨域的请求，最后将请求代理回 <code>dev.server.com</code> 。如下面的配置：</p><pre class="line-numbers language-bash"><code class="language-bash">server <span class="token punctuation">{</span>    listen            80<span class="token punctuation">;</span>    server_name  fe.server.com<span class="token punctuation">;</span>    location / <span class="token punctuation">{</span>        proxy_pass dev.server.com<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样可以完美绕过浏览器的同源策略： <code>fe.server.com</code> 访问 <code>Nginx</code> 的 <code>fe.server.com</code> 属于同源访问，而 <code>Nginx</code> 对服务端转发的请求不会触发浏览器的同源策略。</p><h2 id="配置开启-gzip-压缩"><a href="#配置开启-gzip-压缩" class="headerlink" title="配置开启 gzip 压缩"></a>配置开启 gzip 压缩</h2><p><code>GZIP</code> 是规定的三种标准 <code>HTTP</code> 压缩格式之一。目前绝大多数的网站都在使用 <code>GZIP</code> 传输 <code>HTML</code> 、<code>CSS</code> 、 <code>JavaScript</code> 等资源文件。</p><p>对于文本文件， <code>GZiP</code> 的效果非常明显，开启后传输所需流量大约会降至 <code>1/4~1/3</code> 。</p><p>并不是每个浏览器都支持 <code>gzip</code> 的，如何知道客户端是否支持 <code>gzip</code> 呢，请求头中的 <code>Accept-Encoding</code> 来标识对压缩的支持。<br>![image.png](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)<br>启用 <code>gzip</code> 同时需要客户端和服务端的支持，如果客户端支持 <code>gzip</code> 的解析，那么只要服务端能够返回 <code>gzip</code> 的文件就可以启用 <code>gzip</code> 了,我们可以通过 <code>Nginx</code> 的配置来让服务端支持 <code>gzip</code> 。下面的 <code>respone</code> 中 <code>content-encoding:gzip</code> ，指服务端开启了 <code>gzip</code> 的压缩方式。<br><img src="/2021/03/26/nginx-ti-xi-hua-quan-mian-ren-shi/d6c44208107243bab7cf0b15c89a6722~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"><br>在 <code>/etc/nginx/conf.d/</code> 文件夹中新建配置文件 <code>gzip.conf</code> ：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># # 默认off，是否开启gzip</span><span class="token function">gzip</span> on<span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用；</span>gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># ---- 以上两个参数开启就可以支持Gzip压缩了 ---- #</span><span class="token comment" spellcheck="true"># 默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容；</span>gzip_static on<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩；</span>gzip_proxied any<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩；</span>gzip_vary on<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6；</span>gzip_comp_level 6<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得；</span>gzip_buffers 16 8k<span class="token punctuation">;</span><span class="token comment" spellcheck="true"># 允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大；</span><span class="token comment" spellcheck="true"># gzip_min_length 1k;</span><span class="token comment" spellcheck="true"># 默认 1.1，启用 gzip 所需的 HTTP 最低版本；</span>gzip_http_version 1.1<span class="token punctuation">;</span>复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实也可以通过前端构建工具例如 <code>webpack</code> 、<code>rollup</code> 等在打生产包时就做好 <code>Gzip</code> 压缩，然后放到 <code>Nginx</code> 服务器中，这样可以减少服务器的开销，加快访问速度。</p><p>关于 <code>Nginx</code> 的实际应用就学习到这里，相信通过掌握了 <code>Nginx</code> 核心配置以及实战配置，之后再遇到什么需求，我们也能轻松应对。接下来，让我们再深入一点学习下 <code>Nginx</code> 的架构。</p><h1 id="Nginx-架构"><a href="#Nginx-架构" class="headerlink" title="Nginx 架构"></a>Nginx 架构</h1><h2 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h2><p>多进程结构 <code>Nginx</code> 的进程模型图：</p><p>![未命名文件.png](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>多进程中的 <code>Nginx</code> 进程架构如下图所示，会有一个父进程（ <code>Master Process</code> ），它会有很多子进程（ <code>Child Processes</code> ）。</p><ul><li><pre><code>Master Process</code></pre><p> 用来管理子进程的，其本身并不真正处理用户请求。</p><ul><li>某个子进程 <code>down</code> 掉的话，它会向 <code>Master</code> 进程发送一条消息，表明自己不可用了，此时 <code>Master</code> 进程会去新起一个子进程。</li><li>某个配置文件被修改了 <code>Master</code> 进程会去通知 <code>work</code> 进程获取新的配置信息，这也就是我们所说的热部署。</li></ul></li><li><p>子进程间是通过共享内存的方式进行通信的。</p></li></ul><h2 id="配置文件重载原理"><a href="#配置文件重载原理" class="headerlink" title="配置文件重载原理"></a>配置文件重载原理</h2><p><code>reload</code> 重载配置文件的流程：</p><ol><li>向 <code>master</code> 进程发送 <code>HUP</code> 信号（ <code>reload</code> 命令）；</li><li><code>master</code> 进程检查配置语法是否正确；</li><li><code>master</code> 进程打开监听端口；</li><li><code>master</code> 进程使用新的配置文件启动新的 <code>worker</code> 子进程；</li><li><code>master</code> 进程向老的 <code>worker</code> 子进程发送 <code>QUIT</code> 信号；</li><li>老的 <code>worker</code> 进程关闭监听句柄，处理完当前连接后关闭进程；</li><li>整个过程 <code>Nginx</code> 始终处于平稳运行中，实现了平滑升级，用户无感知；</li></ol><h2 id="Nginx-模块化管理机制"><a href="#Nginx-模块化管理机制" class="headerlink" title="Nginx 模块化管理机制"></a>Nginx 模块化管理机制</h2><p><code>Nginx</code> 的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。<code>Nginx</code> 的模块是互相独立的,低耦合高内聚。<br><img src="/2021/03/26/nginx-ti-xi-hua-quan-mian-ren-shi/7c0d0801228d409b8fc202df83a2233d~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相信通过本文的学习，你应该会对 <code>Nginx</code> 有一个更加全面的认识。</p><p>都看到这里了，就点个👍 👍 👍 吧。</p><p>作者：Lion<br>链接：<a href="https://juejin.cn/post/6942607113118023710">https://juejin.cn/post/6942607113118023710</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>install vsftp</title>
      <link href="2021/03/18/install-vsftp/"/>
      <url>2021/03/18/install-vsftp/</url>
      
        <content type="html"><![CDATA[<h2 id="1、检查安装vsftpd软件"><a href="#1、检查安装vsftpd软件" class="headerlink" title="1、检查安装vsftpd软件"></a>1、检查安装vsftpd软件</h2><p>rpm -qa |grep vsftpd</p><p>如果安装过会出现vsftpd的版本信息，没有则不会显示（如下图）</p><p><img src="/2021/03/18/install-vsftp/bc6a80e3b1fc47f1b38ac84c157c0b1b" alt="你还记得她吗-FTP"></p><p>图1未安装</p><p><img src="/2021/03/18/install-vsftp/60bd57e4427d4ea1b72de5142e50cd73" alt="你还记得她吗-FTP"></p><p>图2 已安装</p><h2 id="2、进行安装"><a href="#2、进行安装" class="headerlink" title="2、进行安装"></a>2、进行安装</h2><p>如果没有安装，使用YUM命令安装</p><p>yum install vsftpd -y</p><p><img src="/2021/03/18/install-vsftp/cb1a9828b9db4d9d9703deebb7fa0b8d" alt="你还记得她吗-FTP"></p><p>图3 安装完成</p><p>等运行完成ftp在你的服务器上就安装完成了，就可以开始你的操作了。其默认的安装目录在/etc/vsftpd，会生产ftp的基本文件</p><p><img src="/2021/03/18/install-vsftp/f7058ce274274c54865edcefd42f2e77" alt="你还记得她吗-FTP"></p><p>图4 默认文件</p><h2 id="3、启动服务"><a href="#3、启动服务" class="headerlink" title="3、启动服务"></a>3、启动服务</h2><p>使用vsftpd软件，主要包括如下几个命令：</p><p>查看状态 systemctl status vsftpd</p><p>启动ftp命令 systemctl start vsftpd</p><p>停止ftp命令 systemctl stop vsftpd</p><p>重启ftp命令 systemctl restart vsftpd</p><p>linux低版本试一下这些命令：</p><p>启动ftp命令　　service vsftpd start</p><p>停止ftp命令　　service vsftpd stop</p><p>重启ftp命令　　service vsftpd restart</p><p>启动完成后你就可以在本地进行测试了</p><h2 id="4、安装本地测试工具ftp客户端组件"><a href="#4、安装本地测试工具ftp客户端组件" class="headerlink" title="4、安装本地测试工具ftp客户端组件"></a>4、安装本地测试工具ftp客户端组件</h2><p>yum -y install ftp</p><p>安装完成后就可以输入ftp localhost 进行连接,连接成功后会让你输入用户名和密码，在centos7下的ftp是允许匿名登录的用户名是 ftp 密码 随意输入即可。</p><p>在centos8下下载完的ftp是不允许匿名登录的，如果想本地测试就需要修改配置文件了。</p><p><img src="/2021/03/18/install-vsftp/fc4d39a285ba400493da68c1e080c438" alt="你还记得她吗-FTP"></p><p>图5 ftp客户端登陆</p><p>登陆完成后就可以在本地操作了。</p><h2 id="5、配置外网访问"><a href="#5、配置外网访问" class="headerlink" title="5、配置外网访问"></a>5、配置外网访问</h2><p>开启防火墙，配置端口，ftp默认的端口是21</p><p>systemctl start firewalld.service 开启防火墙</p><p>firewall-cmd –permanent –zone=public –add-port=21/tcp</p><p>firewall-cmd –permanent –zone=public –add-port=10000-10088/tcp</p><p>10000-10088 为ftp上传时需要的端口，该端口需要在配置文件中配置。</p><h2 id="6、创建存放文件的目录文件"><a href="#6、创建存放文件的目录文件" class="headerlink" title="6、创建存放文件的目录文件"></a>6、创建存放文件的目录文件</h2><p>mkdir -p /data/ftp/test</p><h2 id="7、创建用户和用户组"><a href="#7、创建用户和用户组" class="headerlink" title="7、创建用户和用户组"></a>7、创建用户和用户组</h2><p>useradd ftptest</p><p>echo “12345678” |passwd –stdin ftptest</p><p>groupadd ftptest</p><p>将文件目录授权</p><p>chown ftptest:ftptest /data/ftp/test -R</p><h2 id="8、修改配置文件-vsftpd-conf"><a href="#8、修改配置文件-vsftpd-conf" class="headerlink" title="8、修改配置文件(vsftpd.conf)"></a>8、修改配置文件(vsftpd.conf)</h2><p>anonymous_enable=NO 禁止匿名登陆</p><p>listen=YES 监听ip4</p><p>listen_ipv6=NO 不监听ip6</p><p>pam_service_name=vsftpd</p><p>userlist_enable=YES</p><p>tcp_wrappers=YES</p><p>write_enable=YES 是否可写</p><p>allow_writeable_chroot=YES</p><p>pasv_enable=YES 开始被动模式</p><p>#设置被动模式下，建立数据传输可使用port范围的最小值</p><p>pasv_min_port=10000</p><p>#设置被动模式下，建立数据传输可使用port范围的最大值</p><p>pasv_max_port=10088</p><p>以上为我个人修改配置文件的一些参数，修改完以后保存退出，重启vsftp服务</p><h2 id="9、修改系统配置"><a href="#9、修改系统配置" class="headerlink" title="9、修改系统配置"></a>9、修改系统配置</h2><p>如果此时外网还是没法访问的话需修改系统配置</p><p>vi /etc/selinux/config</p><p>SELINUX=enforcing 设置成SELINUX=disabled</p><p>需要重启服务器，再次使用外网连接就可实现数据的上传和下载了</p><h2 id="10、设置开机自启"><a href="#10、设置开机自启" class="headerlink" title="10、设置开机自启"></a>10、设置开机自启</h2><p>chkconfig vsftpd on</p><p><img src="/2021/03/18/install-vsftp/74d3ca52788f4e1cbf8ef2da5ed2afdc" alt="你还记得她吗-FTP"></p>]]></content>
      
      
      <categories>
          
          <category> vsftp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vsftp - linux - install </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeReview规范</title>
      <link href="2021/03/18/codereview-gui-fan/"/>
      <url>2021/03/18/codereview-gui-fan/</url>
      
        <content type="html"><![CDATA[<h1 id="CodeReview规范"><a href="#CodeReview规范" class="headerlink" title="CodeReview规范"></a>CodeReview规范</h1><p><img src="/2021/03/18/codereview-gui-fan/6a659100ed1b41e3a4e89d688e580314" alt="CodeReview规范"></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="目标和原则"><a href="#目标和原则" class="headerlink" title="目标和原则"></a>目标和原则</h1><ul><li>提高代码质量，及早发现潜在缺陷，降低修改/弥补缺陷的成本</li><li>促进团队内部知识共享，提高团队整体水平</li><li>评审过程对于评审人员来说，也是一种思路重构的过程，帮助更多的人理解系统</li><li>是一个传递知识的手段，可以让其它并不熟悉代码的人知道作者的意图和想法，从而可以在以后轻松维护代码</li><li>可以被用来确认自己的设计和实现是一个清楚和简单的</li><li>鼓励相互学习对方的长处和优点</li><li>高效迅速完成Code Review</li></ul><h1 id="流程和规则"><a href="#流程和规则" class="headerlink" title="流程和规则"></a>流程和规则</h1><p>采用Git Flow + Pull Request（PR）模式来做Code Review。</p><h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><p><img src="/2021/03/18/codereview-gui-fan/911dcdc05ca3470a8774fbf605414705" alt="CodeReview规范"></p><h2 id="Pull-Request（PR）"><a href="#Pull-Request（PR）" class="headerlink" title="Pull Request（PR）"></a>Pull Request（PR）</h2><p><img src="/2021/03/18/codereview-gui-fan/20fd4f0535f64fc1ac60136bcb6d03a4" alt="CodeReview规范"></p><p><img src="/2021/03/18/codereview-gui-fan/9c3fff2c6f524ba7b827348fa38f979f" alt="CodeReview规范"></p><p><strong>Pull Request 的说明</strong></p><ul><li>任务完成才能提交PR</li><li>严禁一个PR里面有多个任务，除非它们是紧密关联的</li><li>PR提交之后只允许针对Review发现问题再次提交代码，除非有充足的理由，严禁在同一个PR中再次提交其它任务的代码</li><li>提交PR时候有一个描述框，内容会自动根据Commit的message合并而成。切记，如果一次提交的内容包含很多Commit，请不要使用自动生成的描述。请用简短但是足够说明问题的语言（理想是控制在3句话之内）来描述： 你改动了什么，解决了什么问题，需要代码审查的人留意那些影响比较大的改动。特别需要留意，如果对基础、公共的组件进行了改动，一定要另起一行特别说明。</li><li>PR应该在1~2个工作日内被合并或者被拒绝</li><li><strong>发起Pull Request以后，请将Pull Request的链接通过Email发给代码审核者，以此通知对方及时进行审核。(BUG修复类当日必须完成合并或者拒绝，功能类或者觉得有重大调整需要会议Review必须在邮件中明确时间和会议人员)</strong></li></ul><h1 id="Code-Review-Checklist"><a href="#Code-Review-Checklist" class="headerlink" title="Code Review Checklist"></a><strong>Code Review Checklist</strong></h1><p>Code Review主要检查代码中是否存在以下方面问题：代码的一致性、编码风格、代码的安全问题、代码冗余、是否正确设计以满足需求（功能、性能）等等</p><ul><li><strong>完整性检查</strong>代码是否完全实现了设计文档中提出的功能需求代码是否已按照设计文档进行了集成和Debug代码是否已创建了需要的数据库，包括正确的初始化数据代码中是否存在任何没有定义或没有引用到的变量、常数或数据类型</li><li><strong>一致性检查</strong>代码的逻辑是否符合设计文档代码中使用的格式、符号、结构等风格是否保持一致</li><li><strong>正确性检查</strong>代码是否符合制定的标准所有的变量都被正确定义和使用所有的注释都是准确的所有的程序调用都使用了正确的参数个数</li><li><strong>可修改性检查</strong>代码涉及到的常量是否易于修改(如使用配置、定义为类常量、使用专门的常量类等)代码中是否包含了交叉说明或数据字典，以描述程序是如何对变量和常量进行访问的代码是否只有一个出口和一个入口（严重的异常处理除外）</li><li><strong>可预测性检查</strong>代码所用的开发语言是否具有定义良好的语法和语义是否代码避免了依赖于开发语言缺省提供的功能代码是否无意中陷入了死循环代码是否是否避免了无穷递归</li><li><strong>健壮性检查</strong>异常处理和清理（释放）资源代码是否采取措施避免运行时错误（如数组边界溢出、被零除、值越界、堆栈溢出等）</li><li><strong>结构性检查</strong>程序的每个功能是否都作为一个可辩识的代码块存在循环是否只有一个入口</li><li><strong>可追溯性检查</strong>代码是否对每个程序进行了唯一标识是否有一个交叉引用的框架可以用来在代码和开发文档之间相互对应代码是否包括一个修订历史记录，记录中对代码的修改和原因都有记录是否所有的安全功能都有标识</li><li><strong>可理解性检查</strong>注释是否足够清晰的描述每个子程序是否使用到不明确或不必要的复杂代码，它们是否被清楚的注释使用一些统一的格式化技巧（如缩进、空白等）用来增强代码的清晰度是否在定义命名规则时采用了便于记忆，反映类型等方法每个变量都定义了合法的取值范围代码中的算法是否符合开发文档中描述的数学模型</li><li><strong>可验证性检查</strong>代码中的实现技术是否便于测试</li><li><strong>可重用性</strong>DRY（Do not Repeat Yourself）原则：同一代码不应该重复两次以上考虑可重用的服务，功能和组件考虑通用函数和类</li><li><strong>可扩展性</strong>轻松添加功能，对现有代码进行最小的更改。一个组件可以被更好的组件替换</li><li><strong>安全性</strong>进行身份验证，授权，输入数据验证，避免诸如SQL注入和跨站脚本（XSS）等安全威胁 ，加密敏感数据（密码，信用卡信息等）</li><li><strong>性能</strong>使用合适的数据类型，例如StringBuilder，通用集合类懒加载，异步和并行处理缓存和会话/应用程序数据</li></ul><p><strong>代码检查包括不局限于上述清单，提交人应在本地自我完成代码格式、架构设计、面向对象分析与设计等检查。</strong>备注：</p><ul><li><strong>Java服务端开发必须遵循</strong>阿里巴巴Java开发手册（终极版）**,IDEA中安装相关插件有告警提示不允许提交合并**</li></ul><h1 id="Code-Review的步骤"><a href="#Code-Review的步骤" class="headerlink" title="Code Review的步骤"></a>Code Review的步骤</h1><ol><li>代码编写者和代码审核者坐在一起，由代码编写者按照UC依次讲解自己负责的代码和相关逻辑，从Web层-&gt;DAO层；</li><li>代码审核者在此过程中可以随时提出自己的疑问，同时积极发现隐藏的bug；对这些bug记录在案。</li><li>代码讲解完毕后，代码审核者给自己安排几个小时再对代码审核一遍。代码需要一行一行静下心看。同时代码又要全面的看，以确保代码整体上设计优良。</li><li>代码审核者根据审核的结果编写“代码审核报告”，“审核报告”中记录发现的问题及修改建议，然后把“审核报告”发送给相关人员。</li><li>代码编写者根据“代码审核报告”给出的修改意见，修改好代码，有不清楚的地方可积极向代码审核者提出。</li><li>代码编写者 bug fix完毕之后给出反馈。</li><li>代码审核者把Code Review中发现的有价值的问题更新到”代码审核规范”的文档中，对于特别值得提醒的问题可群发email给所有技术人员。</li></ol><p>备注：Code Review必备的文档：“Code Review规范”文档：记录代码应该遵循的标准。代码审核者根据这些标准来Code Review代码，同时在Code Review过程中不断完善该文档。</p><h1 id="Code-Review的执行"><a href="#Code-Review的执行" class="headerlink" title="Code Review的执行"></a>Code Review的执行</h1><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><ol><li>评审规范和标准</li><li>在CR前设计确定评审规范和标准是必要，通过规范和标准我们在审查过程中可以有据可依，有理可循，而且还可以做到标准统一。</li><li>选择CR活动的参与者</li><li>在CR开始前，必须把本次CR活动的对象、审查内容以及审查的规范和标准通过email通报给所有的参与者。</li><li>选择CR活动的实施方式</li><li>CR活动有很多形式可供我们选择，我们可以根据实际情况选择桌面式CR、演示讲解式CR、一对一的座位CR等等。(<strong>一般按新增功能桌面式CR、里程碑功能演示讲解式CR、BUG修复一对一的座位CR</strong>)</li></ol><h2 id="实施阶段"><a href="#实施阶段" class="headerlink" title="实施阶段"></a>实施阶段</h2><p>充分的事前准备，只是做好CR活动的前提，在CR实施过程中，我们要做好以下工作。</p><ol><li>准确记录</li><li>对于CR过程发现的问题，我们必须清晰准确的记录，可以使用问题点记录单，明确记录的项目和内容。</li><li>讲解与提问</li><li>CR过程中，要采用代码作者讲解和审查者提问方式。审查者不能只在发现问题时提问，同时也要根据本次审查的内容要求代码作者对某个特定问题的讲解。</li><li>逐项审查</li><li>对事前确定的审查内容，要逐项审查，不能因为时间不足等因素一扫而过。</li><li>注意气氛</li><li>实施审查时，要营造一个讨论问题、解决问题的氛围，不能把审查会搞成批判会，这样会影响相关人员的积极性。</li></ol><h2 id="事后跟踪"><a href="#事后跟踪" class="headerlink" title="事后跟踪"></a>事后跟踪</h2><ol><li>确认发现的问题 CR结束后，对发现的问题，首先需要确定以下内容。</li><li>问题点的难易程度以及影响的范围；</li><li>解决问题的责任者和问题点修正结果的确认者；</li><li>解决问题点的时限。</li><li>修正问题责任者 对于修正问题责任者，在问题点的修正过程中，要三方面内容的记录。问题点的原因；</li><li>解决问题点的对策；</li><li>修正的内容。</li></ol><p>修正结果确认者做为修正结果的确认者，必须按照事前约定的时限及时的对修正结果进行全面的确认</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li><strong>经常进行Code Review</strong></li></ul><p>（1）要Review的代码越多，那么要重构，重写的代码就会越多。而越不被程序作者接受的建议也会越多，唾沫口水战也会越多。（2）程序员代码写得时候越长，程序员就会在代码中加入越来越多的个人的东西。 （3）越接近软件发布的最终期限，代码也就不能改得太多。</p><ul><li><strong>Code Review不要太正式，而且要短</strong></li></ul><p>忘了那个代码评审的Checklist吧，走到你的同事座位跟前，像请师父一样请他坐到你的电脑面前，然后，花5分钟给他讲讲你的代码，给他另外一个5分钟让他给你的代码提提意见，这比什么都好。而如果你用了一个Checklist，让这个事情表现得很正式的话，下面两件事中必有一件事会发生：（1）只有在Checklist上存在的东西才会被Review。（2）Code Reviews 变成了一种礼节性的东西，你的同事会装做很关心你的代码，但其实他心里想着尽快地离开你。只有不正式的Code Review才会让你和评审者放轻松，人只有放松了，才会表现得很真实，很真诚。记住Review只不过是一种形式，而只有在相互信任中通过相互的讨论得到了有意义和有建设性的建议和意见，那才是最实在的。不然，作者和评审者的关系就会变成小偷和警察的关系。</p><ul><li><strong>尽可能的让不同的人Review你的代码</strong></li></ul><p>如果可能的话，不要总是只找一个人来Review你的代码，不同的人有不同的思考方式，有不同的见解，所以，不同的人可以全面的从各个方面评论你的代码。但不要太多了，人多嘴杂反而适得其反，基本上来说，不要超过3个人，这是因为，这是一个可以围在一起讨论的最大人员尺寸。 下面是几个优点：（1）从不同的方向评审代码总是好的。（2）会有更多的人帮你在日后维护你的代码。（3）这也是一个增加团队凝聚力的方法。</p><ul><li><strong>保持积极的正面的态度</strong></li></ul><p>程序员最大的问题就是“自负”，尤其当我们Review别人的代码的时候，我已经见过无数的场面，程序员在Code Review的时候，开始抨击别人的代码，质疑别人的能力。太可笑了，我分析了一下，这类的程序员其实并没有什么本事，因为他们指责对方的目的是想告诉大家自己有多么的牛，靠这种手段来表现自己的程序员，其实是就是传说中所说的“半瓶水”。 所以，无论是代码作者，还是评审者，都需要一种积极向上的正面的态度，作者需要能够虚心接受别人的建议，因为别人的建议是为了让你做得更好；评审者也需要以一种积极的正面的态度向作者提意见，因为那是和你在一个战壕里的战友。记住，你不是一段代码，你是一个人！</p><ul><li><strong>学会享受Code Review</strong></li></ul><p>这可能是最重要的一个提示了，如果你到了一个人人都喜欢Code Review的团阿，那么，你会进入到一个生机勃勃的地方，在那里，每个人都能写出质量非常好的代码，在那里，你不需要经理的管理，团队会自适应一切变化，他们相互学习，相互帮助，不仅仅是写出好的代码，而且团队和其中的每个人都会自动进化，最关键的是，这个是一个团队。</p>]]></content>
      
      
      <categories>
          
          <category> CodeReview </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring flashMap</title>
      <link href="2021/03/17/spring-flashmap/"/>
      <url>2021/03/17/spring-flashmap/</url>
      
        <content type="html"><![CDATA[<p>今天来聊一个 JavaWeb 中简单的话题，但是感觉却比较稀罕，因为这个技能点，有的小伙伴们可能没听过！</p><h1 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1.缘起"></a><strong>1.缘起</strong></h1><p>说到 Web 请求参数传递，大家能想到哪些参数传递方式？</p><p>参数可以放在地址栏中，不过地址栏参数的长度有限制，并且在有的场景下我们可能不希望参数暴漏在地址栏中。参数可以放在请求体中，这个没啥好说的。</p><p>小伙伴们试想这样一个场景：</p><p>在一个电商项目中，有一个提交订单的请求，这个请求是一个 POST 请求，请求参数都在请求体中。当用户提交成功后，为了防止用户刷新浏览器页面造成订单请求重复提交，我们一般会将用户重定向到一个显示订单的页面，这样即使用户刷新页面，也不会造成订单请求重复提交。</p><p>大概的代码就像下面这样：</p><pre><code>@Controllerpublic class OrderController {    @PostMapping("/order")    public String order(OrderInfo orderInfo) {        //其他处理逻辑        return "redirect:/orderlist";    }}</code></pre><p>这段代码我相信大家都懂吧！如果不懂可以看看松哥录制的免费的 SpringMVC 入门教程（硬核！松哥又整了一套免费视频，搞起！）。</p><p>但是这里有一个问题：如果我想传递参数怎么办？</p><p>如果是服务器端跳转，我们可以将参数放在 request 对象中，跳转完成后还能拿到参数，但是如果是客户端跳转我们就只能将参数放在地址栏中了，像上面这个方法的返回值我们可以写成：return “redirect:/orderlist?xxx=xxx”;，这种传参方式有两个缺陷：</p><ul><li>地址栏的长度是有限的，也就意味着能够放在地址栏中的参数是有限的。</li><li>不想将一些特殊的参数放在地址栏中。</li></ul><p>那该怎么办？还有办法传递参数吗？</p><p>有！这就是今天松哥要和大家介绍的 flashMap，专门用来解决重定向时参数的传递问题。</p><h1 id="2-flashMap"><a href="#2-flashMap" class="headerlink" title="2.flashMap"></a><strong>2.flashMap</strong></h1><p>在重定向时，如果需要传递参数，但是又不想放在地址栏中，我们就可以通过 flashMap 来传递参数，松哥先来一个简单的例子大家看看效果：</p><p>首先我们定义一个简单的页面，里边就一个 post 请求提交按钮，如下：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="/order" method="post"&gt;    &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>然后在服务端接收该请求，并完成重定向：</p><pre><code>@Controllerpublic class OrderController {    @PostMapping("/order")    public String order(HttpServletRequest req) {        FlashMap flashMap = (FlashMap) req.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE);        flashMap.put("name", "江南一点雨");        return "redirect:/orderlist";    }    @GetMapping("/orderlist")    @ResponseBody    public String orderList(Model model) {        return (String) model.getAttribute("name");    }}</code></pre><p>首先在 order 接口中，获取到 flashMap 属性，然后存入需要传递的参数，这些参数最终会被 SpringMVC 自动放入重定向接口的 Model 中，这样我们在 orderlist 接口中，就可以获取到该属性了。</p><p>当然，这是一个比较粗糙的写法，我们还可以通过 RedirectAttributes 来简化这一步骤：</p><pre><code>@Controllerpublic class OrderController {    @PostMapping("/order")    public String order(RedirectAttributes attr) {        attr.addFlashAttribute("site", "www.javaboy.org");        attr.addAttribute("name", "微信公众号：江南一点雨");        return "redirect:/orderlist";    }    @GetMapping("/orderlist")    @ResponseBody    public String orderList(Model model) {        return (String) model.getAttribute("site");    }}</code></pre><p>RedirectAttributes 中有两种添加参数的方式：</p><ul><li>addFlashAttribute：将参数放到 flashMap 中。</li><li>addAttribute：将参数放到 URL 地址中。</li></ul><p>经过前面的讲解，现在小伙伴们应该大致明白了 flashMap 的作用了，就是在你进行重定向的时候，不通过地址栏传递参数。</p><p>很多小伙伴可能会有疑问，重定向其实就是浏览器发起了一个新的请求，这新的请求怎么就获取到上一个请求保存的参数呢？这我们就要来看看 SpringMVC 的源码了。</p><h1 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a><strong>3.源码分析</strong></h1><p>首先这里涉及到一个关键类叫做 FlashMapManager，如下：</p><pre><code>public interface FlashMapManager { @Nullable FlashMap retrieveAndUpdate(HttpServletRequest request, HttpServletResponse response); void saveOutputFlashMap(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response);}</code></pre><p>两个方法含义一眼就能看出来：</p><ul><li>retrieveAndUpdate：这个方法用来恢复参数，并将恢复过的的参数和超时的参数从保存介质中删除。</li><li>saveOutputFlashMap：将参数保存保存起来。</li></ul><p>FlashMapManager 的实现类如下：</p><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/a00409add5494ca19696bfcd7f24de5b?from=pc" alt="SpringMVC 中的参数还能这么传递？涨姿势了"></p><p>从这个继承类中，我们基本上就能确定默认的保存介质时 session。具体的保存逻辑则是在 AbstractFlashMapManager 类中。</p><p>整个参数传递的过程可以分为三大步：</p><p>第一步，首先我们将参数设置到 outputFlashMap 中，有两种设置方式：我们前面的代码 req.getAttribute(<br>DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE) 就是直接获取 outputFlashMap 对象然后把参数放进去；第二种方式就是通过在接口中添加 RedirectAttributes 参数，然后把需要传递的参数放入 RedirectAttributes 中，这样当处理器处理完毕后，会自动将其设置到 outputFlashMap 中，具体逻辑在<br>RequestMappingHandlerAdapter#getModelAndView 方法中：</p><pre><code>private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,  ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception { //省略... if (model instanceof RedirectAttributes) {  Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();  HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);  if (request != null) {   RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);  } } return mav;}</code></pre><p>可以看到，如果 model 是 RedirectAttributes 的实例的话，则通过 getOutputFlashMap 方法获取到 outputFlashMap 属性，然后相关的属性设置进去。</p><p>这是第一步，就是将需要传递的参数，先保存到 flashMap 中。</p><p>第二步，重定向对应的视图是 RedirectView，在它的 renderMergedOutputModel 方法中，会调用 FlashMapManager 的 saveOutputFlashMap 方法，将 outputFlashMap 保存到 session 中，如下：</p><pre><code>protected void renderMergedOutputModel(Map&lt;String, Object&gt; model, HttpServletRequest request,  HttpServletResponse response) throws IOException { String targetUrl = createTargetUrl(model, request); targetUrl = updateTargetUrl(targetUrl, model, request, response); // Save flash attributes RequestContextUtils.saveOutputFlashMap(targetUrl, request, response); // Redirect sendRedirect(request, response, targetUrl, this.http10Compatible);}</code></pre><p>RequestContextUtils.saveOutputFlashMap 方法最终就会调用到 FlashMapManager 的 saveOutputFlashMap 方法，将 outputFlashMap 保存下来。我们来大概看一下保存逻辑：</p><pre><code>public final void saveOutputFlashMap(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response) { if (CollectionUtils.isEmpty(flashMap)) {  return; } String path = decodeAndNormalizePath(flashMap.getTargetRequestPath(), request); flashMap.setTargetRequestPath(path); flashMap.startExpirationPeriod(getFlashMapTimeout()); Object mutex = getFlashMapsMutex(request); if (mutex != null) {  synchronized (mutex) {   List&lt;FlashMap&gt; allFlashMaps = retrieveFlashMaps(request);   allFlashMaps = (allFlashMaps != null ? allFlashMaps : new CopyOnWriteArrayList&lt;&gt;());   allFlashMaps.add(flashMap);   updateFlashMaps(allFlashMaps, request, response);  } } else {  List&lt;FlashMap&gt; allFlashMaps = retrieveFlashMaps(request);  allFlashMaps = (allFlashMaps != null ? allFlashMaps : new ArrayList&lt;&gt;(1));  allFlashMaps.add(flashMap);  updateFlashMaps(allFlashMaps, request, response); }}</code></pre><p>其实这里的逻辑也很简单，保存之前会给 flashMap 设置两个属性，一个是重定向的 url 地址，另一个则是过期时间，过期时间默认 180 秒，这两个属性在第三步加载 flashMap 的时候会用到。然后将 flashMap 放入集合中，并调用 updateFlashMaps 方法存入 session 中。</p><p>第三步，当重定向请求到达 DispatcherServlet#doService 方法后，此时会调用 FlashMapManager#retrieveAndUpdate 方法从 Session 中获取 outputFlashMap 并设置到 Request 属性中备用（最终会被转化到 Model 中的属性），相关代码如下：</p><pre><code>protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception { //省略... if (this.flashMapManager != null) {  FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);  if (inputFlashMap != null) {   request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));  }  request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());  request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); } //省略...}</code></pre><p>注意这里获取出来的 outputFlashMap 换了一个名字，变成了 inputFlashMap，其实是同一个东西。</p><p>我们可以大概看一下获取的逻辑 AbstractFlashMapManager#retrieveAndUpdate：</p><pre><code>public final FlashMap retrieveAndUpdate(HttpServletRequest request, HttpServletResponse response) { List&lt;FlashMap&gt; allFlashMaps = retrieveFlashMaps(request); if (CollectionUtils.isEmpty(allFlashMaps)) {  return null; } List&lt;FlashMap&gt; mapsToRemove = getExpiredFlashMaps(allFlashMaps); FlashMap match = getMatchingFlashMap(allFlashMaps, request); if (match != null) {  mapsToRemove.add(match); } if (!mapsToRemove.isEmpty()) {  Object mutex = getFlashMapsMutex(request);  if (mutex != null) {   synchronized (mutex) {    allFlashMaps = retrieveFlashMaps(request);    if (allFlashMaps != null) {     allFlashMaps.removeAll(mapsToRemove);     updateFlashMaps(allFlashMaps, request, response);    }   }  }  else {   allFlashMaps.removeAll(mapsToRemove);   updateFlashMaps(allFlashMaps, request, response);  } } return match;}</code></pre><ul><li>首先调用 retrieveFlashMaps 方法从 session 中获取到所有的 FlashMap。</li><li>调用 getExpiredFlashMaps 方法获取所有过期的 FlashMap，FlashMap 默认的过期时间是 180s。</li><li>获取和当前请求匹配的 getMatchingFlashMap，具体的匹配逻辑就两点：重定向地址要和当前请求地址相同；预设参数要相同。一般来说我们不需要配置预设参数，所以这一条可以忽略。如果想要设置，则首先给 flashMap 设置，像这样：flashMap.addTargetRequestParam(“aa”, “bb”);，然后在重定向的地址栏也加上这个参数：return “redirect:/orderlist?aa=bb”; 即可。</li><li>将获取到的匹配的 FlashMap 对象放入 mapsToRemove 集合中（这个匹配到的 FlashMap 即将失效，放入集合中一会被清空）。</li><li>将 allFlashMaps 集合中的所有 mapsToRemove 数据清空，同时调用 updateFlashMaps 方法更新 session 中的 FlashMap。</li><li>最终将匹配到的 flashMap 返回。</li></ul><p>这就是整个获取 flashMap 的方法，整体来看还是非常 easy 的，并没有什么难点。</p><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a><strong>4.小结</strong></h1><p>好啦，今天就和小伙伴们分享了一下 SpringMVC 中的 flashMap，不知道大家有没有在工作中用到这个东西？如果刚好碰到松哥前面所说的需求，用 FlashMap 真的还是蛮方便的</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git commit template</title>
      <link href="2021/03/17/git-commit-template/"/>
      <url>2021/03/17/git-commit-template/</url>
      
        <content type="html"><![CDATA[<p>程序员应该写出简洁明了的commit log，否则对别人和自己来说就是一种困扰。最近代码review多了，总有一股想笑的感觉。就像下图这满屏的ok，永远无法从中得知提交人的意图。</p><p><img src="https://p1-tt.byteimg.com/origin/pgc-image/9d9e670b93bc456a8e4e855354b1641c?from=pc" alt="80%的程序员，不会写commit记录"></p><p>commit log将如何提交？都有哪些约定？其实是有答案的。对于Java程序员，尤其幸福。IDEA有一个非常好用的插件，可以用来辅助你进行代码提交，辅助你进行团队规范建设。接下来，我将带大家看一看它的使用方法。</p><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p>在IDEA的Marketplace中，搜索Git Commit Template，就可以安装这个插件。插件很小，很快就能下载下来。</p><p><img src="https://p1-tt.byteimg.com/origin/pgc-image/e40238128a3b4f909fcc243ec65d969e?from=pc" alt="80%的程序员，不会写commit记录"></p><p>正常从IDEA提交代码的时候。我们发现多了一个小按钮。</p><p><img src="https://p1-tt.byteimg.com/origin/pgc-image/dde610d69f834dd6b91aaac2d568f346?from=pc" alt="80%的程序员，不会写commit记录"></p><p>点击之后，将弹出一个窗口。让你去设计提交模板。</p><p><img src="https://p3-tt.byteimg.com/origin/pgc-image/18df0ba36a3e422ebc752dbcbc4e7cc0?from=pc" alt="80%的程序员，不会写commit记录"></p><p>这么多信息，真的让人头晕。怪不得程序员们都不喜欢写提交记录。</p><p>其实，在插件的安装界面，就已经说明了这个提交记录的格式。</p><pre><code> &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; &lt;BLANK LINE&gt; &lt;body&gt; &lt;BLANK LINE&gt; &lt;footer&gt;</code></pre><p>从描述中，可以肯容易的看到一个提交记录中，应该包含哪些东西。其中类型最多的，当然是提交类型。</p><h1 id="提交类型Type"><a href="#提交类型Type" class="headerlink" title="提交类型Type"></a>提交类型Type</h1><p>我们按照插件显示的顺序来说明一下。</p><ul><li>feat 功能feature的意思，也是最常用的。当你的功能有变更的时候，都可以采用这种类型的type</li><li>fix 当然指的是bug修复</li><li>docs 更新了文档，或者更新了注释</li><li>style 代码格式调整，比如执行了format、更改了tab显示等</li><li>refactor 重构代码。指的是代码结构的调整，比如使用了一些设计模式重新组织了代码</li><li>perf 对项目或者模块进行了性能优化。比如一些jvm的参数改动，把stringbuffer改为stringbuilder等</li><li>test 这个简单，就是增加了单元测试和自动化相关的代码</li><li>build 影响编译的一些更改，比如更改了maven插件、增加了npm的过程等</li><li>ci 持续集成方面的更改。现在有些build系统喜欢把ci功能使用yml描述。如有这种更改，建议使用ci</li><li>chore 其他改动。比如一些注释修改或者文件清理。不影响src和test代码文件的，都可以放在这里</li><li>revert 回滚了一些前面的代码</li></ul><p>除了这些预设的，团队还可以按照自己的需求，增加新的type。比如专门处理线上工单，就可以创造一个叫做ticket的类型。</p><h1 id="范围scope"><a href="#范围scope" class="headerlink" title="范围scope"></a>范围scope</h1><p>scope是范围的意思，主要指的是代码的影响面。scope并没有要求强制，但团队可以按照自己的理解进行设计。通常由技术维度和业务维度两种划分方式。比如按照技术分为：controller、dto、service、dao等。但因为一个功能提交，会涉及到多个scope（都不喜欢非常细粒度的提交），所以按照技术维度分的情况比较少。</p><p>按照业务模块进行划分，也是比较不错的选择。比如分为user、order等划分，可以很容易看出是影响用户模块还是order模块。</p><p>如果你实在不知道怎么填，那就留空。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h1 id="主题subject"><a href="#主题subject" class="headerlink" title="主题subject"></a>主题subject</h1><p>这个体现的是总结概括能力，没得跑。一句话能够说明主要的提交是什么。subject也是众多git管理工具默认显示的一行。如果你写的标准，那么提交记录看起来就很漂亮很规整。</p><h1 id="正文Body"><a href="#正文Body" class="headerlink" title="正文Body"></a>正文Body</h1><p>主要填写详细的改动记录。我一般习惯列上1234，但如果你的subject写的非常好，正文可以直接弱化。但如果时间充裕，填写上重要记录的前因后果，需求背景，是一个好的习惯。</p><h1 id="尾部Footer"><a href="#尾部Footer" class="headerlink" title="尾部Footer"></a>尾部Footer</h1><p>添加一些额外的hook，比如提交记录之后，自动关闭jira的工单（JIRA和gitlab等是可以联动的）。在比如触发一些文档编译或者其他动作。</p><p>这部分自定义行也是比较强的。</p><h1 id="Skip-CI"><a href="#Skip-CI" class="headerlink" title="Skip CI"></a>Skip CI</h1><p>最后还有一个skip CI选项。一般的ci工具，都可以设置提交代码时自动触发编译。但你可以告诉它忽略本次提交。这可能是因为你提前预判到了一些构建风险，或者就是不想编译。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>最后，看一个典型的提交记录，有了工具的支持，我们的瞎扯也看得正经起来。</p><pre><code>fix(order): 修复了1分钱买汽车的bug商务反馈可以1分钱买汽车，目前已经卖出了100w量Closes #2455[skip ci]</code></pre><p>其实，提交的核心是type和subject。一个用来表示它的提交类型，一个用来对提交进行概括性总结，写好了这两点，就能轻轻松松秒杀80%的程序员了。</p><p>有了这些基础，从commit log，自动生成change log，就变的非常的容易。配合持续集成平台，自动生成发版的变更记录，也是可行的，这也是为什么团队管理，都在一直强调git的提交规范。因为它确实非常有用。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>避免 Mysql重复插入数据</title>
      <link href="2021/03/12/bi-mian-mysql-chong-fu-cha-ru-shu-ju/"/>
      <url>2021/03/12/bi-mian-mysql-chong-fu-cha-ru-shu-ju/</url>
      
        <content type="html"><![CDATA[<p>最常见的方式就是为字段设置主键或唯一索引，当插入重复数据时，抛出错误，程序终止，但这会给后续处理带来麻烦，因此需要对插入语句做特殊处理，尽量避开或忽略异常，下面我简单介绍一下，感兴趣的朋友可以尝试一下：</p><p>这里为了方便演示，我新建了一个user测试表，主要有id，username，sex，address这4个字段，其中主键为id（自增），同时对username字段设置了唯一索引：</p><h2 id="01-insert-ignore-into"><a href="#01-insert-ignore-into" class="headerlink" title="\01 insert ignore into**"></a><strong><em>\</em>01 insert ignore into**</strong></h2><p>即插入数据时，如果数据存在，则忽略此次插入，前提条件是插入的数据字段设置了主键或唯一索引，测试SQL语句如下，当插入本条数据时，MySQL数据库会首先检索已有数据（也就是idx_username索引），如果存在，则忽略本次插入，如果不存在，则正常插入数据：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">ignore</span> <span class="token keyword">into</span> <span class="token keyword">user</span><span class="token punctuation">(</span>username，sex，address<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">"jack"</span><span class="token punctuation">,</span><span class="token string">"male"</span><span class="token punctuation">,</span><span class="token string">"new york"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eukZ9J6BEiafMZnicLgVib5Y8ia8ic8IoVzPahzSWmjjbg1QJdmCdUbzpVx59M9ZpnWB7bWatpKhfUQNooZf768edAw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="02-on-duplicate-key-update"><a href="#02-on-duplicate-key-update" class="headerlink" title="02 on duplicate key update"></a><strong>02 on duplicate key update</strong></h2><p>即插入数据时，如果数据存在，则执行更新操作，前提条件同上，也是插入的数据字段设置了主键或唯一索引，测试SQL语句如下，当插入本条记录时，MySQL数据库会首先检索已有数据（idx_username索引），如果存在，则执行update更新操作，如果不存在，则直接插入：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span><span class="token punctuation">(</span>username，sex，address<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">"jack"</span><span class="token punctuation">,</span><span class="token string">"male"</span><span class="token punctuation">,</span><span class="token string">"new york"</span><span class="token punctuation">)</span><span class="token keyword">on</span> <span class="token keyword">duplicate key</span> <span class="token keyword">update</span><span class="token keyword">set</span><span class="token operator">=</span><span class="token string">'male'</span><span class="token punctuation">,</span>address<span class="token operator">=</span><span class="token string">'noe york'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eukZ9J6BEiafMZnicLgVib5Y8ia8ic8IoVzPaYPzKQzy6CFxcOblCjBf9roZSiav2T4DiaPicxqKlmGKWhNHce2CGdOyNw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="03-replace-into"><a href="#03-replace-into" class="headerlink" title="03 replace into"></a><strong>03 replace into</strong></h2><p>即插入数据时，如果数据存在，则删除再插入，前提条件同上，插入的数据字段需要设置主键或唯一索引，测试SQL语句如下，当插入本条记录时，MySQL数据库会首先检索已有数据（idx_username索引），如果存在，则先删除旧数据，然后再插入，如果不存在，则直接插入：</p><pre class="line-numbers language-sql"><code class="language-sql">replace <span class="token keyword">into</span> <span class="token keyword">user</span><span class="token punctuation">(</span>username，sex，address<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token string">"jack"</span><span class="token punctuation">,</span><span class="token string">"male"</span><span class="token punctuation">,</span><span class="token string">"new york"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eukZ9J6BEiafMZnicLgVib5Y8ia8ic8IoVzPaj7P8HAtNwvA4KZKlucELQ3icRvgE8fjvFYJJ5WXQB7f0bZn0y5ZZ5Mg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="04-insert-if-not-exists"><a href="#04-insert-if-not-exists" class="headerlink" title="04 insert if not exists"></a><strong>04 insert if not exists</strong></h2><p>即insert into … select … where not exist … ，这种方式适合于插入的数据字段没有设置主键或唯一索引，当插入一条数据时，首先判断MySQL数据库中是否存在这条数据，如果不存在，则正常插入，如果存在，则忽略：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span><span class="token punctuation">(</span>username，sex，address<span class="token punctuation">)</span> <span class="token keyword">select</span> <span class="token string">"jack"</span><span class="token punctuation">,</span><span class="token string">"male"</span><span class="token punctuation">,</span><span class="token string">"new york"</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token keyword">where</span> <span class="token operator">not</span> <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> username <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> username<span class="token operator">=</span><span class="token string">'jack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eukZ9J6BEiafMZnicLgVib5Y8ia8ic8IoVzPaMicViaejyxysicKHtkG0pHBfw4SRW3vCTWvia6PFYN3Fk6RxgyC7ZcTm6Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">目前，就分享这4种MySQL处理重复数据的方式吧，前3种方式适合字段设置了主键或唯一索引，最后一种方式则没有此限制，只要你熟悉一下使用过程，很快就能掌握的，网上也有相关资料和教程，介绍的非常详细，感兴趣的话，可以搜一下。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot+Mybatis实现动态数据源切换</title>
      <link href="2021/03/12/springboot-mybatis-shi-xian-dong-tai-shu-ju-yuan-qie-huan/"/>
      <url>2021/03/12/springboot-mybatis-shi-xian-dong-tai-shu-ju-yuan-qie-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot-Mybatis实现动态数据源切换"><a href="#SpringBoot-Mybatis实现动态数据源切换" class="headerlink" title="SpringBoot + Mybatis实现动态数据源切换"></a>SpringBoot + Mybatis实现动态数据源切换</h1><h2 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h2><p>电商订单项目分正向和逆向两个部分：其中正向数据库记录了订单的基本信息，包括订单基本信息、订单商品信息、优惠卷信息、发票信息、账期信息、结算信息、订单备注信息、收货人信息等；逆向数据库主要包含了商品的退货信息和维修信息。数据量超过500万行就要考虑分库分表和读写分离，那么我们在正向操作和逆向操作的时候，就需要动态的切换到相应的数据库，进行相关的操作。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>现在项目的结构设计基本上是基于MVC的，那么数据库的操作集中在dao层完成，主要业务逻辑在service层处理，controller层处理请求。假设在执行dao层代码之前能够将数据源（DataSource）换成我们想要执行操作的数据源，那么这个问题就解决了</p><h2 id="环境准备："><a href="#环境准备：" class="headerlink" title="环境准备："></a>环境准备：</h2><p><strong>1.实体类</strong></p><pre><code>@Datapublic class Product {        private Integer id;        private String name;        private Double price;}</code></pre><p><strong>2.ProductMapper</strong></p><pre><code>public interface ProductMapper {     @Select("select * from product")     public List&lt;Product&gt; findAllProductM();     @Select("select * from product")     public List&lt;Product&gt; findAllProductS(); } </code></pre><p><strong>3.ProductService</strong></p><pre><code>@Service public class ProductService {     @Autowired     private ProductMapper productMapper;     public void findAllProductM(){         // 查询Master         List&lt;Product&gt; allProductM = productMapper.findAllProductM();         System.out.println(allProductM);     }    public void findAllProductS(){         // 查询Slave         List&lt;Product&gt; allProductS = productMapper.findAllProductS();         System.out.println(allProductS);     } }</code></pre><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="第一步：配置多数据源"><a href="#第一步：配置多数据源" class="headerlink" title="第一步：配置多数据源"></a><strong>第一步：配置多数据源</strong></h3><p>首先，我们在application.properties中配置两个数据源</p><pre><code>spring.druid.datasource.master.password=root spring.druid.datasource.master.username=root spring.druid.datasource.master.jdbc- url=jdbc:mysql://localhost:3306/product_master? useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC spring.druid.datasource.master.driver-class-name=com.mysql.cj.jdbc.Driver spring.druid.datasource.slave.password=root spring.druid.datasource.slave.username=root spring.druid.datasource.slave.jdbc- url=jdbc:mysql://localhost:3306/product_slave? useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC spring.druid.datasource.slave.driver-class-name=com.mysql.cj.jdbc.Driver</code></pre><p>在SpringBoot的配置代码中，我们初始化两个数据源：</p><pre><code>@Configuration public class MyDataSourceConfiguratioin {     Logger logger = LoggerFactory.getLogger(MyDataSourceConfiguratioin.class);     /*** Master data source. */     @Bean("masterDataSource")     @ConfigurationProperties(prefix = "spring.druid.datasource.master")     DataSource masterDataSource() {         logger.info("create master datasource...");         return DataSourceBuilder.create().build();     }    /*** Slave data source. */     @Bean("slaveDataSource")     @ConfigurationProperties(prefix = "spring.druid.datasource.slave")     DataSource slaveDataSource() {         logger.info("create slave datasource...");         return DataSourceBuilder.create().build();     }     @Bean    @Primary    DataSource primaryDataSource(@Autowired @Qualifier("masterDataSource")DataSource masterDataSource,                                 @Autowired @Qualifier("masterDataSource")DataSource slaveDataSource){        logger.info("create routing datasource...");         Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;();         map.put("masterDataSource", masterDataSource);         map.put("slaveDataSource", slaveDataSource);         RoutingDataSource routing = new RoutingDataSource();         routing.setTargetDataSources(map);         routing.setDefaultTargetDataSource(masterDataSource);         return routing;     }}</code></pre><h3 id="第二步：编写RoutingDataSource"><a href="#第二步：编写RoutingDataSource" class="headerlink" title="第二步：编写RoutingDataSource"></a><strong>第二步：编写RoutingDataSource</strong></h3><p>然后，我们用Spring内置的RoutingDataSource，把两个真实的数据源代理为一个动态数据源:</p><pre><code>public class RoutingDataSource extends AbstractRoutingDataSource {     @Override     protected Object determineCurrentLookupKey() {         return RoutingDataSourceContext.getDataSourceRoutingKey();    } } </code></pre><h3 id="第三步：编写RoutingDataSourceContext"><a href="#第三步：编写RoutingDataSourceContext" class="headerlink" title="第三步：编写RoutingDataSourceContext"></a><strong>第三步：编写RoutingDataSourceContext</strong></h3><p>用于存储当前需要切换为哪个数据源</p><pre><code>public class RoutingDataSourceContext {     // holds data source key in thread local:     static final ThreadLocal&lt;String&gt; threadLocalDataSourceKey = new ThreadLocal&lt;&gt;();     public static String getDataSourceRoutingKey() {         String key = threadLocalDataSourceKey.get();         return key == null ? "masterDataSource" : key;     }    public RoutingDataSourceContext(String key) {         threadLocalDataSourceKey.set(key);     }    public void close() {         threadLocalDataSourceKey.remove();     }}</code></pre><h3 id="测试（一下代码为controller中代码）"><a href="#测试（一下代码为controller中代码）" class="headerlink" title="测试（一下代码为controller中代码）"></a>测试（一下代码为controller中代码）</h3><pre><code>@GetMapping("/findAllProductM")public String findAllProductM() {        String key = "masterDataSource";        RoutingDataSourceContext routingDataSourceContext = new RoutingDataSourceContext(key);        productService.findAllProductM();        return "master";}@GetMapping("/findAllProductS")public String findAllProductS() {        String key = "slaveDataSource";    RoutingDataSourceContext routingDataSourceContext = new RoutingDataSourceContext(key);    productService.findAllProductS();    return "slave";}</code></pre><p>以上代码即可实现数据源动态切换</p><h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h2><p>以上代码是可行的，但是，需要读数据库的地方，就需要加上一大段RoutingDataSourceContext</p><p>ctx = …代码，使用起来十分不便。以下是优化方案</p><p>我们可以申明一个自定义注解，将以上RoutingDataSourceContext中的值，放在注解的value属性中，</p><p>然后定义一个切面类，当我们在方法上标注自定义注解的时候，执行切面逻辑，获取到注解中的值，set到RoutingDataSourceContext中，从而实现通过注解的方式，来动态切换数据源</p><p>以下是代码实现：</p><p><strong>注解类</strong></p><pre><code>@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface RoutingWith { String value() default "master"; }</code></pre><p><strong>切面类：</strong></p><pre><code>@Aspect @Component public class RoutingAspect { @Around("@annotation(routingWith)") public Object routingWithDataSource(ProceedingJoinPoint joinPoint, RoutingWith routingWith) throws Throwable {     String key = routingWith.value();     RoutingDataSourceContext ctx = new RoutingDataSourceContext(key);     return joinPoint.proceed(); }} </code></pre><p><strong>改造Controller方法</strong></p><pre><code>@RoutingWith("masterDataSource") @GetMapping("/findAllProductM") public String findAllProductM() { productService.findAllProductM(); return "lagou"; }@RoutingWith("slaveDataSource") @GetMapping("/findAllProductS") public String findAllProductS() {  productService.findAllProductS(); return "lagou"; }</code></pre><p>以上就是实现以及优化的所有代码，给菜鸡一个赞吧</p><blockquote><p>作者：yusiji<br>链接：<br><a href="https://juejin.cn/post/6937481321522397221">https://juejin.cn/post/6937481321522397221</a><br>来源：掘金</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Assembly打包和部署SpringBoot工程</title>
      <link href="2021/03/12/shi-yong-assembly-da-bao-he-bu-shu-springboot-gong-cheng/"/>
      <url>2021/03/12/shi-yong-assembly-da-bao-he-bu-shu-springboot-gong-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Assembly打包和部署Spring-Boot工程"><a href="#使用Assembly打包和部署Spring-Boot工程" class="headerlink" title="使用Assembly打包和部署Spring Boot工程"></a>使用Assembly打包和部署Spring Boot工程</h1><h2 id="Spring-Boot项目的2种部署方式"><a href="#Spring-Boot项目的2种部署方式" class="headerlink" title="Spring Boot项目的2种部署方式"></a>Spring Boot项目的2种部署方式</h2><p>目前来说，Spring Boot 项目有如下 2 种常见的部署方式</p><ol><li>一种是使用 docker 容器去部署。将 Spring Boot 的应用构建成一个 docker image，然后通过容器去启动镜像。这种方式在需要部署大规模的应用以及对应用进行扩展时，是非常方便的，属于目前工业级的部署方案，但是需要掌握 docker 的生态圈技术。</li><li>另一种则是使用 FatJar 直接部署启动（将一个 jar 及其依赖的三方 jar 全部打到一个包中，这个包即为 FatJar）。这是很多初学者或者极小规模情况下的一个简单应用部署方式。</li></ol><h2 id="Assembly-的优势"><a href="#Assembly-的优势" class="headerlink" title="Assembly 的优势"></a>Assembly 的优势</h2><p>上面介绍的 Fatjar 部署方案存在一些缺陷。因为我们如果直接构建一个 Spring Boot 的 FatJar 交由运维人员部署的话，整个配置文件都被隐藏到 jar 中，想要针对不同的环境修改配置文件就变成了一件很困难的事情。如果存在环境不确定，或者需要启动脚本启动项目的时候，这种直接通过 jar 的方式后续会需要处理很多工作。</p><p>而通过 assembly 将 Spring Boot 服务化打包，便能解决上面提到的 2 个问题</p><ul><li>使得 Spring Boot 能够加载 jar 外的配置文件。</li><li>提供一个服务化的启动脚本，这个脚本一般是 shell 或者 windows 下的 bat ，有了 Spring Boot 的应用服务脚本后，就可以很容易的去启动和停止 Spring Boot 的应用了。</li></ul><h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><p><strong>添加插件</strong></p><p>(1) 编辑项目的 pom.xml 文件，加入 assembly 打包插件。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--主要使用的是maven提供的assembly插件完成--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-assembly-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptors</span><span class="token punctuation">></span></span>                    <span class="token comment" spellcheck="true">&lt;!--具体的配置文件--></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptor</span><span class="token punctuation">></span></span>src/main/assembly/assembly.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptor</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptors</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>make-assembly<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>                    <span class="token comment" spellcheck="true">&lt;!--绑定到maven操作类型上--></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>                    <span class="token comment" spellcheck="true">&lt;!--运行一次--></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>single<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2) 从上面代码可以看出，把 assembly 的配置都放在 main/assembly 目录下（具体目录里面的文件接下来会创建）。</p><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/563fec49186841c4a7cb59c21cbc93b0?from=pc" alt="使用Assembly打包和部署Spring Boot工程"></p><p><strong>编写服务启动/停止脚本</strong></p><p>首先在 assembly 目录下创建一个 bin 文件夹，然后在该文件夹下创建一个 start.sh 文件，这个是 linux 环境下的启动脚本，具体内容如下。</p><blockquote><p>Tip：开头的项目名称、jar 包名称不用我们手动设置，这里使用参数变量，在项目打包后这些参数自动会替换为 pom 的 profiles 中 properties 的值（assembly 配置文件需要开启属性替换功能），下面另外两个配置文件也同理。</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash# 项目名称SERVER_NAME="${project.artifactId}"# jar名称JAR_NAME="${project.build.finalName}.jar"# 进入bin目录cd `dirname $0`# bin目录绝对路径BIN_DIR=`pwd`# 返回到上一级项目根目录路径cd ..# 打印项目根目录绝对路径# `pwd` 执行系统命令并获得结果DEPLOY_DIR=`pwd`# 外部配置文件绝对目录,如果是目录需要/结尾，也可以直接指定文件# 如果指定的是目录,spring则会读取目录中的所有配置文件CONF_DIR=$DEPLOY_DIR/config# SERVER_PORT=`sed '/server.port/!d;s/.*=//' config/application.properties | tr -d '\r'`# 获取应用的端口号SERVER_PORT=`sed -nr '/port: [0-9]+/ s/.*port: +([0-9]+).*/\1/p' config/application.yml`PIDS=`ps -f | grep java | grep "$CONF_DIR" |awk '{print $2}'`if [ "$1" = "status" ]; then    if [ -n "$PIDS" ]; then        echo "The $SERVER_NAME is running...!"        echo "PID: $PIDS"        exit 0    else        echo "The $SERVER_NAME is stopped"        exit 0    fifiif [ -n "$PIDS" ]; then    echo "ERROR: The $SERVER_NAME already started!"    echo "PID: $PIDS"    exit 1fiif [ -n "$SERVER_PORT" ]; then    SERVER_PORT_COUNT=`netstat -tln | grep $SERVER_PORT | wc -l`    if [ $SERVER_PORT_COUNT -gt 0 ]; then        echo "ERROR: The $SERVER_NAME port $SERVER_PORT already used!"        exit 1    fifi# 项目日志输出绝对路径LOGS_DIR=$DEPLOY_DIR/logs# 如果logs文件夹不存在,则创建文件夹if [ ! -d $LOGS_DIR ]; then    mkdir $LOGS_DIRfiSTDOUT_FILE=$LOGS_DIR/catalina.log# JVM ConfigurationJAVA_OPTS=" -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true "JAVA_DEBUG_OPTS=""if [ "$1" = "debug" ]; then    JAVA_DEBUG_OPTS=" -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n "fiJAVA_JMX_OPTS=""if [ "$1" = "jmx" ]; then    JAVA_JMX_OPTS=" -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false "fiJAVA_MEM_OPTS=""BITS=`java -version 2>&1 | grep -i 64-bit`if [ -n "$BITS" ]; then    JAVA_MEM_OPTS=" -server -Xmx512m -Xms512m -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 "else    JAVA_MEM_OPTS=" -server -Xms512m -Xmx512m -XX:PermSize=128m -XX:SurvivorRatio=2 -XX:+UseParallelGC "fi# 加载外部log4j2文件的配置LOG_IMPL_FILE=log4j2.xmlLOGGING_CONFIG=""if [ -f "$CONF_DIR/$LOG_IMPL_FILE" ]then    LOGGING_CONFIG="-Dlogging.config=$CONF_DIR/$LOG_IMPL_FILE"fiCONFIG_FILES=" -Dlogging.path=$LOGS_DIR $LOGGING_CONFIG -Dspring.config.location=$CONF_DIR/ "echo -e "Starting the $SERVER_NAME ..."nohup java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS $CONFIG_FILES -jar $DEPLOY_DIR/lib/$JAR_NAME > $STDOUT_FILE 2>&1 &COUNT=0while [ $COUNT -lt 1 ]; do    echo -e ".\c"    sleep 1    if [ -n "$SERVER_PORT" ]; then        COUNT=`netstat -an | grep $SERVER_PORT | wc -l`    else       COUNT=`ps -f | grep java | grep "$DEPLOY_DIR" | awk '{print $2}' | wc -l`    fi    if [ $COUNT -gt 0 ]; then        break    fidoneecho "OK!"PIDS=`ps -f | grep java | grep "$DEPLOY_DIR" | awk '{print $2}'`echo "PID: $PIDS"echo "STDOUT: $STDOUT_FILE"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建一个 stop.sh 文件，这个是 linux 环境下的停止脚本，具体内容如下。</p><pre><code>#!/bin/bash# 项目名称APPLICATION="${project.artifactId}"# 项目启动jar包名称APPLICATION_JAR="${project.build.finalName}.jar"# 通过项目名称查找到PI，然后kill -9 pidPID=$(ps -ef | grep "${APPLICATION_JAR}" | grep -v grep | awk '{ print $2 }')if [[ -z "$PID" ]]then    echo ${APPLICATION} is already stoppedelse    echo kill  ${PID}    kill -9 ${PID}    echo ${APPLICATION} stopped successfullyfi</code></pre><p>最后创建一个 start.bat 文件，这个是 Windows 环境下的启动脚本，具体内容如下。</p><pre class="line-numbers language-shell"><code class="language-shell">echo offset APP_NAME=${project.build.finalName}.jarset LOG_IMPL_FILE=log4j2.xmlset LOGGING_CONFIG=if exist ../config/%LOG_IMPL_FILE% (    set LOGGING_CONFIG=-Dlogging.config=../config/%LOGGING_CONFIG%)set CONFIG= -Dlogging.path=../logs %LOGGING_CONFIG% -Dspring.config.location=../config/set DEBUG_OPTS=if ""%1"" == ""debug"" (   set DEBUG_OPTS= -Xloggc:../logs/gc.log -verbose:gc -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=../logs   goto debug)set JMX_OPTS=if ""%1"" == ""jmx"" (   set JMX_OPTS= -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9888 -Dcom.sun.management.jmxremote.ssl=FALSE -Dcom.sun.management.jmxremote.authenticate=FALSE   goto jmx)echo "Starting the %APP_NAME%"java -Xms512m -Xmx512m -server %DEBUG_OPTS% %JMX_OPTS% %CONFIG% -jar ../lib/%APP_NAME%echo "java -Xms512m -Xmx512m -server %DEBUG_OPTS% %JMX_OPTS% %CONFIG% -jar ../lib/%APP_NAME%"goto end:debugecho "debug"java -Xms512m -Xmx512m -server %DEBUG_OPTS% %CONFIG% -jar ../lib/%APP_NAME%goto end:jmxjava -Xms512m -Xmx512m -server %JMX_OPTS% %CONFIG% -jar ../lib/%APP_NAME%goto end:endpause<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>创建打包配置文件</strong></p><p>最后，我们在 assembly 文件夹下创建一个 assembly.xml 配置文件，具体内容如下。</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assembly</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--        必须写，否则打包时会有 assembly ID must be present and non-empty 错误        这个名字最终会追加到打包的名字的末尾，如项目的名字为 hangge-test-0.0.1-SNAPSHOT,        则最终生成的包名为 hangge-test-0.0.1-SNAPSHOT-bin.tar.gz     --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>bin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 打包的类型，如果有N个，将会打N个类型的包 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>formats</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>format</span><span class="token punctuation">></span></span>tar.gz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>format</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--&lt;format>zip&lt;/format>--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>formats</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includeBaseDirectory</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includeBaseDirectory</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--文件设置--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSets</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--            0755->即用户具有读/写/执行权限，组用户和其它用户具有读写权限；            0644->即用户具有读写权限，组用户和其它用户具有只读权限；        --></span>        <span class="token comment" spellcheck="true">&lt;!-- 将src/main/assembly/bin目录下的所有文件输出到打包后的bin目录中 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/assembly/bin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>bin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileMode</span><span class="token punctuation">></span></span>0755<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileMode</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--如果是脚本，一定要改为unix.如果是在windows上面编码，会出现dos编写问题--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lineEnding</span><span class="token punctuation">></span></span>unix<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lineEnding</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtered</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtered</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 是否进行属性替换 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 将src/main/assembly/config目录下的所有文件输出到打包后的config目录中 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/assembly/config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileMode</span><span class="token punctuation">></span></span>0644<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileMode</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 将src/main/resources下配置文件打包到config目录 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>/config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.yml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtered</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtered</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 是否进行属性替换 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 将项目启动jar打包到lib目录中 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>target<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>*.jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 将项目说明文档打包到docs目录中 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>docs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>*.md<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileMode</span><span class="token punctuation">></span></span>0644<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileMode</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>docs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>docs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileMode</span><span class="token punctuation">></span></span>0644<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileMode</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/assembly/docs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>docs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileMode</span><span class="token punctuation">></span></span>0644<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileMode</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSets</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assembly</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="打包测试"><a href="#打包测试" class="headerlink" title="打包测试"></a>打包测试</h2><p><strong>打包项目</strong></p><ol><li>我们使用 mvn package 命令对项目进行打包。</li></ol><p><img src="https://p3-tt.byteimg.com/origin/pgc-image/34d4adc8ee034a5aa6dbc3e298154835?from=pc" alt="使用Assembly打包和部署Spring Boot工程"></p><ol><li>打包后在 target 下便会生成一个名为 xxx.tar.gz 的压缩文件。</li></ol><p><img src="https://p3-tt.byteimg.com/origin/pgc-image/d867043b146e4dfb83712e74e5108372?from=pc" alt="使用Assembly打包和部署Spring Boot工程"></p><ol><li>将这个压缩包解压后可以看到内部包含的目录如下。</li></ol><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/0c0e6411dfc9445784de03beda73ef09?from=pc" alt="使用Assembly打包和部署Spring Boot工程"></p><p><strong>启动服务</strong></p><ol><li>上述打包文件解压后，在 bin 目录有如下几个启动文件</li></ol><ul><li>Linux、macOS 系统：执行 start.sh 启动服务，执行 stop.sh 停止服务。</li><li>Windows 系统：双击 start.bat 即可启动服务</li></ul><p><img src="https://p3-tt.byteimg.com/origin/pgc-image/923c3675369a485c8eab34705589640b?from=pc" alt="使用Assembly打包和部署Spring Boot工程"></p><ol><li>服务启动后，相应的日志文件会生成到 logs 目录下（logs 目录会自动创建）</li></ol><p><img src="https://p1-tt.byteimg.com/origin/pgc-image/22bf65c4ed5f455f9d08379d216ee083?from=pc" alt="使用Assembly打包和部署Spring Boot工程"></p><p><strong>修改配置</strong></p><ol><li>修改 config 文件夹下面的配置文件，此处的配置文件是 application.properties。</li></ol><p><img src="https://p3-tt.byteimg.com/origin/pgc-image/4fec0d0965c047b48b109109b708f948?from=pc" alt="使用Assembly打包和部署Spring Boot工程"></p><ol><li>这里我们将服务端口改成 9090。</li></ol><pre><code>server.port=9090</code></pre><ol><li>重启服务，可以看到端口确实发生了变化，说明外部配置文件加载成功。</li></ol><p><img src="https://p3-tt.byteimg.com/origin/pgc-image/d154e8ffd1e847e786cc5c07e392b2a3?from=pc" alt="使用Assembly打包和部署Spring Boot工程"></p><h2 id="将项目与依赖分开打包"><a href="#将项目与依赖分开打包" class="headerlink" title="将项目与依赖分开打包"></a>将项目与依赖分开打包</h2><p>至此，上文中介绍的使用 assembly 对项目打包时，项目代码和项目所有的依赖文件会一起打成一个可执行的 jar 包。</p><p>如果项目的依赖包很多，那么这个文件就会非常大。每次发布版本如果都要上传这个整个的 jar 包，既浪费带宽也浪费时间。</p><p>下面介绍如何将项目的外部依赖跟自己的代码包分开打包，这样当项目修改后，只需要上传覆盖修改后的包即可。</p><p><strong>修改配置</strong></p><ol><li>首先我们编辑 assembly.xml 配置文件。在前文的基础上新增第三方依赖设置，实现将第三方的 jar 包添加到压缩包里的 lib 目录。</li></ol><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assembly</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--        必须写，否则打包时会有 assembly ID must be present and non-empty 错误        这个名字最终会追加到打包的名字的末尾，如项目的名字为 hangge-test-0.0.1-SNAPSHOT,        则最终生成的包名为 hangge-test-0.0.1-SNAPSHOT-bin.tar.gz     --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>bin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 打包的类型，如果有N个，将会打N个类型的包 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>formats</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>format</span><span class="token punctuation">></span></span>tar.gz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>format</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--&lt;format>zip&lt;/format>--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>formats</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includeBaseDirectory</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includeBaseDirectory</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--第三方依赖设置--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencySets</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencySet</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 不使用项目的artifact，第三方jar不要解压，打包进zip文件的lib目录 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>useProjectArtifact</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>useProjectArtifact</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>unpack</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>unpack</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencySet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencySets</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--文件设置--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSets</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--            0755->即用户具有读/写/执行权限，组用户和其它用户具有读写权限；            0644->即用户具有读写权限，组用户和其它用户具有只读权限；        --></span>        <span class="token comment" spellcheck="true">&lt;!-- 将src/main/assembly/bin目录下的所有文件输出到打包后的bin目录中 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/assembly/bin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>bin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileMode</span><span class="token punctuation">></span></span>0755<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileMode</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--如果是脚本，一定要改为unix.如果是在windows上面编码，会出现dos编写问题--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>lineEnding</span><span class="token punctuation">></span></span>unix<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>lineEnding</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtered</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtered</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 是否进行属性替换 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 将src/main/assembly/config目录下的所有文件输出到打包后的config目录中 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/assembly/config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileMode</span><span class="token punctuation">></span></span>0644<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileMode</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 将src/main/resources下配置文件打包到config目录 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>/config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.properties<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>**/*.yml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtered</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtered</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 是否进行属性替换 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 将项目启动jar打包到lib目录中 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>target<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>*.jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 将项目说明文档打包到docs目录中 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>docs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>includes</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span><span class="token punctuation">></span></span>*.md<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>includes</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileMode</span><span class="token punctuation">></span></span>0644<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileMode</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>docs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>docs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileMode</span><span class="token punctuation">></span></span>0644<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileMode</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileSet</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/assembly/docs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>docs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileMode</span><span class="token punctuation">></span></span>0644<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileMode</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSet</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileSets</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assembly</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>接着编辑项目的 pom.xml 文件，先前使用的是 spring-boot-maven-plugin 来打包，这个插件会将项目所有的依赖打入项目 jar 包里面。我们将其替换为 maven-jar-plugin，并进行相关设置。</li></ol><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 指定启动类，将依赖打成外部jar包 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-jar-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>archive</span><span class="token punctuation">></span></span>                    <span class="token comment" spellcheck="true">&lt;!-- 生成的jar中，不要包含pom.xml和pom.properties这两个文件 --></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>addMavenDescriptor</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>addMavenDescriptor</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifest</span><span class="token punctuation">></span></span>                        <span class="token comment" spellcheck="true">&lt;!-- 是否要把第三方jar加入到类构建路径 --></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>addClasspath</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>addClasspath</span><span class="token punctuation">></span></span>                        <span class="token comment" spellcheck="true">&lt;!-- 外部依赖jar包的最终位置 --></span>                        <span class="token comment" spellcheck="true">&lt;!-- 因为我们将第三方jar和本项目jar放在同一个目录下，这里就使用./ --></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classpathPrefix</span><span class="token punctuation">></span></span>./<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classpathPrefix</span><span class="token punctuation">></span></span>                        <span class="token comment" spellcheck="true">&lt;!-- 项目启动类 --></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mainClass</span><span class="token punctuation">></span></span>com.example.hanggetest.HanggeTestApplication<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mainClass</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifest</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>archive</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--主要使用的是maven提供的assembly插件完成--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-assembly-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptors</span><span class="token punctuation">></span></span>                    <span class="token comment" spellcheck="true">&lt;!--具体的配置文件--></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>descriptor</span><span class="token punctuation">></span></span>src/main/assembly/assembly.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptor</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>descriptors</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>make-assembly<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>                    <span class="token comment" spellcheck="true">&lt;!--绑定到maven操作类型上--></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>                    <span class="token comment" spellcheck="true">&lt;!--运行一次--></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>single<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>打包测试</strong></p><p>上面两个配置修改完毕后，我们重新对项目进行打包。将生成的压缩包解压后可以发现，lib 文件夹下项目 jar 包以及第三方 jar 都分开了，并且项目 jar 体积也十分小巧。</p><p><img src="https://p3-tt.byteimg.com/origin/pgc-image/507dbf7d7b964769b6230a9e5caaa91d?from=pc" alt="使用Assembly打包和部署Spring Boot工程"></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>commond Docker</title>
      <link href="2021/03/05/commond-docker/"/>
      <url>2021/03/05/commond-docker/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Docker容器信息"><a href="#1、Docker容器信息" class="headerlink" title="1、Docker容器信息"></a>1、Docker容器信息</h2><pre class="line-numbers language-shell"><code class="language-shell">##查看docker容器版本docker version##查看docker容器信息docker info##查看docker容器帮助docker --help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、镜像操作"><a href="#2、镜像操作" class="headerlink" title="2、镜像操作"></a>2、镜像操作</h2><p>提示：对于镜像的操作可使用镜像名、镜像长ID和短ID。</p><h3 id="2-1、镜像查看"><a href="#2-1、镜像查看" class="headerlink" title="2.1、镜像查看"></a>2.1、镜像查看</h3><pre class="line-numbers language-shell"><code class="language-shell">##列出本地imagesdocker images##含中间映像层docker images -a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>##只显示镜像IDdocker images -q##含中间映像层docker images -qa   </code></pre><pre><code>##显示镜像摘要信息(DIGEST列)docker images --digests##显示镜像完整信息docker images --no-trunc</code></pre><pre><code>##显示指定镜像的历史创建；参数：-H 镜像大小和日期，默认为true；--no-trunc  显示完整的提交记录；-q  仅列出提交记录IDdocker history -H redis</code></pre><h3 id="2-2、镜像搜索"><a href="#2-2、镜像搜索" class="headerlink" title="2.2、镜像搜索"></a>2.2、镜像搜索</h3><pre><code>##搜索仓库MySQL镜像docker search mysql## --filter=stars=600：只显示 starts&gt;=600 的镜像docker search --filter=stars=600 mysql## --no-trunc 显示镜像完整 DESCRIPTION 描述docker search --no-trunc mysql## --automated ：只列出 AUTOMATED=OK 的镜像docker search  --automated mysql</code></pre><h3 id="2-3、镜像下载"><a href="#2-3、镜像下载" class="headerlink" title="2.3、镜像下载"></a>2.3、镜像下载</h3><pre><code>##下载Redis官方最新镜像，相当于：docker pull redis:latestdocker pull redis##下载仓库所有Redis镜像docker pull -a redis##下载私人仓库镜像docker pull bitnami/redis</code></pre><h3 id="2-4、镜像删除"><a href="#2-4、镜像删除" class="headerlink" title="2.4、镜像删除"></a>2.4、镜像删除</h3><pre><code>##单个镜像删除，相当于：docker rmi redis:latestdocker rmi redis##强制删除(针对基于镜像有运行的容器进程)docker rmi -f redis##多个镜像删除，不同镜像间以空格间隔docker rmi -f redis tomcat nginx##删除本地全部镜像docker rmi -f $(docker images -q)</code></pre><h3 id="2-5、镜像构建"><a href="#2-5、镜像构建" class="headerlink" title="2.5、镜像构建"></a>2.5、镜像构建</h3><pre><code>##（1）编写dockerfilecd /docker/dockerfilevim mycentos##（2）构建docker镜像docker build -f /docker/dockerfile/mycentos -t mycentos:1.1</code></pre><h2 id="3、容器操作"><a href="#3、容器操作" class="headerlink" title="3、容器操作"></a>3、容器操作</h2><p>提示：对于容器的操作可使用CONTAINER ID 或 NAMES。</p><h3 id="3-1、容器启动"><a href="#3-1、容器启动" class="headerlink" title="3.1、容器启动"></a>3.1、容器启动</h3><pre><code>##新建并启动容器，参数：-i  以交互模式运行容器；-t  为容器重新分配一个伪输入终端；--name  为容器指定一个名称docker run -i -t --name mycentos##后台启动容器，参数：-d  已守护方式启动容器docker run -d mycentos## 启动jenkins镜像docker run -d -p 7000:8080 -p 50000:50000 -v /home/data/docker/jenkins:/var/jenkins_home --name jenkins --restart always --privileged=true  -u root jenkins/jenkins:lts</code></pre><p>注意：此时使用”docker ps -a”会发现容器已经退出。这是docker的机制：要使Docker容器后台运行，就必须有一个前台进程。解决方案：将你要运行的程序以前台进程的形式运行。</p><pre><code>##启动一个或多个已经被停止的容器docker start redis##重启容器docker restart redis</code></pre><h3 id="3-2、容器进程"><a href="#3-2、容器进程" class="headerlink" title="3.2、容器进程"></a>3.2、容器进程</h3><pre><code>##top支持 ps 命令参数，格式：docker top [OPTIONS] CONTAINER [ps OPTIONS]##列出redis容器中运行进程docker top redis##查看所有运行容器的进程信息for i in  `docker ps |grep Up|awk '{print $1}'`;do echo \ &amp;&amp;docker top $i; done</code></pre><h3 id="3-3、容器日志"><a href="#3-3、容器日志" class="headerlink" title="3.3、容器日志"></a>3.3、容器日志</h3><pre><code>##查看redis容器日志，默认参数docker logs rabbitmq##查看redis容器日志，参数：-f  跟踪日志输出；-t   显示时间戳；--tail  仅列出最新N条容器日志；docker logs -f -t --tail=20 redis##查看容器redis从2019年05月21日后的最新10条日志。docker logs --since="2019-05-21" --tail=10 redis</code></pre><h3 id="3-4、容器的进入与退出"><a href="#3-4、容器的进入与退出" class="headerlink" title="3.4、容器的进入与退出"></a>3.4、容器的进入与退出</h3><pre><code>##使用run方式在创建时进入docker run -it centos /bin/bash##关闭容器并退出exit##仅退出容器，不关闭快捷键：Ctrl + P + Q##直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=false  确保CTRL-D或CTRL-C不会关闭容器docker attach --sig-proxy=false centos ##在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i  即使没有附加也保持STDIN 打开；-t  分配一个伪终端docker exec -i -t  centos /bin/bash##以交互模式在容器中执行命令，结果返回到当前终端屏幕docker exec -i -t centos ls -l /tmp##以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端docker exec -d centos  touch cache.txt </code></pre><h3 id="3-5、查看容器"><a href="#3-5、查看容器" class="headerlink" title="3.5、查看容器"></a>3.5、查看容器</h3><pre><code>##查看正在运行的容器docker ps##查看正在运行的容器的IDdocker ps -q##查看正在运行+历史运行过的容器docker ps -a##显示运行容器总文件大小docker ps -s</code></pre><pre><code>##显示最近创建容器docker ps -l##显示最近创建的3个容器docker ps -n 3##不截断输出docker ps --no-trunc </code></pre><pre><code>##获取镜像redis的元信息docker inspect redis##获取正在运行的容器redis的 IPdocker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' redis</code></pre><h3 id="3-6、容器的停止与删除"><a href="#3-6、容器的停止与删除" class="headerlink" title="3.6、容器的停止与删除"></a>3.6、容器的停止与删除</h3><pre><code>##停止一个运行中的容器docker stop redis##杀掉一个运行中的容器docker kill redis##删除一个已停止的容器docker rm redis##删除一个运行中的容器docker rm -f redis##删除多个容器docker rm -f $(docker ps -a -q)docker ps -a -q | xargs docker rm## -l 移除容器间的网络连接，连接名为 dbdocker rm -l db ## -v 删除容器，并删除容器挂载的数据卷docker rm -v redis</code></pre><h3 id="3-7、生成镜像"><a href="#3-7、生成镜像" class="headerlink" title="3.7、生成镜像"></a>3.7、生成镜像</h3><pre><code>##基于当前redis容器创建一个新的镜像；参数：-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停docker commit -a="DeepInThought" -m="my redis" [redis容器ID]  myredis:v1.1</code></pre><h3 id="3-8、容器与主机间的数据拷贝"><a href="#3-8、容器与主机间的数据拷贝" class="headerlink" title="3.8、容器与主机间的数据拷贝"></a>3.8、容器与主机间的数据拷贝</h3><pre><code>##将rabbitmq容器中的文件copy至本地路径docker cp rabbitmq:/[container_path] [local_path]##将主机文件copy至rabbitmq容器docker cp [local_path] rabbitmq:/[container_path]/##将主机文件copy至rabbitmq容器，目录重命名为[container_path]（注意与非重命名copy的区别）docker cp [local_path] rabbitmq:/[container_path]</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jackson</title>
      <link href="2021/03/01/jackson/"/>
      <url>2021/03/01/jackson/</url>
      
        <content type="html"><![CDATA[<h1 id="Jackson的功能原来如此之牛"><a href="#Jackson的功能原来如此之牛" class="headerlink" title="Jackson的功能原来如此之牛"></a>Jackson的功能原来如此之牛</h1><p>Java高级架构师2021-02-24 13:18:53</p><blockquote><p>原文出自：公众号 程序新视界</p><p>原文链接：<a href="https://mp.weixin.qq.com/s/m34q4AC-T0fc9oIWxDqEVg">https://mp.weixin.qq.com/s/m34q4AC-T0fc9oIWxDqEVg</a></p></blockquote><p>在上篇《<a href="https://www.toutiao.com/i6932339487607439880/?group_id=6932339487607439880">经过多方调研，最终还是决定禁用FastJson</a>》中，讲了FastJson的基本使用以及存在的不确定性问题，所以最终决定在项目中放弃使用，进而选择市面上比较主流，Spring Boot默认绑定的JSON类库：Jackson。</p><p>本文就来讲解一下Jackson的基本使用以及与Spring Boot的结合与实践。</p><h2 id="什么是Jackson"><a href="#什么是Jackson" class="headerlink" title="什么是Jackson"></a>什么是Jackson</h2><p>Jackson是比较主流的基于Java的JSON类库，可用于Json和XML与JavaBean之间的序列化和反序列化。</p><p>没看错，Jackson也可以处理JavaBean与XML之间的转换，基于jackson-dataformat-xml组件，而且比较JDK自带XML实现更加高效和安全。而我们使用比较多的是处理JSON与JavaBean之间的功能。</p><p>Jackson主流到什么程度？单从Maven仓库中的统计来看，Jackson的使用量排位第一。而Spring Boot支持的三个JSON库（Gson、Jackson、JSON-B）中，Jackson是首选默认库。</p><p>Jackson也有以下特点：依赖少，简单易用，解析大Json速度快、内存占用比较低、拥有灵活的API、方便扩展与定制。</p><p>Jackson类库GitHub地址：<a href="https://github.com/FasterXML/jackson">https://github.com/FasterXML/jackson</a> 。</p><h2 id="Jackson的组成部分"><a href="#Jackson的组成部分" class="headerlink" title="Jackson的组成部分"></a>Jackson的组成部分</h2><p>Jackson的核心模块由三部分组成（从Jackson 2.x开始）：jackson-core、jackson-annotations、jackson-databind。</p><ul><li>jackson-core：核心包，定义了低级流（Streaming）API，提供基于”流模式”解析。Jackson内部实现正是通过高性能的流模式API的JsonGenerator和JsonParser来生成和解析json。</li><li>jackson-annotations，注解（Annotations）包，提供标准的Jackson注解功能；</li><li>jackson-databind：数据绑定（Databind）包，实现了数据绑定（和对象序列化）支持，它依赖于Streaming和Annotations包。提供基于“对象绑定”解析的API（ObjectMapper）和”树模型”解析的API（JsonNode）；基于”对象绑定”解析的API和”树模型”解析的API依赖基于“流模式”解析的API。</li></ul><p>下面看一下不同环境下相关组件的依赖引入情况。</p><p>在SpringBoot当中，spring-boot-starter-web间接引入了Jackson组件，也就是如果你使用了SpringBoot框架，那么你的项目中已经有了Jackson依赖。下面的依赖省略了version和scope项。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>web starter中依赖了json starter：</p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>json starter最终引入了Jackson：</p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;  &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;  &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;  &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>上面已经提到过，jackson-databind依赖于Streaming和Annotations包，因此，引入jackson-databind相当于引入了jackson-core和jackson-annotations。</p><p>通常情况下，我们单独使用时，根据需要通过Maven引入jackson-databind、jackson-core和jackson-annotations即可。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>对于SpringBoot项目，基本上不用再额外添加依赖。</p><h2 id="Jackson核心类ObjectMapper"><a href="#Jackson核心类ObjectMapper" class="headerlink" title="Jackson核心类ObjectMapper"></a>Jackson核心类ObjectMapper</h2><p>Jackson提供了三种JSON的处理方式，分别是：数据绑定、JSON树模型、流式API。其中前两项功能都是基于ObjectMapper来实现的，而流式API功能则需要基于更底层的JsonGenerator和JsonParser来实现。</p><p>通常情况下我们使用ObjectMapper类就足够了，它拥有以下功能：</p><ul><li>从字符串、流或文件中解析JSON，并创建表示已解析的JSON的Java对象（反序列化）。</li><li>将Java对象构建成JSON字符串（序列化）。</li><li>将JSON解析为自定义类的对象，也可以解析JSON树模型的对象；</li></ul><p>ObjectMapper基于JsonParser和JsonGenerator来实现JSON实际的读/写。这一点看一下ObjectMapper的构造方法即可明白。</p><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><p>Jackson的常见使用，就不逐一讲解了，通过一些列的实例给大家展示一下，每个实例当中都会通过注释进行说明。</p><h2 id="常见简单使用"><a href="#常见简单使用" class="headerlink" title="常见简单使用"></a>常见简单使用</h2><p>下面的示例是我们经常会用到的用法演示，主要涉及到JavaBean和Json字符串之间的转换。</p><p>Jackson在将json转换为JavaBean属性时，默认是通过Json字段的名称与Java对象中的getter和setter方法进行匹配进行绑定。</p><p>Jackson取getter和setter方法名称中去除“get”和“set”部分，并将首字母小写。例如Json中的name，与JavaBean中的getName()和setName()进行匹配。</p><p>但并不是所有的属性都可以被序列化和反序列化，基本上遵循一下规则：</p><ul><li>public修饰的属性可序列化和反序列化。</li><li>属性提供public的getter/setter方法，该属性可序列化和反序列化。</li><li>属性只有public的setter方法，而无public的getter方法，该属性只能用于反序列化。</li></ul><pre><code>@Slf4jpublic class JacksonTest {    /**     * JavaBean转JSON字符串     */    @Test    public void testJavaBeanToJson() {        WeChat weChat = new WeChat();        weChat.setId("zhuan2quan");        weChat.setName("程序新视界");        weChat.setInterest(new String[]{"Java", "Spring Boot", "JVM"});        ObjectMapper mapper = new ObjectMapper();        try {            String result = mapper.writeValueAsString(weChat);            System.out.println(result);        } catch (JsonProcessingException e) {            log.error("转换异常", e);        }    }    /**     * JSON字符串转JavaBean     */    @Test    public void testJsonToJavaBean() {        String json = "{\"id\":\"zhuan2quan\",\"name\":\"程序新视界\",\"interest\":[\"Java\",\"Spring Boot\",\"JVM\"]}";        ObjectMapper mapper = new ObjectMapper();        try {            WeChat weChat = mapper.readValue(json, WeChat.class);            System.out.println(weChat);        } catch (JsonProcessingException e) {            log.error("解析异常", e);        }    }    /**     * JSON字符串转Map集合     */    @Test    public void testJsonToMap() {        String json = "{\"id\":\"zhuan2quan\",\"name\":\"程序新视界\",\"interest\":[\"Java\",\"Spring Boot\",\"JVM\"]}";        ObjectMapper mapper = new ObjectMapper();        try {            // 对泛型的反序列化，使用TypeReference可以明确的指定反序列化的类型。            Map&lt;String, Object&gt; map = mapper.readValue(json, new TypeReference&lt;Map&lt;String, Object&gt;&gt;() {            });            System.out.println(map);        } catch (JsonProcessingException e) {            log.error("解析异常", e);        }    }    /**     * JavaBean转文件     */    @Test    public void testJavaBeanToFile() {        WeChat weChat = new WeChat();        weChat.setId("zhuan2quan");        weChat.setName("程序新视界");        weChat.setInterest(new String[]{"Java", "Spring Boot", "JVM"});        ObjectMapper mapper = new ObjectMapper();        try {            //写到文件            mapper.writeValue(new File("/json.txt"), weChat);            //从文件中读取            WeChat weChat1 = mapper.readValue(new File("/json.txt"), WeChat.class);            System.out.println(weChat1);        } catch (IOException e) {            log.error("转换异常", e);        }    }    /**     * JavaBean转字节流     */    @Test    public void testJavaBeanToBytes() {        WeChat weChat = new WeChat();        weChat.setId("zhuan2quan");        weChat.setName("程序新视界");        weChat.setInterest(new String[]{"Java", "Spring Boot", "JVM"});        ObjectMapper mapper = new ObjectMapper();        try {            // 写为字节流            byte[] bytes = mapper.writeValueAsBytes(weChat);            // 从字节流读取            WeChat weChat1 = mapper.readValue(bytes, WeChat.class);            System.out.println(weChat1);        } catch (IOException e) {            log.error("转换异常", e);        }    }}</code></pre><p>上述代码用到了lombok注解和单元测试注解，根据需要可进行替换。</p><h2 id="JSON树模型"><a href="#JSON树模型" class="headerlink" title="JSON树模型"></a>JSON树模型</h2><p>如果Json字符串比较大，则可使用JSON树模型来灵活的获取所需的字段内容。在Jackson中提供了get、path、has等方法来获取或判断。</p><p>下面直接看两个示例：</p><pre><code>@Slf4jpublic class JacksonNodeTest {    /**     * JavaBean转JSON字符串     */    @Test    public void testJsonNode() {        // 构建JSON树        ObjectMapper mapper = new ObjectMapper();        ObjectNode root = mapper.createObjectNode();        root.put("id", "zhuan2quan");        root.put("name", "程序新视界");        ArrayNode interest = root.putArray("interest");        interest.add("Java");        interest.add("Spring Boot");        interest.add("JVM");        // JSON树转JSON字符串        String json = null;        try {            json = mapper.writeValueAsString(root);        } catch (JsonProcessingException e) {            log.error("Json Node转换异常", e);        }        System.out.println(json);    }    /**     * 解析JSON字符串为JSON树模型     */    @Test    public void testJsonToJsonNode() {        String json = "{\"id\":\"zhuan2quan\",\"name\":\"程序新视界\",\"interest\":[\"Java\",\"Spring Boot\",\"JVM\"]}";        ObjectMapper mapper = new ObjectMapper();        try {            // 将JSON字符串转为JSON树            JsonNode jsonNode = mapper.readTree(json);            String name = jsonNode.path("name").asText();            System.out.println(name);            JsonNode interestNode = jsonNode.get("interest");            if (interestNode.isArray()){                for (JsonNode node : interestNode){                    System.out.println(node.asText());                }            }        } catch (JsonProcessingException e) {            log.error("Json Node转换异常", e);        }    }}</code></pre><p>其中get方法和path功能相似，区别在于如果要读取的key在Json串中不存在时，get方法会null，而path会返回MissingNode实例对象，在链路方法情况下保证不会抛出异常。</p><h2 id="流式API"><a href="#流式API" class="headerlink" title="流式API"></a>流式API</h2><p>除了上述两种形式，还可以基于底层的流式API来进行操作，主要通过JsonGenerator和JsonParser两个API，但操作起来比较复杂，就不再这里演示了。</p><h2 id="格式化统一配置"><a href="#格式化统一配置" class="headerlink" title="格式化统一配置"></a>格式化统一配置</h2><p>在使用ObjectMapper时，会存在一些字段在某些情况下不需要进行序列化或反序列化，同时还可能需要指定格式化的一些信息等。此时，可以通过ObjectMapper进行配置。</p><pre><code>//反序列化时忽略json中存在但Java对象不存在的属性mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);//序列化时日期格式默认为yyyy-MM-dd'T'HH:mm:ss.SSSZmapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);//序列化时自定义时间日期格式mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));//序列化时忽略值为null的属性mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);//序列化时忽略值为默认值的属性mapper.setDefaultPropertyInclusion(JsonInclude.Include.NON_DEFAULT);</code></pre><p>针对于配置项，在2.2版本中新增了一个ObjectMapper的实现类JsonMapper，功能与ObjectMapper一致。不过新增了一个builder方法。可以直接通过JsonMapper.builder().configure()方法来进行配置，最后获得一个JsonMapper对象。JsonMapper的其他方法基本都集成自ObjectMapper。</p><h2 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h2><p>上面通过统一配置可对全局格式的序列化和反序列化进行配置，但某些个别的场景下，需要针对具体的字段进行配置，这就需要用注解。比如当Json字符串中的字段与Java对象中的属性不一致时，就需要通过注解来建立它们直接的关系。</p><p>@JsonProperty，作用JavaBean字段上，指定一个字段用于JSON映射，默认情况下映射的JSON字段与注解的字段名称相同。可通过value属性指定映射的JSON的字段名称。</p><p>@JsonIgnore可用于字段、getter/setter、构造函数参数上，指定字段不参与序列化和反序列化。</p><p>@JsonIgnoreProperties作用于类上，序列化时@JsonIgnoreProperties({“prop1”, “prop2”})会忽略pro1和pro2两个属性。反序列化时@JsonIgnoreProperties(ignoreUnknown=true)会忽略类中不存在的字段。</p><p>@JsonFormat作用于字段上，通常用来进行格式化操作。</p><pre><code>@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")private Date date;</code></pre><p>如果JavaBean中的时间字段使用的是JDK8新增的时间日期（LocalDate/LocalTime/LocalDateTime）类型的话，需要添加jackson-datatype-jsr310依赖。在讲依赖部分时，SpringBoot默认引入的依赖中就有这个。</p><p>当然，还有一些其他的注解，比如@JsonPropertyOrder、@JsonRootName、@JsonAnySetter、@JsonAnyGetter、@JsonNaming等，当使用时参考对应的文档和示例看一下就可以，这里就不再一一列出了。</p><h2 id="自定义解析器"><a href="#自定义解析器" class="headerlink" title="自定义解析器"></a>自定义解析器</h2><p>如果上面的注解和统一配置还无法满足需求，可自定义解析器，示例如下：</p><pre><code>public class MyFastjsonDeserialize extends JsonDeserializer&lt;Point&gt; {    @Override    public Point deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {        JsonNode node = jsonParser.getCodec().readTree(jsonParser);        Iterator&lt;JsonNode&gt; iterator = node.get("coordinates").elements();        List&lt;Double&gt; list = new ArrayList&lt;&gt;();        while (iterator.hasNext()) {            list.add(iterator.next().asDouble());        }        return new Point(list.get(0), list.get(1));    }}</code></pre><p>定义完成之后，注册到Mapper中：</p><pre><code>ObjectMapper objectMapper = new ObjectMapper();SimpleModule module = new SimpleModule();module.addDeserializer(Point.class, new MyFastjsonDeserialize());objectMapper.registerModule(module);</code></pre><h2 id="Jackson处理XML"><a href="#Jackson处理XML" class="headerlink" title="Jackson处理XML"></a>Jackson处理XML</h2><p>Jackson也可以通过jackson-dataformat-xml包提供了处理XML的功能。在处理XML时建议使用woodstox-core包，它是一个XML的实现，比JDK自带XML实现更加高效，也更加安全。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>如果使用Java 9及以上版本，可能会出现java.lang.NoClassDefFoundError: javax/xml/bind/JAXBException异常，这是因为Java 9实现了JDK的模块化，将原本和JDK打包在一起的JAXB实现分隔出来。所以需要手动添加JAXB的实现。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;    &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>下面是代码示例，基本上和JSON的API非常相似，XmlMapper实际上就是ObjectMapper的子类。</p><pre><code>@Testpublic void testXml(){    WeChat weChat = new WeChat();    weChat.setId("zhuan2quan");    weChat.setName("程序新视界");    weChat.setInterest(new String[]{"Java", "Spring Boot", "JVM"});    XmlMapper xmlMapper = new XmlMapper();    try {        String xml = xmlMapper.writeValueAsString(weChat);        System.out.println(xml);    } catch (JsonProcessingException e) {        e.printStackTrace();    }}</code></pre><p>执行之后，输出结果：</p><pre><code>&lt;WeChat&gt;    &lt;id&gt;zhuan2quan&lt;/id&gt;    &lt;name&gt;程序新视界&lt;/name&gt;    &lt;interest&gt;        &lt;interest&gt;Java&lt;/interest&gt;        &lt;interest&gt;Spring Boot&lt;/interest&gt;        &lt;interest&gt;JVM&lt;/interest&gt;    &lt;/interest&gt;&lt;/WeChat&gt;</code></pre><h2 id="Spring-Boot中的集成"><a href="#Spring-Boot中的集成" class="headerlink" title="Spring Boot中的集成"></a>Spring Boot中的集成</h2><p>在最开始的时候，我们已经看到Spring Boot默认引入了Jackson的依赖，而且也用我们做什么额外的操作，其实已经在使用Jackson进行Json格式的数据与MVC中参数进行绑定操作了。</p><p>如果Spring Boot默认的配置并不适合项目需求，也可以通过内置的配置进行配置，以application.yml配置为例，可通过指定以下属性进行相应选项的配置：</p><pre><code>#指定日期格式，比如yyyy-MM-dd HH:mm:ss，或者具体的格式化类的全限定名spring.jackson.date-format #是否开启Jackson的反序列化spring.jackson.deserialization#是否开启json的generators.spring.jackson.generator#指定Joda date/time的格式，比如yyyy-MM-ddHH:mm:ss). 如果没有配置的话，dateformat会作为backupspring.jackson.joda-date-time-format#指定json使用的Locale.spring.jackson.locale#是否开启Jackson通用的特性.spring.jackson.mapper#是否开启jackson的parser特性.spring.jackson.parser#指定PropertyNamingStrategy(CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES)或者指定PropertyNamingStrategy子类的全限定类名.spring.jackson.property-naming-strategy#是否开启jackson的序列化.spring.jackson.serialization#指定序列化时属性的inclusion方式，具体查看JsonInclude.Include枚举.spring.jackson.serialization-inclusion#指定日期格式化时区，比如America/Los_Angeles或者GMT+10.spring.jackson.time-zone</code></pre><p>Spring Boot自动配置非常方便，但某些时候需要我们手动配置Bean来替代自动配置的Bean。可通过如下形式进行配置：</p><pre><code>@Configurationpublic class JacksonConfig {    @Bean    @Qualifier("json")    public ObjectMapper jsonMapper(Jackson2ObjectMapperBuilder builder) {        ObjectMapper mapper = builder.createXmlMapper(false)                .build();        mapper.enable(SerializationFeature.INDENT_OUTPUT);        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);        return mapper;    }}</code></pre><p>配置完成，可在使用的地方直接注入即可：</p><pre><code>@Resourceprivate ObjectMapper jsonMapper;</code></pre><p>对于上面的注入，可能会有朋友问了，是否有线程安全的问题？这个不用担心ObjectMapper是线程安全的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>经过本篇文章的讲解，大家对Jackson应该有一个比较全面的了解了。就个人而言，学习Jackson之后，感觉还是挺有意思的。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jackson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解SpringSecurity登录原理带你看源代码</title>
      <link href="2021/02/23/xiang-jie-springsecurity-deng-lu-yuan-li-dai-ni-kan-yuan-dai-ma/"/>
      <url>2021/02/23/xiang-jie-springsecurity-deng-lu-yuan-li-dai-ni-kan-yuan-dai-ma/</url>
      
        <content type="html"><![CDATA[<p>使用的jar和版本：<br>springboot：2.4.2</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-oauth2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.social<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-social-security<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>12345678910<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="security过滤器链总概括"><a href="#security过滤器链总概括" class="headerlink" title="security过滤器链总概括"></a>security过滤器链总概括</h1><p><strong>下图为security过滤器链的流程图</strong></p><p><img src="https://p1-tt.byteimg.com/origin/pgc-image/59d22456ba374bd6accd9879de39f865?from=pc" alt="全网最详解Spring Security登录原理带你看源代码"></p><h1 id="对于上图的讲解"><a href="#对于上图的讲解" class="headerlink" title="对于上图的讲解"></a><strong>对于上图的讲解</strong></h1><ol><li>登录检验过滤器（上图的绿色模块）：<strong>根据上图所示配置了所有的请求都需要身份认证，那么，此拦截器就会检测当前请求是否经过了绿色过滤器的认证，即检查标记，实际上，这一段配置可以写得非常复杂，比如可以配置某类请求只有VIP用户才允许访问等，这些配置都会被拦截器读取，拦截器会根据这些配置做判断。如果判断通过，那么访问到具体API，如果不过，根据不过的原因，会抛出不同的异常。<br>比如在当前配置中，配置了所有请求都需要身份认证，那么，如果当前请求没有认证，拦截器就会抛出一个用户没有经过身份认证异常。如果配置文件中配置了当前请求只有VIP用户才能访问，而用户在之前虽然验证了，但是并不是VIP用户，那么就会抛出用户权限不足异常，在异常抛出之后，就会被固定在拦截器前面一环的ExceptionTranslationFilter所捕获，这两个过滤器是固定在过滤器最终的两环之上。ExceptionTranslationFilter这个过滤器最主要的作用就是用来捕获守门人所抛出的异常，然后根据抛出的异常，作出相应的处理，比如说，如果是因为没有登录抛出的异常，那么就会根据配置文件中的配置，引导用户完成认证，比如，配置文件中配置了formLogin方式认证，那么该过滤器就会引导用户到默认的认证页面，如果配置了httpBasic方式，那么就会让浏览器弹出一个窗口，让用户进行认证。至此，即为SpringSecurity整个核心业务的基本原理，整个框架提供的业务和特性，都是经过当前过滤器链实现的。在之后的章节中，会讲解如何使用手机验证码，或者微信qq等第三方登录，实际上，都是在这个过滤器链上加入这种绿色的拦截器，来支持不同的身份认证功能逻辑，在实际的业务中，过滤器链上过滤器链上过滤器不止这三种，还会有其他很多种，一般一个普通的应用都会有10几个这个过滤器，在后续的章节中，会讲解这些过滤器，目前，在讲解SpringSecurity基本原理的过程中，只需要知道有这三种过滤器即可。注意，在拦截器上，这些绿色的拦截器是可以通过配置文件决定使用或者不是用的，但是其他两种过滤器，是肯定会出现在框架中，并且肯定是在最后的两个环节上。位置不可更改，也不能在过滤器链上去掉。</strong></li></ol><p><strong>一些解释和说明</strong><br>（1）Authentication(身份验证)对象：是Spring Security用来描述当前用户的相关信息的一个对象。而对于不同的登录方式，会实现一种该组件，实际上就是个pojo。</p><ol><li>用户名和密码被获取并组合到UsernamePasswordAuthenticationToken的实例中(Authentication接口的实例)。</li><li>token令牌被传递到AuthenticationManager的实例进行验证。</li><li>身份验证成功时，AuthenticationManager将返回一个完全填充的身份验证实例。</li><li>安全上下文是通过调用SecurityContextHolder.getContext().setAuthentication(…)，转入返回的身份验证对象。</li></ol><p>查看它的源代6个方法，后面的流程有用到。</p><h1 id="Authentication接口"><a href="#Authentication接口" class="headerlink" title="Authentication接口"></a><strong>Authentication接口</strong></h1><pre><code>public interface Authentication extends Principal, Serializable {'    //授予委托人的权限集合。例如登录人是员工则是员工的权限，登录者是用户则是用户的权限。    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();    //证明主体正确的凭据，通常是密码    Object getCredentials();    //存储有关身份验证请求的其他详细信息。例如：IP地址，证书序列号等。    Object getDetails();    //被认证主体的身份    Object getPrincipal();    //令牌是否通过身份验证    boolean isAuthenticated();    //设置身份验证令牌是否受信任    void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;}1234567891011121314</code></pre><p>（2）idea按ctrl+n可以搜索所有的源代码</p><h1 id="开始源代码的流程详解"><a href="#开始源代码的流程详解" class="headerlink" title="开始源代码的流程详解"></a><strong>开始源代码的流程详解</strong></h1><h2 id="1-AuthenticationFilter-梦开始的地方"><a href="#1-AuthenticationFilter-梦开始的地方" class="headerlink" title="1.AuthenticationFilter(梦开始的地方)"></a><strong>1.AuthenticationFilter(梦开始的地方)</strong></h2><ul><li>认证过滤器，每当容器支持一种登录方式的时候，就需要在主链中添加一种该组件。就是上面流程图绿色模块的过滤器链。</li></ul><p>只要其中一个登录过滤器链通过，其它的相同类型的过滤器直接通过，不再检验。这也好理解，因为我们登录账号的时候只需要使用一种登录方式进行检验就行。</p><p>例如：<br>BasicAuthenticationFilter过滤器：登录方式默认弹出一个输入弹窗<br>UsernamePasswordAuthenticationFilter过滤器：为最常常见的账号密码登录方式<br>除此之外还有邮箱登录、短信登录等等。<br><strong>本文主要讲解账号密码登录的方式</strong></p><h2 id="2-UsernamePasswordAuthenticationFilter"><a href="#2-UsernamePasswordAuthenticationFilter" class="headerlink" title="2.UsernamePasswordAuthenticationFilter"></a><strong>2.UsernamePasswordAuthenticationFilter</strong></h2><ul><li>将前端传回来的usernamepassword打包，传给providerManager处理。</li></ul><pre><code>public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {    //这个类设置许多的默认值，后期都可以修改为我们需要的    //在这里默认账号为username，密码为password，默认请求路径和方式分别为/login,POST    public static final String SPRING_SECURITY_FORM_USERNAME_KEY = "username";    public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = "password";    //默认的登录访问地址    private static final AntPathRequestMatcher DEFAULT_ANT_PATH_REQUEST_MATCHER = new AntPathRequestMatcher("/login",            "POST");    private String usernameParameter = SPRING_SECURITY_FORM_USERNAME_KEY;    private String passwordParameter = SPRING_SECURITY_FORM_PASSWORD_KEY;    //仅仅接受post请求    private boolean postOnly = true;    public UsernamePasswordAuthenticationFilter() {        super(DEFAULT_ANT_PATH_REQUEST_MATCHER);    }    public UsernamePasswordAuthenticationFilter(AuthenticationManager authenticationManager) {        super(DEFAULT_ANT_PATH_REQUEST_MATCHER, authenticationManager);    }    //接受request请求 和 response响应    @Override    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)            throws AuthenticationException {            //调用了两个属性进行判断是否为post请求        if (this.postOnly &amp;&amp; !request.getMethod().equals("POST")) {            throw new AuthenticationServiceException("Authentication method not supported: " + request.getMethod());        }        //获取用户名和密码        String username = obtainUsername(request);        username = (username != null) ? username : "";        username = username.trim();        String password = obtainPassword(request);        password = (password != null) ? password : "";        //构造UsernamePasswordAuthenticationToken对象        UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);        //为details属性赋值        setDetails(request, authRequest);        // 调用authenticate方法进行校验，AuthenticationManager接口的ProviderManager实现类进行校验        return this.getAuthenticationManager().authenticate(authRequest);    }1234567891011121314151617181920212223242526272829303132333435363738394041424344</code></pre><p>构造UsernamePasswordAuthenticationToken对象<br>传入获取到的用户名和密码，而用户名对应UPAT对象中的principal属性，而密码对应credentials属性。</p><pre><code>public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken {    private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;    private final Object principal;    private Object credentials;    //UsernamePasswordAuthenticationToken对象构造器    public UsernamePasswordAuthenticationToken(Object principal, Object credentials) {        super(null);        this.principal = principal;        this.credentials = credentials;        //默认指定不应信任身份验证令牌        setAuthenticated(false);    }    //代码省略    //。。。。    //。。。。123456789101112131415161718</code></pre><h2 id="3-AuthenticationManager是用来管理AuthenticationProvider的接口"><a href="#3-AuthenticationManager是用来管理AuthenticationProvider的接口" class="headerlink" title="3.AuthenticationManager是用来管理AuthenticationProvider的接口"></a><strong>3.AuthenticationManager是用来管理AuthenticationProvider的接口</strong></h2><ul><li>AuthenticationManager是一个用来处理身份验证请求的顶级接口，它自己不直接处理认证请求，而是委托给其所配置的Authentication，AuthenticationManager的实现有很多，通常使用<strong>ProviderManager</strong>对认证请求链进行管理。</li></ul><p>通常，一个 AuthenticationManager（或更常见的一个 AuthenticationProvider）将在成功进行身份验证之后返回一个不变的身份验证令牌，在这种情况下，令牌可以安全地返回 true此方法。返回true将提高性能，因为AuthenticationManager不再需要为每个请求调用。</p><pre><code>//AuthenticationManager接口public interface AuthenticationManager {    Authentication authenticate(Authentication var1) throws AuthenticationException;}//AuthenticationProvider接口public interface AuthenticationProvider {    Authentication authenticate(Authentication var1) throws AuthenticationException;i    boolean supports(Class&lt;?&gt; var1);}1234567891011</code></pre><p><strong>ProviderManager实现类</strong></p><ul><li>ProviderManager主要是对AuthenticationProvider链进项管理</li></ul><p>通过查找后进入，然后使用ctrl+H组合键查看它的继承关系，找到ProviderManager实现类，它实现了AuthenticationManager接口，它有个重要的authenticate方法。主要是根据传入的token遍历容器中的所有的provider，找到对应的适配器，并调用适配器去处理当前token。</p><p>如果有多个AuthenticationProvider支持传递的 Authentication对象，则第一个能够成功验证该Authentication对象的对象将确定 result，从而覆盖AuthenticationException 早期支持AuthenticationProviders抛出的任何可能（提高性能）。验证成功后，AuthenticationProvider将不会尝试后续的。如果通过任何支持均未通过身份验证， AuthenticationProvider则将抛出最后一个抛出的错误 AuthenticationException。</p><pre><code>    public Authentication authenticate(Authentication authentication) throws AuthenticationException {    //代码省略    //。。。。    //。。。。。         //整个过程主要就是确定用户当前是登录哪种登录方式而使用对于的登录过滤器进行验证        //迭代多个AuthenticationProvider对象（登录验证过滤器）        for (AuthenticationProvider provider : getProviders()) {            //注意这个supports方法            if (!provider.supports(toTest)) {                continue;            }            if (logger.isTraceEnabled()) {                logger.trace(LogMessage.format("Authenticating request with %s (%d/%d)",                        provider.getClass().getSimpleName(), ++currentPosition, size));            }            try {                //注意这个authenticate方法                //确定Authentcation对象                result = provider.authenticate(authentication);                if (result != null) {                    copyDetails(authentication, result);                    break;                }            }            catch (AccountStatusException | InternalAuthenticationServiceException ex) {                prepareException(ex, authentication);                // SEC-546: Avoid polling additional providers if auth failure is due to                // invalid account status                throw ex;    //代码省略    //。。。。    //。。。。    }    /*    ProviderManager中有一个List用来存储定义的AuthenticationProvider认证实现类    也可以认为是一个认证处理器链来支持同一个应用中的多个不同身份认证机制    ProviderManager将会根据顺序来进行验证    */    public List&lt;AuthenticationProvider&gt; getProviders() {        return this.providers;    }123456789101112131415161718192021222324252627282930313233343536373839404142</code></pre><h2 id="4-AuthenticationProvider接口"><a href="#4-AuthenticationProvider接口" class="headerlink" title="4.AuthenticationProvider接口"></a><strong>4.AuthenticationProvider接口</strong></h2><ul><li>就是进行身份认证的接口，它里面有两个方法：authenticate认证方法和supports是否支持某种类型token的方法，通过ctrl+h查看继承关系，找到AbstractUserDetailsAuthenticationProvider抽象类，它实现了AuthenticationProvider接口。</li></ul><p>AbstractUserDetailsAuthenticationProvider抽象类</p><ul><li>用户认证 和 判断token认证的方法</li></ul><p>工作流程：先看缓存中是否有用户，如果没有，调用自实现去找，找到之后，做了后置检测，检测4个标志是否为true，并且判断容器中是否有passwordencoder，如果有，使用加密匹配规则，如果没有，直接用字符串匹配前端以及数据库中的密码。</p><p><strong>authenticate认证方法</strong></p><pre><code>@Overridepublic Authentication authenticate(Authentication authentication) throws AuthenticationException {        Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication,                () -&gt; this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.onlySupports",                        "Only UsernamePasswordAuthenticationToken is supported"));        String username = determineUsername(authentication);        boolean cacheWasUsed = true;        UserDetails user = this.userCache.getUserFromCache(username);        //如果从缓存中没有获取到UserDetails        //表示没有登录成功或记录        //那么它调用retrieveUser方法来获取用户信息UserDetails,同时捕获异常        if (user == null) {            cacheWasUsed = false;            try {            //这里的retrieveUser是抽象方法，主要是关注它的子类实现。            //等下会讲，先观察UserDetails                user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);                //代码省略（下面会将）。。。                //........。。                //...........        return createSuccessAuthentication(principalToReturn, authentication, user);}12345678910111213141516171819202122</code></pre><p><strong>supports是否支持某种类型token的方法</strong></p><pre><code>public boolean supports(Class&lt;?&gt; aClass) {   //返回UsernamePasswordAuthenticationToken   //说明它是支持UsernamePasswordAuthenticationToken类型的AuthenticationProvider    return UsernamePasswordAuthenticationToken.class.isAssignableFrom(aClass);}12345</code></pre><p><strong>UserDetails接口</strong></p><ul><li>用户信息UserDetails是个接口，当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的，而在实际项目中账号和密码都是从数据库中查询出来的，所以我们要通过自定义逻辑控制认证逻辑，只需要实现 UserDetailsService 接口即可，点进去查看它的该接口的信息。</li></ul><p>发现该封装类一共就7个方法，都是用来表示用户的认证信息的，从上往下，依次为，用户权限列表，密码，用户名，账号本身是否过期，是否锁定，本次登录凭证是否过期，账号本身是否可用。基本上封装了大多数系统所需要的认证信息。如果系统中没有需要验证账号本身是否过期的业务，那么也可以将这些字段永远设置为真，如果为假，那么则认证失败。</p><pre><code>public interface UserDetails extends Serializable {    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();//在集合中获取所有权限    String getPassword();//获取密码    String getUsername();//获取用户名    boolean isAccountNonExpired();//是否账号过期    boolean isAccountNonLocked();//是否账号被锁定    boolean isCredentialsNonExpired();//凭证（密码）是否过期    boolean isEnabled();//是否可用}123456789</code></pre><p>继续观察刚才AbstractUserDetailsAuthenticationProvider抽象类的authenticate认证方法中的省略代码，有三个重要的检验用户登录方法和一个检验成功的回调方法：</p><ol><li>preAuthenticationChecks.check（）</li><li>additionalAuthenticationChecks（）</li><li>postAuthenticationChecks（）</li><li>createSuccessAuthentication（）</li></ol><pre><code>//。。。。。。。。。。。接上        try {            //preAuthenticationChecks.check（）方法:检验3个boolean方法            this.preAuthenticationChecks.check(user);            //additionalAuthenticationChecks（）：用于检测账号和密码（可以点进去查看）            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);        }                catch (AuthenticationException ex) {            if (!cacheWasUsed) {                throw ex;            }            cacheWasUsed = false;            user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);            this.preAuthenticationChecks.check(user);            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);        }        //postAuthenticationChecks（）：检验1个Boolean        this.postAuthenticationChecks.check(user);        if (!cacheWasUsed) {            this.userCache.putUserInCache(user);        }        Object principalToReturn = user;        if (this.forcePrincipalAsString) {            principalToReturn = user.getUsername();        }        //如果上面的检查都通过并且没有异常，表示认证通过，会调用下面的方法：     return createSuccessAuthentication(principalToReturn, authentication, user);    }12345678910111213141516171819202122232425262728</code></pre><p><strong>preAuthenticationChecks预检查</strong>，在最下面的内部类DefaultPreAuthenticationChecks中可以看到，它会检查上面提到的三个boolean方法，即检查账户未锁定、账户可用、账户未过期，如果上面的方法只要有一个返回false，就会抛出异常，那么认证就会失败。下面还有个<strong>postAuthenticationChecks.check(user)后检查</strong>，在最下面的DefaultPostAuthenticationChecks内部类中可以看到，它会检查密码未过期，如果为false就会抛出异常</p><pre><code>        @Override        public void check(UserDetails user) {            if (!user.isAccountNonLocked()) {                AbstractUserDetailsAuthenticationProvider.this.logger                        .debug("Failed to authenticate since user account is locked");                throw new LockedException(AbstractUserDetailsAuthenticationProvider.this.messages                        .getMessage("AbstractUserDetailsAuthenticationProvider.locked", "User account is locked"));            }            if (!user.isEnabled()) {                AbstractUserDetailsAuthenticationProvider.this.logger                        .debug("Failed to authenticate since user account is disabled");                throw new DisabledException(AbstractUserDetailsAuthenticationProvider.this.messages                        .getMessage("AbstractUserDetailsAuthenticationProvider.disabled", "User is disabled"));            }            if (!user.isAccountNonExpired()) {                AbstractUserDetailsAuthenticationProvider.this.logger                        .debug("Failed to authenticate since user account has expired");                throw new AccountExpiredException(AbstractUserDetailsAuthenticationProvider.this.messages                        .getMessage("AbstractUserDetailsAuthenticationProvider.expired", "User account has expired"));            }        }        @Override        public void check(UserDetails user) {            if (!user.isCredentialsNonExpired()) {                AbstractUserDetailsAuthenticationProvider.this.logger                        .debug("Failed to authenticate since user account credentials have expired");                throw new CredentialsExpiredException(AbstractUserDetailsAuthenticationProvider.this.messages                        .getMessage("AbstractUserDetailsAuthenticationProvider.credentialsExpired",                                "User credentials have expired"));            }        }123456789101112131415161718192021222324252627282930313233</code></pre><p><strong>additionalAuthenticationChecks()</strong> 是附加检查，允许子类对UserDetails给定的身份验证请求执行返回（或缓存）返回的任何其他检查，它主要是检查用户密码的正确性，如果密码为空或者错误都会抛出异常。通常，子类至少会Authentication.getCredentials()与 进行比较UserDetails.getPassword()。如果需要自定义逻辑来比较UserDetails和/或的 其他属性UsernamePasswordAuthenticationToken，则这些属性也应出现在此方法中。</p><pre><code>    protected void additionalAuthenticationChecks(UserDetails userDetails,            UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {        if (authentication.getCredentials() == null) {            this.logger.debug("Failed to authenticate since no credentials provided");            throw new BadCredentialsException(this.messages                    .getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));        }        String presentedPassword = authentication.getCredentials().toString();        if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {            this.logger.debug("Failed to authenticate since password does not match stored value");            throw new BadCredentialsException(this.messages                    .getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));        }    }1234567891011121314</code></pre><p><strong>createSuccessAuthentication（）</strong> 如果全部检验通过，创建一个成功的Authentication对象，查看该方法的方法体，发现是通过构造方法实例化对象<strong>UsernamePasswordAuthenticationToken</strong>时，调用的是三个参数的构造方法，返回一个成功的认证令牌。<br>三个参数说明：</p><ol><li>principal：应该是返回对象的主体（由isForcePrincipalAsString()方法定义）</li><li>authentication：提交给提供商进行验证。需要Authentication对象的密码和其它身份信息</li><li>user：需要UserDetails对象的集合中获取所有权限</li></ol><p><strong>UsernamePasswordAuthenticationToken</strong>继承<strong>AbstractAuthenticationToken</strong>实现Authentication<br>所以当在页面中输入用户名和密码之后首先会进入到<strong>UsernamePasswordAuthenticationToken</strong>验证(Authentication)，然后生成的Authentication会被交由<strong>AuthenticationManager</strong>来进行管理而<strong>AuthenticationManager</strong>管理一系列的<strong>AuthenticationProvider</strong>，而每一个<strong>Provider</strong>都会通–<strong>UserDetailsService</strong>和<strong>UserDetail</strong>来返回一个以<strong>UsernamePasswordAuthenticationToken</strong>实现的带用户名和密码以及权限的Authentication。<br>在下面的代码中通过new出一个新UsernamePasswordAuthenticationToken 的对象并使用setDetails(authentication.getDetails())：向新的对象设置authentication对象的有关身份验证请求的其他详细信息，这些可能是IP地址，证书序列号等。到这里就表示认证通过了。</p><pre><code>    protected Authentication createSuccessAuthentication(Object principal, Authentication authentication,            UserDetails user) {        UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(        principal,        authentication.getCredentials(),        this.authoritiesMapper.mapAuthorities(user.getAuthorities()));        result.setDetails(authentication.getDetails());        this.logger.debug("Authenticated user");        return result;    }1234567891011</code></pre><h2 id="5-DaoAuthenticationProvider类"><a href="#5-DaoAuthenticationProvider类" class="headerlink" title="5.DaoAuthenticationProvider类"></a><strong>5.DaoAuthenticationProvider类</strong></h2><ul><li>最终查询数据库的类，收集容器中userdetail的实现，调用loaduserbyusername方法，返回数据库中的用户信息。</li></ul><p>下面是获取用户信息<strong>UserDetails的retrieveUser</strong>方法</p><ol><li>参数：username -要检索的用户名 | authentication-身份验证请求，子类可能 需要执行基于绑定的检索UserDetails</li><li>返回值：用户信息（从不null-应当抛出异常）</li></ol><p>它是调用了getUserDetailsService先获取到UserDetailsService对象，通过调用UserDetailsService对象的loadUserByUsername方法根据对应的username用户名来获取用户信息UserDetails</p><pre><code>@Override    protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication)            throws AuthenticationException {        prepareTimingAttackProtection();        try {        //获取用户信息UserDetails            UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);            if (loadedUser == null) {                throw new InternalAuthenticationServiceException(                        "UserDetailsService returned null, which is an interface contract violation");            }            return loadedUser;        }        //代码省略        //。。。。        //。。。。。12345678910111213141516</code></pre><p>找到UserDetailsService，发现它是一个接口，查看继承关系，有很多实现，都是spring-security提供的实现类，并不满足我们的需要，我们想自己制定获取用户信息的逻辑，所以我们可以实现这个接口。比如从我们的数据库中查找用户信息</p><pre><code>public interface UserDetailsService {    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;}1234</code></pre><p><strong>覆盖安全框架的默认登录， 只要继承 UserDetailsService接口并被容器监控到，就可以覆盖掉默认方法。下面为自定义登录的实现类。</strong></p><pre><code>@Service@Slf4jpublic class UserDeatailServiceImpl implements UserDetailsService {    @Autowired    private UsersMapper usersMapper;    @Override    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {        log.debug("登入的用户：{}",s);        Users users=new Users();        users.setUsername(s);        Users loginUser = usersMapper.selectOne(users);        if (loginUser==null){            throw new PassPortException("用户名或者密码不匹配");        }        //默认全部为true保证通过        return new User(loginUser.getUsername(), loginUser.getPassword(),                true, true, true, true,                //身份权限名可以自定义，按照这里写比较规范                AuthorityUtils.commaSeparatedStringToAuthorityList("ROLE_USER,ROLE_ADMIN"));    }}12345678910111213141516171819202122232425</code></pre><h2 id="6-AbstractAuthenticationProcessingFilter"><a href="#6-AbstractAuthenticationProcessingFilter" class="headerlink" title="6.AbstractAuthenticationProcessingFilter"></a><strong>6.AbstractAuthenticationProcessingFilter</strong></h2><ul><li>所有认证过滤器的父类，将所有认证的逻辑共有的部分抽取到父类，前置检测当前请求是否有当前过滤器处理的，后置判断当前认证是否成功：</li></ul><ol><li>如果成功，那么使用认证成功处理器处理，并且将登陆成功的依据交给rememberMeService。</li><li>如果失败（登录流程一次）调用登录失败处理器，并且清空securityContext，再调用rememberMeService的loginfail</li></ol><p><strong>接下来看它的源代码</strong></p><pre><code>private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain)            throws IOException, ServletException {        //第三种情况：返回Null，表示身份验证过程未完成。        if (!requiresAuthentication(request, response)) {            chain.doFilter(request, response);            return;        }        try {            //UsernamePasswordAuthenticationFilter类的attemptAuthentication方法继承了AbstractAuthenticationProcessingFilter类            //返回一个经过身份验证的用户令牌；如果身份验证不完整，则返回null。            //或是 抛出异常AuthenticationException：表示身份验证失败。            Authentication authenticationResult = attemptAuthentication(request, response);            //第三种情况：返回Null，表示身份验证过程未完成。            if (authenticationResult == null) {                return;            }            this.sessionStrategy.onAuthentication(authenticationResult, request, response);            if (this.continueChainBeforeSuccessfulAuthentication) {                chain.doFilter(request, response);            }            //第一种情况：一个认证返回的对象，调用登录成功的逻辑方法            successfulAuthentication(request, response, chain, authenticationResult);        }        catch (InternalAuthenticationServiceException failed) {            this.logger.error("An internal error occurred while trying to authenticate the user.", failed);            //第二种情况：验证中出现一次，调用登录失败的逻辑的方法            unsuccessfulAuthentication(request, response, failed);        }        catch (AuthenticationException ex) {            //第二种情况：验证中出现一次，调用登录失败的逻辑的方法            unsuccessfulAuthentication(request, response, ex);        }    }    //登录成功的逻辑方法    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain,            Authentication authResult) throws IOException, ServletException {            //从当前执行的线程中获取对象信息并更改当前已认证的主体        SecurityContextHolder.getContext().setAuthentication(authResult);        if (this.logger.isDebugEnabled()) {            this.logger.debug(LogMessage.format("Set SecurityContextHolder to %s", authResult));        }        //将登陆成功的依据交给rememberMeService        this.rememberMeServices.loginSuccess(request, response, authResult);        if (this.eventPublisher != null) {            this.eventPublisher.publishEvent(new InteractiveAuthenticationSuccessEvent(authResult, this.getClass()));        }        //成功处理器，可以自定义        this.successHandler.onAuthenticationSuccess(request, response, authResult);    }     //登录失败的逻辑方法    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,            AuthenticationException failed) throws IOException, ServletException {        //清空securityContext        SecurityContextHolder.clearContext();        this.logger.trace("Failed to process authentication request", failed);        this.logger.trace("Cleared SecurityContextHolder");        this.logger.trace("Handling authentication failure");        //记住我的功能 表示保存失败        this.rememberMeServices.loginFail(request, response);        //失败处理器，可以自定义        this.failureHandler.onAuthenticationFailure(request, response, failed);    }12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364</code></pre><h2 id="7-个人总结"><a href="#7-个人总结" class="headerlink" title="7. 个人总结"></a><strong>7. 个人总结</strong></h2><p><strong>1.认证的检验的简单流程图</strong></p><p><img src="https://p3-tt.byteimg.com/origin/pgc-image/85f6df66ee0e44a1a6d378211454c191?from=pc" alt="全网最详解Spring Security登录原理带你看源代码"></p><p><strong>2.一些类的讲解</strong></p><p><img src="https://p1-tt.byteimg.com/origin/pgc-image/c1d05e82420848d5b17d345cb06025fe?from=pc" alt="全网最详解Spring Security登录原理带你看源代码"></p><p><strong>3.大概代码流程图</strong></p><p><img src="https://p1-tt.byteimg.com/origin/pgc-image/4c4e152a1d904c32beb7456ebdaab91d?from=pc" alt="全网最详解Spring Security登录原理带你看源代码"></p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet 3.0 新特性详解</title>
      <link href="2021/01/30/servlet-3-0/"/>
      <url>2021/01/30/servlet-3-0/</url>
      
        <content type="html"><![CDATA[<h1 id="Servlet-3-0-新特性详解"><a href="#Servlet-3-0-新特性详解" class="headerlink" title="Servlet 3.0 新特性详解"></a>Servlet 3.0 新特性详解</h1><p>Servlet 3.0 作为 Java EE 6 规范体系中一员，随着 Java EE 6 规范一起发布。该版本在前一版本（Servlet 2.5）的基础上提供了若干新特性用于简化 Web 应用的开发和部署。其中有几项特性的引入让开发者感到非常兴奋，同时也获得了 Java 社区的一片赞誉之声：</p><ol><li>异步处理支持：有了该特性，Servlet 线程不再需要一直阻塞，直到业务处理完毕才能再输出响应，最后才结束该 Servlet 线程。在接收到请求之后，Servlet 线程可以将耗时的操作委派给另一个线程来完成，自己在不生成响应的情况下返回至容器。针对业务处理较耗时的情况，这将大大减少服务器资源的占用，并且提高并发处理速度。</li><li>新增的注解支持：该版本新增了若干注解，用于简化 Servlet、过滤器（Filter）和监听器（Listener）的声明，这使得 web.xml 部署描述文件从该版本开始不再是必选的了。</li><li>可插性支持：熟悉 Struts2 的开发者一定会对其通过插件的方式与包括 Spring 在内的各种常用框架的整合特性记忆犹新。将相应的插件封装成 JAR 包并放在类路径下，Struts2 运行时便能自动加载这些插件。现在 Servlet 3.0 提供了类似的特性，开发者可以通过插件的方式很方便的扩充已有 Web 应用的功能，而不需要修改原有的应用。</li></ol><p>下面我们将逐一讲解这些新特性，通过下面的学习，读者将能够明晰了解 Servlet 3.0 的变化，并能够顺利使用它进行日常的开发工作。</p><h2 id="异步处理支持"><a href="#异步处理支持" class="headerlink" title="异步处理支持"></a>异步处理支持</h2><p>Servlet 3.0 之前，一个普通 Servlet 的主要工作流程大致如下：首先，Servlet 接收到请求之后，可能需要对请求携带的数据进行一些预处理；接着，调用业务接口的某些方法，以完成业务处理；最后，根据处理的结果提交响应，Servlet 线程结束。其中第二步的业务处理通常是最耗时的，这主要体现在数据库操作，以及其它的跨网络调用等，在此过程中，Servlet 线程一直处于阻塞状态，直到业务方法执行完毕。在处理业务的过程中，Servlet 资源一直被占用而得不到释放，对于并发较大的应用，这有可能造成性能的瓶颈。对此，在以前通常是采用私有解决方案来提前结束 Servlet 线程，并及时释放资源。</p><p>Servlet 3.0 针对这个问题做了开创性的工作，现在通过使用 Servlet 3.0 的异步处理支持，之前的 Servlet 处理流程可以调整为如下的过程：首先，Servlet 接收到请求之后，可能首先需要对请求携带的数据进行一些预处理；接着，Servlet 线程将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，此时 Servlet 还没有生成响应数据，异步线程处理完业务以后，可以直接生成响应数据（异步线程拥有 ServletRequest 和 ServletResponse 对象的引用），或者将请求继续转发给其它 Servlet。如此一来， Servlet 线程不再是一直处于阻塞状态以等待业务逻辑的处理，而是启动异步线程之后可以立即返回。</p><p>异步处理特性可以应用于 Servlet 和过滤器两种组件，由于异步处理的工作模式和普通工作模式在实现上有着本质的区别，因此默认情况下，Servlet 和过滤器并没有开启异步处理特性，如果希望使用该特性，则必须按照如下的方式启用：</p><ol><li><p>对于使用传统的部署描述文件 (web.xml) 配置 Servlet 和过滤器的情况，Servlet 3.0 为 <servlet> 和 <filter> 标签增加了 <async-supported> 子标签，该标签的默认取值为 false，要启用异步处理支持，则将其设为 true 即可。以 Servlet 为例，其配置方式如下所示：</async-supported></filter></servlet></p><pre class="line-numbers language-java"><code class="language-java"><span class="token operator">&lt;</span>servlet<span class="token operator">></span>     <span class="token operator">&lt;</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>DemoServlet<span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span>name<span class="token operator">></span>     <span class="token operator">&lt;</span>servlet<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">></span>footmark<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>Demo Servlet<span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">-</span><span class="token keyword">class</span><span class="token operator">></span>     <span class="token operator">&lt;</span>async<span class="token operator">-</span>supported<span class="token operator">></span><span class="token boolean">true</span><span class="token operator">&lt;</span><span class="token operator">/</span>async<span class="token operator">-</span>supported<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>servlet<span class="token operator">></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对于使用 Servlet 3.0 提供的 @WebServlet 和 @WebFilter 进行 Servlet 或过滤器配置的情况，这两个注解都提供了 asyncSupported 属性，默认该属性的取值为 false，要启用异步处理支持，只需将该属性设置为 true 即可。以 @WebFilter 为例，其配置方式如下所示：</p></li></ol><pre><code>@WebFilter(urlPatterns = "/demo",asyncSupported = true) public class DemoFilter implements Filter{...} </code></pre><p>一个简单的模拟异步处理的 Servlet 示例如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token string">"/demo"</span><span class="token punctuation">,</span> asyncSupported <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncDemoServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> HttpServletResponse resp<span class="token punctuation">)</span>    <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ServletException <span class="token punctuation">{</span>        resp<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PrintWriter out <span class="token operator">=</span> resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"进入Servlet的时间："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//在子线程中执行业务调用，并由其负责输出响应，主线程退出</span>        AsyncContext ctx <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">startAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Executor</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"结束Servlet的时间："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Executor</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AsyncContext ctx <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Executor</span><span class="token punctuation">(</span>AsyncContext ctx<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ctx <span class="token operator">=</span> ctx<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//等待十秒钟，以模拟业务方法的执行</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            PrintWriter out <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"业务处理完毕的时间："</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ctx<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，Servlet 3.0 还为异步处理提供了一个监听器，使用 AsyncListener 接口表示。它可以监控如下四种事件：</p><ol><li>异步线程开始时，调用 AsyncListener 的 onStartAsync(AsyncEvent event) 方法；</li><li>异步线程出错时，调用 AsyncListener 的 onError(AsyncEvent event) 方法；</li><li>异步线程执行超时，则调用 AsyncListener 的 onTimeout(AsyncEvent event) 方法；</li><li>异步执行完毕时，调用 AsyncListener 的 onComplete(AsyncEvent event) 方法；</li></ol><p>要注册一个 AsyncListener，只需将准备好的 AsyncListener 对象传递给 AsyncContext 对象的 addListener() 方法即可，如下所示：</p><pre class="line-numbers language-java"><code class="language-java">AsyncContext ctx <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">startAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ctx<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AsyncListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onComplete</span><span class="token punctuation">(</span>AsyncEvent asyncEvent<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 做一些清理工作或者其他</span>    <span class="token punctuation">}</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="新增的注解支持"><a href="#新增的注解支持" class="headerlink" title="新增的注解支持"></a>新增的注解支持</h2><p>Servlet 3.0 的部署描述文件 web.xml 的顶层标签 <web-app> 有一个 metadata-complete 属性，该属性指定当前的部署描述文件是否是完全的。如果设置为 true，则容器在部署时将只依赖部署描述文件，忽略所有的注解（同时也会跳过 web-fragment.xml 的扫描，亦即禁用可插性支持，具体请看后文关于 [可插性支持](<a href="http://www.ibm.com/#">http://www.ibm.com/#</a>_ 可插性支持)的讲解）；如果不配置该属性，或者将其设置为 false，则表示启用注解支持（和可插性支持）。</web-app></p><h3 id="WebServlet"><a href="#WebServlet" class="headerlink" title="@WebServlet"></a>@WebServlet</h3><p>@WebServlet 用于将一个类声明为 Servlet，该注解将会在部署时被容器处理，容器将根据具体的属性配置将相应的类部署为 Servlet。该注解具有下表给出的一些常用属性（以下所有属性均为可选属性，但是 vlaue 或者 urlPatterns 通常是必需的，且二者不能共存，如果同时指定，通常是忽略 value 的取值）：</p><p><strong>表 1. @WebServlet 主要属性列表</strong></p><table><thead><tr><th><strong>属性名</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>String</td><td>指定 Servlet 的 name 属性，等价于 <servlet-name>。如果没有显式指定，则该 Servlet 的取值即为类的全限定名。</servlet-name></td></tr><tr><td>value</td><td>String[]</td><td>该属性等价于 urlPatterns 属性。两个属性不能同时使用。</td></tr><tr><td>urlPatterns</td><td>String[]</td><td>指定一组 Servlet 的 URL 匹配模式。等价于 <url-pattern> 标签。</url-pattern></td></tr><tr><td>loadOnStartup</td><td>int</td><td>指定 Servlet 的加载顺序，等价于 <load-on-startup> 标签。</load-on-startup></td></tr><tr><td>initParams</td><td>WebInitParam[]</td><td>指定一组 Servlet 初始化参数，等价于 <init-param> 标签。</init-param></td></tr><tr><td>asyncSupported</td><td>boolean</td><td>声明 Servlet 是否支持异步操作模式，等价于 <async-supported> 标签。</async-supported></td></tr><tr><td>description</td><td>String</td><td>该 Servlet 的描述信息，等价于 <description> 标签。</description></td></tr><tr><td>displayName</td><td>String</td><td>该 Servlet 的显示名，通常配合工具使用，等价于 <display-name> 标签。</display-name></td></tr></tbody></table><p>下面是一个简单的示例：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"/simple"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> asyncSupported <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>     loadOnStartup <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"SimpleServlet"</span><span class="token punctuation">,</span> displayName <span class="token operator">=</span> <span class="token string">"ss"</span><span class="token punctuation">,</span>     initParams <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@WebInitParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"username"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span><span class="token punctuation">{</span> … <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如此配置之后，就可以不必在 web.xml 中配置相应的 <servlet> 和 <servlet-mapping> 元素了，容器会在部署时根据指定的属性将该类发布为 Servlet。它的等价的 web.xml 配置形式如下：</servlet-mapping></servlet></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>display-name</span><span class="token punctuation">></span></span>ss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>display-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>SimpleServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>footmark.servlet.SimpleServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>-1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>async-supported</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>async-supported</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>username<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>tom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>SimpleServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/simple<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="WebInitParam"><a href="#WebInitParam" class="headerlink" title="@WebInitParam"></a>@WebInitParam</h3><p>该注解通常不单独使用，而是配合 @WebServlet 或者 @WebFilter 使用。它的作用是为 Servlet 或者过滤器指定初始化参数，这等价于 web.xml 中 <servlet> 和 <filter> 的 <init-param> 子标签。@WebInitParam 具有下表给出的一些常用属性：</init-param></filter></servlet></p><p><strong>表 2. @WebInitParam 的常用属性</strong></p><table><thead><tr><th><strong>属性名</strong></th><th><strong>类型</strong></th><th><strong>是否可选</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>String</td><td>否</td><td>指定参数的名字，等价于 <param-name>。</param-name></td></tr><tr><td>value</td><td>String</td><td>否</td><td>指定参数的值，等价于 <param-value>。</param-value></td></tr><tr><td>description</td><td>String</td><td>是</td><td>关于参数的描述，等价于 <description>。</description></td></tr></tbody></table><h3 id="WebFilter"><a href="#WebFilter" class="headerlink" title="@WebFilter"></a>@WebFilter</h3><p>@WebFilter 用于将一个类声明为过滤器，该注解将会在部署时被容器处理，容器将根据具体的属性配置将相应的类部署为过滤器。该注解具有下表给出的一些常用属性 ( 以下所有属性均为可选属性，但是 value、urlPatterns、servletNames 三者必需至少包含一个，且 value 和 urlPatterns 不能共存，如果同时指定，通常忽略 value 的取值 )：</p><p><strong>表 3. @WebFilter 的常用属性</strong></p><table><thead><tr><th><strong>属性名</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>filterName</td><td>String</td><td>指定过滤器的 name 属性，等价于 <filter-name></filter-name></td></tr><tr><td>value</td><td>String[]</td><td>该属性等价于 urlPatterns 属性。但是两者不应该同时使用。</td></tr><tr><td>urlPatterns</td><td>String[]</td><td>指定一组过滤器的 URL 匹配模式。等价于 <url-pattern> 标签。</url-pattern></td></tr><tr><td>servletNames</td><td>String[]</td><td>指定过滤器将应用于哪些 Servlet。取值是 @WebServlet 中的 name 属性的取值，或者是 web.xml 中 <servlet-name> 的取值。</servlet-name></td></tr><tr><td>dispatcherTypes</td><td>DispatcherType</td><td>指定过滤器的转发模式。具体取值包括：<br>ASYNC、ERROR、FORWARD、INCLUDE、REQUEST。</td></tr><tr><td>initParams</td><td>WebInitParam[]</td><td>指定一组过滤器初始化参数，等价于 <init-param> 标签。</init-param></td></tr><tr><td>asyncSupported</td><td>boolean</td><td>声明过滤器是否支持异步操作模式，等价于 <async-supported> 标签。</async-supported></td></tr><tr><td>description</td><td>String</td><td>该过滤器的描述信息，等价于 <description> 标签。</description></td></tr><tr><td>displayName</td><td>String</td><td>该过滤器的显示名，通常配合工具使用，等价于 <display-name> 标签。</display-name></td></tr></tbody></table><p>下面是一个简单的示例：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@WebFilter</span><span class="token punctuation">(</span>servletNames <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"SimpleServlet"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>filterName<span class="token operator">=</span><span class="token string">"SimpleFilter"</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LessThanSixFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如此配置之后，就可以不必在 web.xml 中配置相应的 <filter> 和 <filter-mapping> 元素了，容器会在部署时根据指定的属性将该类发布为过滤器。它等价的 web.xml 中的配置形式为：</filter-mapping></filter></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>SimpleFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>xxx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>SimpleFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>SimpleServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="WebListener"><a href="#WebListener" class="headerlink" title="@WebListener"></a>@WebListener</h3><p>该注解用于将类声明为监听器，被 @WebListener 标注的类必须实现以下至少一个接口：</p><ul><li>ServletContextListener</li><li>ServletContextAttributeListener</li><li>ServletRequestListener</li><li>ServletRequestAttributeListener</li><li>HttpSessionListener</li><li>HttpSessionAttributeListener</li></ul><p>该注解使用非常简单，其属性如下：</p><p><strong>表 4. @WebListener 的常用属性</strong></p><table><thead><tr><th><strong>属性名</strong></th><th><strong>类型</strong></th><th><strong>是否可选</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>是</td><td>该监听器的描述信息。</td></tr></tbody></table><p>一个简单示例如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@WebListener</span><span class="token punctuation">(</span><span class="token string">"This is only a demo listener"</span><span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleListener</span> <span class="token keyword">implements</span> <span class="token class-name">ServletContextListener</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如此，则不需要在 web.xml 中配置 <listener> 标签了。它等价的 web.xml 中的配置形式如下：</listener></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">></span></span>footmark.servlet.SimpleListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="MultipartConfig"><a href="#MultipartConfig" class="headerlink" title="@MultipartConfig"></a>@MultipartConfig</h3><p>该注解主要是为了辅助 Servlet 3.0 中 HttpServletRequest 提供的对上传文件的支持。该注解标注在 Servlet 上面，以表示该 Servlet 希望处理的请求的 MIME 类型是 multipart/form-data。另外，它还提供了若干属性用于简化对上传文件的处理。具体如下：</p><p><strong>表 5. @MultipartConfig 的常用属性</strong></p><table><thead><tr><th>属性名</th><th>类型</th><th>是否可选</th><th>描述</th></tr></thead><tbody><tr><td>fileSizeThreshold</td><td>int</td><td>是</td><td>当数据量大于该值时，内容将被写入文件。</td></tr><tr><td>location</td><td>String</td><td>是</td><td>存放生成的文件地址。</td></tr><tr><td>maxFileSize</td><td>long</td><td>是</td><td>允许上传的文件最大值。默认值为 -1，表示没有限制。</td></tr><tr><td>maxRequestSize</td><td>long</td><td>是</td><td>针对该 multipart/form-data 请求的最大数量，默认值为 -1，表示没有限制。</td></tr></tbody></table><h2 id="可插性支持"><a href="#可插性支持" class="headerlink" title="可插性支持"></a>可插性支持</h2><p>如果说 3.0 版本新增的注解支持是为了简化 Servlet/ 过滤器 / 监听器的声明，从而使得 web.xml 变为可选配置， 那么新增的可插性 (pluggability) 支持则将 Servlet 配置的灵活性提升到了新的高度。熟悉 Struts2 的开发者都知道，Struts2 通过插件的形式提供了对包括 Spring 在内的各种开发框架的支持，开发者甚至可以自己为 Struts2 开发插件，而 Servlet 的可插性支持正是基于这样的理念而产生的。使用该特性，现在我们可以在不修改已有 Web 应用的前提下，只需将按照一定格式打成的 JAR 包放到 WEB-INF/lib 目录下，即可实现新功能的扩充，不需要额外的配置。</p><p>Servlet 3.0 引入了称之为“Web 模块部署描述符片段”的 web-fragment.xml 部署描述文件，该文件必须存放在 JAR 文件的 META-INF 目录下，该部署描述文件可以包含一切可以在 web.xml 中定义的内容。JAR 包通常放在 WEB-INF/lib 目录下，除此之外，所有该模块使用的资源，包括 class 文件、配置文件等，只需要能够被容器的类加载器链加载的路径上，比如 classes 目录等。</p><p>现在，为一个 Web 应用增加一个 Servlet 配置有如下三种方式 ( 过滤器、监听器与 Servlet 三者的配置都是等价的，故在此以 Servlet 配置为例进行讲述，过滤器和监听器具有与之非常类似的特性 )：</p><ul><li>编写一个类继承自 HttpServlet，将该类放在 classes 目录下的对应包结构中，修改 web.xml，在其中增加一个 Servlet 声明。这是最原始的方式；</li><li>编写一个类继承自 HttpServlet，并且在该类上使用 @WebServlet 注解将该类声明为 Servlet，将该类放在 classes 目录下的对应包结构中，无需修改 web.xml 文件。</li><li>编写一个类继承自 HttpServlet，将该类打成 JAR 包，并且在 JAR 包的 META-INF 目录下放置一个 web-fragment.xml 文件，该文件中声明了相应的 Servlet 配置。web-fragment.xml 文件示例如下：</li></ul><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-fragment</span>     <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span>http://java.sun.com/xml/ns/javaee</span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span> <span class="token attr-name">version</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3.0<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://java.sun.com/xml/ns/javaee    http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd<span class="token punctuation">"</span></span>    <span class="token attr-name">metadata-complete</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>fragment<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>footmark.servlet.FragmentServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>fragment<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/fragment<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-fragment</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的示例可以看出，web-fragment.xml 与 web.xml 除了在头部声明的 XSD 引用不同之外，其主体配置与 web.xml 是完全一致的。</p><p>由于一个 Web 应用中可以出现多个 web-fragment.xml 声明文件，加上一个 web.xml 文件，加载顺序问题便成了不得不面对的问题。Servlet 规范的专家组在设计的时候已经考虑到了这个问题，并定义了加载顺序的规则。</p><p>web-fragment.xml 包含了两个可选的顶层标签，<name> 和 <ordering>，如果希望为当前的文件指定明确的加载顺序，通常需要使用这两个标签，<name> 主要用于标识当前的文件，而 <ordering> 则用于指定先后顺序。一个简单的示例如下：</ordering></name></ordering></name></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>web-fragment...</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>FragmentA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ordering</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>after</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>FragmentB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>FragmentC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>after</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>before</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>others</span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>before</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ordering</span><span class="token punctuation">></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>web-fragment</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示， <name> 标签的取值通常是被其它 web-fragment.xml 文件在定义先后顺序时引用的，在当前文件中一般用不着，它起着标识当前文件的作用。</name></p><p>在 <ordering> 标签内部，我们可以定义当前 web-fragment.xml 文件与其他文件的相对位置关系，这主要通过 <ordering> 的 <after> 和 <before> 子标签来实现的。在这两个子标签内部可以通过 <name> 标签来指定相对应的文件。比如：</name></before></after></ordering></ordering></p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>after</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>FragmentB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>FragmentC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>after</span><span class="token punctuation">></span></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以上片段则表示当前文件必须在 FragmentB 和 FragmentC 之后解析。<before> 的使用于此相同，它所表示的是当前文件必须早于 <before> 标签里所列出的 web-fragment.xml 文件。</before></before></p><p>除了将所比较的文件通过 <name> 在 <after> 和 <begin> 中列出之外，Servlet 还提供了一个简化的标签 <others>。它表示除了当前文件之外的其他所有的 web-fragment.xml 文件。该标签的优先级要低于使用 <name> 明确指定的相对位置关系。</name></others></begin></after></name></p><h2 id="ServletContext-的性能增强"><a href="#ServletContext-的性能增强" class="headerlink" title="ServletContext 的性能增强"></a>ServletContext 的性能增强</h2><p>除了以上的新特性之外，ServletContext 对象的功能在新版本中也得到了增强。现在，该对象支持在运行时动态部署 Servlet、过滤器、监听器，以及为 Servlet 和过滤器增加 URL 映射等。以 Servlet 为例，过滤器与监听器与之类似。ServletContext 为动态配置 Servlet 增加了如下方法：</p><ul><li><code>ServletRegistration.Dynamic addServlet(String servletName,Class&lt;? extends Servlet&gt; servletClass)</code></li><li><code>ServletRegistration.Dynamic addServlet(String servletName, Servlet servlet)</code></li><li><code>ServletRegistration.Dynamic addServlet(String servletName, String className)</code></li><li><t extends="" servlet=""> T createServlet(Class<t> clazz)</t></t></li><li>ServletRegistration getServletRegistration(String servletName)</li><li>Map&lt;String,? extends ServletRegistration&gt; getServletRegistrations()</li></ul><p>其中前三个方法的作用是相同的，只是参数类型不同而已；通过 createServlet() 方法创建的 Servlet，通常需要做一些自定义的配置，然后使用 addServlet() 方法来将其动态注册为一个可以用于服务的 Servlet。两个 getServletRegistration() 方法主要用于动态为 Servlet 增加映射信息，这等价于在 web.xml( 抑或 web-fragment.xml) 中使用 <servlet-mapping> 标签为存在的 Servlet 增加映射信息。</servlet-mapping></p><p>以上 ServletContext 新增的方法要么是在 ServletContextListener 的 contexInitialized 方法中调用，要么是在 ServletContainerInitializer 的 onStartup() 方法中调用。</p><p>ServletContainerInitializer 也是 Servlet 3.0 新增的一个接口，容器在启动时使用 JAR 服务 API(JAR Service API) 来发现 ServletContainerInitializer 的实现类，并且容器将 WEB-INF/lib 目录下 JAR 包中的类都交给该类的 onStartup() 方法处理，我们通常需要在该实现类上使用 @HandlesTypes 注解来指定希望被处理的类，过滤掉不希望给 onStartup() 处理的类。</p><h2 id="HttpServletRequest-对文件上传的支持"><a href="#HttpServletRequest-对文件上传的支持" class="headerlink" title="HttpServletRequest 对文件上传的支持"></a>HttpServletRequest 对文件上传的支持</h2><p>此前，对于处理上传文件的操作一直是让开发者头疼的问题，因为 Servlet 本身没有对此提供直接的支持，需要使用第三方框架来实现，而且使用起来也不够简单。如今这都成为了历史，Servlet 3.0 已经提供了这个功能，而且使用也非常简单。为此，HttpServletRequest 提供了两个方法用于从请求中解析出上传的文件：</p><ul><li>Part getPart(String name)</li><li>Collection<part> getParts()</part></li></ul><p>前者用于获取请求中给定 name 的文件，后者用于获取所有的文件。每一个文件用一个 javax.servlet.http.Part 对象来表示。该接口提供了处理文件的简易方法，比如 write()、delete() 等。至此，结合 HttpServletRequest 和 Part 来保存上传的文件变得非常简单，如下所示：</p><pre class="line-numbers language-java"><code class="language-java">Part photo <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getPart</span><span class="token punctuation">(</span><span class="token string">"photo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> photo<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"/tmp/photo.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 可以将两行代码简化为 request.getPart("photo").write("/tmp/photo.jpg") 一行。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另外，开发者可以配合前面提到的 @MultipartConfig 注解来对上传操作进行一些自定义的配置，比如限制上传文件的大小，以及保存文件的路径等。其用法非常简单，故不在此赘述了。</p><p>需要注意的是，如果请求的 MIME 类型不是 multipart/form-data，则不能使用上面的两个方法，否则将抛异常。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Servlet 3.0 的众多新特性使得 Servlet 开发变得更加简单，尤其是异步处理特性和可插性支持的出现，必将对现有的 MVC 框架产生深远影响。虽然我们通常不会自己去用 Servlet 编写控制层代码，但是也许在下一个版本的 Struts 中，您就能切实感受到这些新特性带来的实质性改变。</p><p>参考资料</p><p><strong>学习</strong></p><ul><li><a href="http://jcp.org/aboutJava/communityprocess/final/jsr315/index.html">JSR-000315 Java Servlet 3.0 规范</a>：这里除了可以下载 Servlet 3.0 的规范文档，还可以了解关于与该规范相关的一些其他信息。</li><li><a href="https://glassfish.dev.java.net/">GlassFish 项目主页</a>：可以在这里现在 GlassFish V3 版本，这是 SUN 提供的 Java EE 6 规范的参考实现。</li><li>“<a href="http://www.ibm.com/developerworks/cn/java/servlet_new/">Servlet 2.2 的新特征</a>”（developerWorks，2000 年 12 月）：讨论 Servlet 2.2 一些新的比较重要的特征，并给出了一些简单的例子来演示这些特征的用途及用法。</li><li>“<a href="http://www.ibm.com/developerworks/cn/views/java/tutorials.jsp?cv_doc_id=85168">Java Servlet 技术简介</a>”（developerWorks，2004 年 12 月）：本教程包括一个说明 servlet 基本概念的简单例子，以及一个涉及更多内容的例子，它说明如何在小型的合同管理程序中更复杂地使用 servlet。</li><li><a href="http://www.ibm.com/developerworks/apps/SendTo?bookstore=safari">技术书店</a>：浏览关于这些和其他技术主题的图书。</li><li><a href="http://www.ibm.com/developerworks/cn/java/">developerWorks Java 技术专区</a>：数百篇关于 Java 编程各个方面的文章。</li></ul><p>摘自<a href="http://www.ibm.com/developerworks/cn/java/j-lo-servlet30/">http://www.ibm.com/developerworks/cn/java/j-lo-servlet30/</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 软硬链接说明及使用</title>
      <link href="2021/01/21/linux-link/"/>
      <url>2021/01/21/linux-link/</url>
      
        <content type="html"><![CDATA[<p>软连接是linux中一个常用命令，它的功能是为某一个文件在另外一个位置建立一个同不的链接。</p><p>具体用法是：ln -s 源文件 目标文件。 </p><p>当 我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在其它的 目录下用ln命令链接（link）就可以，不必重复的占用磁盘空间。</p><p>例如：</p><pre><code>ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql</code></pre><p>这样我们就对/usr/bin目录下的mysql命令创建了软连接 </p><p>【硬连接】<br>硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><p>【软连接】<br>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p><p><strong>使用方式</strong></p><p>创建软链接</p><p>ln  -s [源文件或目录] [目标文件或目录]</p><p>例：</p><p>当前路径创建test 引向/var/www/test 文件夹 </p><pre class="line-numbers language-shell"><code class="language-shell">ln –s /var/www/test test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建/var/test 引向/var/www/test 文件夹 </p><pre class="line-numbers language-shell"><code class="language-shell">ln –s /var/www/test /var/test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除软链接</p><p>和删除普通的文件是一样的，删除都是使用rm来进行操作</p><p>例：</p><p>删除test</p><pre class="line-numbers language-shell"><code class="language-shell">rm –rf test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改软链接</p><p>ln –snf  [新的源文件或目录] [目标文件或目录]</p><p>这将会修改原有的链接地址为新的地址</p><p>例如：</p><p>创建一个软链接</p><pre class="line-numbers language-shell"><code class="language-shell">ln –s /var/www/test /var/test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改指向的新路径</p><pre class="line-numbers language-shell"><code class="language-shell">ln –snf /var/www/test1 /var/test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>常用参数：</strong></p><pre><code>　　-f : 链结时先将与 dist 同档名的档案删除　　-d : 允许系统管理者硬链结自己的目录　　-i : 在删除与 dist 同档名的档案时先进行询问　　-n : 在进行软连结时，将 dist 视为一般的档案　　-s : 进行软链结(symbolic link)　　-v : 在连结之前显示其档名　　-b : 将在链结时会被覆写或删除的档案进行备份　　-S SUFFIX : 将备份的档案都加上 SUFFIX 的字尾　　-V METHOD : 指定备份的方式　　--help : 显示辅助说明　　--version : 显示版本</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> link </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx动态添加模块 平滑升级</title>
      <link href="2021/01/21/nginx-add-module/"/>
      <url>2021/01/21/nginx-add-module/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx动态添加模块-平滑升级"><a href="#Nginx动态添加模块-平滑升级" class="headerlink" title="Nginx动态添加模块 平滑升级"></a>Nginx动态添加模块 平滑升级</h1><p>已经安装好的Nginx动态添加模块</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>　　已经安装好的Nginx，需要添加一个未被编译安装的模块，需要怎么弄呢？ 这里已安装第三方nginx-rtmp-module模块为例</p><p>　　nginx的模块是需要重新编译nginx，而不是像apache一样配置文件引用.so</p><h2 id="具体操作步骤"><a href="#具体操作步骤" class="headerlink" title="具体操作步骤"></a>具体操作步骤</h2><h3 id="（1）下载第三方扩展模块"><a href="#（1）下载第三方扩展模块" class="headerlink" title="（1）下载第三方扩展模块"></a>（1）下载第三方扩展模块</h3><p>这里已模块 nginx-rtmp-module 为例：</p><pre class="line-numbers language-shell"><code class="language-shell">[root@master ~]# cd /home/work/software/[root@master ~]# wget https://github.com/arut/nginx-rtmp-module/archive/master.zip[root@master ~]# unzip master.zip[root@master ~]# ls nginx-rtmp-module-master/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（2）查看nginx编译安装时安装了哪些模块"><a href="#（2）查看nginx编译安装时安装了哪些模块" class="headerlink" title="（2）查看nginx编译安装时安装了哪些模块"></a>（2）查看nginx编译安装时安装了哪些模块</h3><pre class="line-numbers language-shell"><code class="language-shell">[root@master ~]# /opt/nginx-1.9.5/sbin/nginx -V nginx version: nginx/1.9.5built by gcc 4.4.7 20120313 (Red Hat 4.4.7-23) (GCC) built with OpenSSL 1.0.1g 7 Apr 2014TLS SNI support enabledconfigure arguments: --prefix=/opt/nginx-1.9.5 --with-pcre=/home/work/software/pcre-8.38 --with-zlib=/home/work/software/zlib-1.2.8 --conf-path=/opt/nginx-1.9.5/conf/nginx.conf --pid-path=/opt/nginx-1.9.5/conf/nginx.pid --with-http_ssl_module --with-openssl=/home/work/software/openssl-1.0.1g --add-module=/home/work/software/headers-more-nginx-module-0.23 --add-module=/home/work/software/nginx-http-concat-master --with-http_gzip_static_module可以看出编译安装使用了--prefix=/opt/nginx-1.9.5 --with-pcre=/home/work/software/pcre-8.38 --with-zlib=/home/work/software/zlib-1.2.8 --conf-path=/opt/nginx-1.9.5/conf/nginx.conf --pid-path=/opt/nginx-1.9.5/conf/nginx.pid --with-http_ssl_module --with-openssl=/home/work/software/openssl-1.0.1g --add-module=/home/work/software/headers-more-nginx-module-0.23 --add-module=/home/work/software/nginx-http-concat-master --with-http_gzip_static_module这些模块。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（3）加入需要安装的模块"><a href="#（3）加入需要安装的模块" class="headerlink" title="（3）加入需要安装的模块"></a>（3）加入需要安装的模块</h3><p>重新编译，如这里添加–add-module=/home/work/software/nginx-rtmp-module-master</p><pre class="line-numbers language-shell"><code class="language-shell">[root@master ~]# cd /home/work/software/nginx-1.9.5     //进入到nginx之前安装的目录[root@master ~]# ./configure --prefix=/opt/nginx-1.9.5 --with-pcre=/home/work/software/pcre-8.38 --with-zlib=/home/work/software/zlib-1.2.8 --conf-path=/opt/nginx-1.9.5/conf/nginx.conf --pid-path=/opt/nginx-1.9.5/conf/nginx.pid --with-http_ssl_module --with-openssl=/home/work/software/openssl-1.0.1g --add-module=/home/work/software/headers-more-nginx-module-0.23 --add-module=/home/work/software/nginx-http-concat-master --with-http_gzip_static_module --add-module=/home/work/software/nginx-rtmp-module-master[root@master ~]# make    //注意：千万不要make install，不然真的就GG了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="（4）替换nginx二进制文件"><a href="#（4）替换nginx二进制文件" class="headerlink" title="（4）替换nginx二进制文件"></a>（4）替换nginx二进制文件</h3><pre class="line-numbers language-shell"><code class="language-shell">[root@master ~]# /etc/init.d/nginx stop　　[root@master ~]# cp /opt/nginx-1.9.5/sbin/nginx /opt/nginx-1.9.5/sbin/nginx.bak[root@master ~]# cp ./objs/nginx /opt/nginx-1.9.5/sbin/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="（5）再次确认是否安装成功"><a href="#（5）再次确认是否安装成功" class="headerlink" title="（5）再次确认是否安装成功"></a>（5）再次确认是否安装成功</h3><pre class="line-numbers language-shell"><code class="language-shell">[root@master ~]# /opt/nginx-1.9.5/sbin/nginx -V nginx version: nginx/1.9.5built by gcc 4.4.7 20120313 (Red Hat 4.4.7-23) (GCC) built with OpenSSL 1.0.1g 7 Apr 2014TLS SNI support enabledconfigure arguments: --prefix=/opt/nginx-1.9.5 --with-pcre=/home/work/software/pcre-8.38 --with-zlib=/home/work/software/zlib-1.2.8 --conf-path=/opt/nginx-1.9.5/conf/nginx.conf --pid-path=/opt/nginx-1.9.5/conf/nginx.pid --with-http_ssl_module --with-openssl=/home/work/software/openssl-1.0.1g --add-module=/home/work/software/headers-more-nginx-module-0.23 --add-module=/home/work/software/nginx-http-concat-master --with-http_gzip_static_module --add-module=/home/work/software/nginx-rtmp-module-master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此、nginx就重新编译添加模块成功了。</p><p>作者：别来无恙-</p><p>出处：<a href="https://www.cnblogs.com/yanjieli/p/10615361.html">https://www.cnblogs.com/yanjieli/p/10615361.html</a></p><p>版权：本作品采用「<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a>」许可协议进行许可。</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx+rtmp+ffmpeg搭建流媒体服务器</title>
      <link href="2021/01/21/install-nginx-rtmp-ffmpeg/"/>
      <url>2021/01/21/install-nginx-rtmp-ffmpeg/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx-rtmp-ffmpeg搭建流媒体服务器"><a href="#Nginx-rtmp-ffmpeg搭建流媒体服务器" class="headerlink" title="Nginx+rtmp+ffmpeg搭建流媒体服务器"></a>Nginx+rtmp+ffmpeg搭建流媒体服务器</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>　　nginx搭建流媒体服务需要用到 nginx-rtmp-module 模块</p><p>具体操作步骤：</p><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><h3 id="（1）下载第三方扩展模块nginx-rtmp-module"><a href="#（1）下载第三方扩展模块nginx-rtmp-module" class="headerlink" title="（1）下载第三方扩展模块nginx-rtmp-module**"></a>（1）下载第三方扩展模块nginx-rtmp-module**</h3><pre class="line-numbers language-shell"><code class="language-shell">[root@master ~]#  mkdir module && cd module        　　//创建一个存放模块的目录[root@master ~]#  wget https://github.com/arut/nginx-rtmp-module/archive/master.zip        //下载模块[root@master ~]#  unzip master.zip        　　　　　　　　//解压[root@master ~]#  ls nginx-rtmp-module-master/         //查看模块目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（2）编译安装nginx"><a href="#（2）编译安装nginx" class="headerlink" title="（2）编译安装nginx**"></a>（2）编译安装nginx**</h3><h3 id="（说明：此处由于我这边已有lnmp运行项目的环境，直接动态添加的-nginx-rtmp-module模块；-动态参加可参考：这里）"><a href="#（说明：此处由于我这边已有lnmp运行项目的环境，直接动态添加的-nginx-rtmp-module模块；-动态参加可参考：这里）" class="headerlink" title="（说明：此处由于我这边已有lnmp运行项目的环境，直接动态添加的 nginx-rtmp-module模块； 动态参加可参考：这里）"></a>（说明：此处由于我这边已有lnmp运行项目的环境，直接动态添加的 nginx-rtmp-module模块； 动态参加可参考：<a href="https://www.cnblogs.com/yanjieli/p/10615361.html">这里</a>）</h3><pre class="line-numbers language-shell"><code class="language-shell">[root@master ~]#  yum -y install pcre-devel openssl openssl-devel        //安装依赖[root@master ~]#  wget http://nginx.org/download/nginx-1.12.2.tar.gz        //下载nginx包[root@master ~]#  tar xf nginx-1.12.2.tar.gz[root@master ~]#  ./configure --prefix=/opt/nginx-1.9.5 --add-module=/root/module/nginx-rtmp-module-master --with-http_ssl_module    //编译安装nginx，并指定上面下载的模块路径[root@master ~]#  make        [root@master ~]#  make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="（3）修改nginx配置文件"><a href="#（3）修改nginx配置文件" class="headerlink" title="（3）修改nginx配置文件"></a>（3）修改nginx配置文件</h3><p>添加如下内容并重新载入配置文件</p><pre class="line-numbers language-shell"><code class="language-shell"># vim nginx.confrtmp {      server {          listen 1935;      #监听的端口号        application myapp {     #自定义的名字            live on;         }          application hls {              live on;              hls on;              hls_path /tmp/hls;               hls_fragment 1s;            hls_playlist_length 3s;         }      } }[root@master ~]#  /etc/init.d/nginx -t[root@master ~]#  /etc/init.d/nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完整nginx.conf</p><h2 id="安装ffmpeg"><a href="#安装ffmpeg" class="headerlink" title="安装ffmpeg"></a>安装ffmpeg</h2><p>ffmpeg命令参考这位朋友的文章：<a href="https://www.jianshu.com/p/049d03705a81">https://www.jianshu.com/p/049d03705a81</a></p><h3 id="（1）安装依赖"><a href="#（1）安装依赖" class="headerlink" title="（1）安装依赖"></a>（1）安装依赖</h3><pre class="line-numbers language-shell"><code class="language-shell">[root@master ~]#  yum install yasm -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（2）下载ffmpeg并安装"><a href="#（2）下载ffmpeg并安装" class="headerlink" title="（2）下载ffmpeg并安装"></a>（2）下载ffmpeg并安装</h3><pre class="line-numbers language-shell"><code class="language-shell">[root@master ~]#  git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg    //下载ffmpeg[root@master ~]#  cd ffmpeg[root@master ~]#  ./configure --prefix=/usr/local/ffmpeg[root@master ~]#  make[root@master ~]#  make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>也可以将编译好了得 ffmpeg文件拷贝到目标服务器，并建立软连接（ln  -s  /usr/local/ffmpeg/bin/ffmpeg  /usr/bin）</p></blockquote><h3 id="（3）拷贝命令到-usr-bin（方便后面调用）"><a href="#（3）拷贝命令到-usr-bin（方便后面调用）" class="headerlink" title="（3）拷贝命令到/usr/bin（方便后面调用）"></a>（3）拷贝命令到/usr/bin（方便后面调用）</h3><pre><code>[root@master ~]#  ls /usr/local/ffmpeg/        //查看安装目录生成的文件bin  include  lib  share[root@master ~]#  cp /usr/local/ffmpeg/bin/* /usr/bin/</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="（1）启用ffmpeg进行推流"><a href="#（1）启用ffmpeg进行推流" class="headerlink" title="（1）启用ffmpeg进行推流"></a>（1）启用ffmpeg进行推流</h3><pre class="line-numbers language-shell"><code class="language-shell">#测试rtsp转rtmp流[root@master ~]#  ffmpeg -rtsp_transport tcp -i rtsp://admin:14haozhan@@10.52.167.67:554/h264/ch1/sub/av_stream -acodec aac -strict experimental -ar 44100 -ac 2 -b:a 96k -r 25 -b:v 500k -s 1280*720 -f flv rtmp://10.3.52.172:1935/myapp/test2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell">[root@master ~]#  ffmpeg -i rtsp://192.168.1.175:554/11 -acodec aac -strict experimental -ar 44100 -ac 2 -b:a 96k -r 25 -b:v 500k -s 640*480 -f flv rtmp://192.168.1.11:1935/myapp/23<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell"><code class="language-shell">#测试本地视频文件转rtmp流[root@master ~]# ffmpeg -re -i /opt/test.mp4 -vcodec copy -acodec copy -b:v 800k -b:a 32k -f flv rtmp://10.52.3.172:1935/myapp/test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>-i 要处理视频文件的路径，此处地址是一个监控摄像头<br>-s 像素<br>rtmp://192.168.1.11:1935/myapp/23  说明：rtmp://IP:PORT/ myapp指nginx配置文件中自定义的，23指输出文件的名字<br>-f 强迫采用flv格式<br>别的参数参考上面那位老兄的</p></blockquote><p><a href="https://img2018.cnblogs.com/blog/1210730/201903/1210730-20190328163723868-788115261.png"><img src="https://img2018.cnblogs.com/blog/1210730/201903/1210730-20190328163723868-788115261.png" alt="img"></a></p><h3 id="（2）打开VLC-媒体—-gt-流—-gt-网络"><a href="#（2）打开VLC-媒体—-gt-流—-gt-网络" class="headerlink" title="（2）打开VLC 媒体—>流—>网络"></a>（2）打开VLC 媒体—&gt;流—&gt;网络</h3><p><a href="https://img2018.cnblogs.com/blog/1210730/201903/1210730-20190328163940470-52170983.png"><img src="https://img2018.cnblogs.com/blog/1210730/201903/1210730-20190328163940470-52170983.png" alt="img"></a></p><p> <a href="https://img2018.cnblogs.com/blog/1210730/201903/1210730-20190328170042369-1748920126.png"><img src="https://img2018.cnblogs.com/blog/1210730/201903/1210730-20190328170042369-1748920126.png" alt="img"></a></p><h3 id="（3）进入服务器查看输出的位置可以发现已生成文件"><a href="#（3）进入服务器查看输出的位置可以发现已生成文件" class="headerlink" title="（3）进入服务器查看输出的位置可以发现已生成文件"></a>（3）进入服务器查看输出的位置可以发现已生成文件</h3><pre><code># ll /tmp/hls/total 1636-rw-r--r-- 1 root root 500644 Mar 28 17:05 22-1955.ts-rw-r--r-- 1 root root 384460 Mar 28 17:05 22-1956.ts-rw-r--r-- 1 root root 413036 Mar 28 17:05 22-1957.ts-rw-r--r-- 1 root root 366036 Mar 28 17:05 22-1958.ts-rw-r--r-- 1 root root    154 Mar 28 17:05 22.m3u8</code></pre><h3 id="（4）还可以使用浏览器这样访问-http-192-168-1-11-hls-22-m3u8"><a href="#（4）还可以使用浏览器这样访问-http-192-168-1-11-hls-22-m3u8" class="headerlink" title="（4）还可以使用浏览器这样访问 http://192.168.1.11/hls/22.m3u8**"></a>（4）还可以使用浏览器这样访问 <a href="http://192.168.1.11/hls/22.m3u8">http://192.168.1.11/hls/22.m3u8</a>**</h3><p><a href="https://img2018.cnblogs.com/blog/1210730/201903/1210730-20190328214813618-1563382617.png"><img src="https://img2018.cnblogs.com/blog/1210730/201903/1210730-20190328214813618-1563382617.png" alt="img"></a> </p><p>至此就搭建完成了，至于别的操作后续再写</p><p>作者：别来无恙-</p><p>出处：<a href="https://www.cnblogs.com/yanjieli/p/10615361.html">https://www.cnblogs.com/yanjieli/p/10615361.html</a></p><p>版权：本作品采用「<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a>」许可协议进行许可。</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> rtmp </tag>
            
            <tag> ffmpeg </tag>
            
            <tag> linux - install </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>install elasticsearch</title>
      <link href="2021/01/21/install-elasticsearch/"/>
      <url>2021/01/21/install-elasticsearch/</url>
      
        <content type="html"><![CDATA[<h2 id="elasticsearch-6-8安装"><a href="#elasticsearch-6-8安装" class="headerlink" title="elasticsearch 6.8安装"></a>elasticsearch 6.8安装</h2><p><a href="https://www.elastic.co/cn/downloads/past-releases#elasticsearch">https://www.elastic.co/cn/downloads/past-releases#elasticsearch</a></p><p>选择6.8.8版本</p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.8/zip-targz.html">https://www.elastic.co/guide/en/elasticsearch/reference/6.8/zip-targz.html</a></p><p>官方文档，安装说明</p><h3 id="1、先安装java"><a href="#1、先安装java" class="headerlink" title="1、先安装java"></a>1、先安装java</h3><p><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a></p><p>选择【Linux x64 RPM Package】</p><pre class="line-numbers language-shell"><code class="language-shell">[root@host101 ~]# rpm -ivh jdk-8u251-linux-x64.rpm warning: jdk-8u251-linux-x64.rpm: Header V3 RSA/SHA256 Signature, key ID ec551f03: NOKEYPreparing...                          ################################# [100%]Updating / installing...   1:jdk1.8-2000:1.8.0_251-fcs        ################################# [100%]Unpacking JAR files...        tools.jar...        plugin.jar...        javaws.jar...        deploy.jar...        rt.jar...        jsse.jar...        charsets.jar...        localedata.jar...[root@host101 ~]# <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、下载elasticsearch软件，解压到-usr-locl目录下"><a href="#2、下载elasticsearch软件，解压到-usr-locl目录下" class="headerlink" title="2、下载elasticsearch软件，解压到/usr/locl目录下"></a>2、下载elasticsearch软件，解压到/usr/locl目录下</h3><pre class="line-numbers language-shell"><code class="language-shell">[root@host101 ~]# tar xvf elasticsearch-6.8.8.tar.gz -C /usr/local/[root@host101 ~]# cd /usr/local/[root@host101 local]# mv elasticsearch-6.8.8/ elasticsearch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3、运行elasticsearch-开启报错之旅"><a href="#3、运行elasticsearch-开启报错之旅" class="headerlink" title="3、运行elasticsearch,开启报错之旅"></a>3、运行elasticsearch,开启报错之旅</h3><h4 id="3-1-报错：不能以root用户运行"><a href="#3-1-报错：不能以root用户运行" class="headerlink" title="3.1 报错：不能以root用户运行"></a>3.1 报错：不能以root用户运行</h4><pre class="line-numbers language-shell"><code class="language-shell">[root@host101 elasticsearch]# bin/elasticsearchOpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N[2020-06-08T07:53:35,386][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler] [unknown] uncaught exception in thread [main]org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root        at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:163) ~[elasticsearch-6.8.8.jar:6.8.8]        at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:150) ~[elasticsearch-6.8.8.jar:6.8.8]        at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) ~[elasticsearch-6.8.8.jar:6.8.8]        at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) ~[elasticsearch-cli-6.8.8.jar:6.8.8]        at org.elasticsearch.cli.Command.main(Command.java:90) ~[elasticsearch-cli-6.8.8.jar:6.8.8]        at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:116) ~[elasticsearch-6.8.8.jar:6.8.8]        at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:93) ~[elasticsearch-6.8.8.jar:6.8.8]Caused by: java.lang.RuntimeException: can not run elasticsearch as root        at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:103) ~[elasticsearch-6.8.8.jar:6.8.8]        at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:170) ~[elasticsearch-6.8.8.jar:6.8.8]        at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:333) ~[elasticsearch-6.8.8.jar:6.8.8]        at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:159) ~[elasticsearch-6.8.8.jar:6.8.8]        ... 6 more<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：</p><p>添加其它用户，我新加了一个es用户，将elasticsearch目录授予es用户,启动成功。</p><pre class="line-numbers language-shell"><code class="language-shell">[root@host101 elasticsearch]# useradd es[root@host101 elasticsearch]# chown -R es:es /usr/local/elasticsearch/[root@host101 elasticsearch]#su - es[es@host101 elasticsearch]$ bin/elasticsearchOpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N[2020-06-08T08:03:17,900][INFO ][o.e.e.NodeEnvironment ] [5Viw2iF] using [1] data paths, mounts [[/ (rootfs)]], net usable_space [7.8gb], net total_space [16.9gb], types [rootfs][2020-06-08T08:03:17,904][INFO ][o.e.e.NodeEnvironment ] [5Viw2iF] heap size [1015.6mb], compressed ordinary object pointers [true][2020-06-08T08:03:17,906][INFO ][o.e.n.Node ] [5Viw2iF] node name derived from node ID [5Viw2iFFSraid8DsATRv0Q]; set [node.name] to override[2020-06-08T08:03:17,906][INFO ][o.e.n.Node ] [5Viw2iF] version[6.8.8], pid[26327], build[default/tar/2f4c224/2020-03-18T23:22:18.622755Z], OS[Linux/3.10.0-957.el7.x86_64/amd64], JVM[Oracle Corporation/OpenJDK 64-Bit Server VM/1.8.0_181/25.181-b13]............[2020-06-08T08:03:50,821][INFO ][o.e.c.s.MasterService ] [5Viw2iF] zen-disco-elected-as-master ([0] nodes joined), reason: new_master {5Viw2iF}{5Viw2iFFSraid8DsATRv0Q}{4P_TXjOBTWmK_kV3Xm88bA}{127.0.0.1}{127.0.0.1:9300}{ml.machine_memory=1907941376, xpack.installed=true, ml.max_open_jobs=20, ml.enabled=true}[2020-06-08T08:03:50,849][INFO ][o.e.c.s.ClusterApplierService] [5Viw2iF] new_master {5Viw2iF}{5Viw2iFFSraid8DsATRv0Q}{4P_TXjOBTWmK_kV3Xm88bA}{127.0.0.1}{127.0.0.1:9300}{ml.machine_memory=1907941376, xpack.installed=true, ml.max_open_jobs=20, ml.enabled=true}, reason: apply cluster state (from master [master {5Viw2iF}{5Viw2iFFSraid8DsATRv0Q}{4P_TXjOBTWmK_kV3Xm88bA}{127.0.0.1}{127.0.0.1:9300}{ml.machine_memory=1907941376, xpack.installed=true, ml.max_open_jobs=20, ml.enabled=true} committed version [1] source [zen-disco-elected-as-master ([0] nodes joined)]])[2020-06-08T08:03:51,221][INFO ][o.e.h.n.Netty4HttpServerTransport] [5Viw2iF] publish_address {127.0.0.1:9200}, bound_addresses {[::1]:9200}, {127.0.0.1:9200}[2020-06-08T08:03:51,222][INFO ][o.e.n.Node ] [5Viw2iF] started[2020-06-08T08:03:51,949][WARN ][o.e.x.s.a.s.m.NativeRoleMappingStore] [5Viw2iF] Failed to clear cache for realms [[]][2020-06-08T08:03:52,106][INFO ][o.e.l.LicenseService ] [5Viw2iF] license [25b1507f-4db2-4bdb-9f72-bf19ed92defe] mode [basic] - valid[2020-06-08T08:03:52,123][INFO ][o.e.g.GatewayService ] [5Viw2iF] recovered [0] indices into cluster_state<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-其它IP访问不到ES数据库"><a href="#3-2-其它IP访问不到ES数据库" class="headerlink" title="3.2 其它IP访问不到ES数据库"></a>3.2 其它IP访问不到ES数据库</h4><p>但默认监控的是127.0.0.1端口，其它IP访问不到ES数据库，需要修改为本机Ip 192.168.150.101</p><pre class="line-numbers language-shell"><code class="language-shell">[root@host101 config]# cd /usr/local/elasticsearch/config/[root@host101 config]# vi elasticsearch.yml 修改这个参数network.host: 192.168.150.101保存！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-重启数据库，报错"><a href="#3-3-重启数据库，报错" class="headerlink" title="3.3 重启数据库，报错"></a>3.3 重启数据库，报错</h4><pre class="line-numbers language-shell"><code class="language-shell">[es@host101 elasticsearch]$ bin/elasticsearchOpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N[2020-06-08T08:08:16,804][INFO ][o.e.e.NodeEnvironment    ] [5Viw2iF] using [1] data paths, mounts [[/ (rootfs)]], net usable_space [7.5gb], net total_space [16.9gb], types [rootfs][2020-06-08T08:08:16,823][INFO ][o.e.e.NodeEnvironment    ] [5Viw2iF] heap size [1015.6mb], compressed ordinary object pointers [true][2020-06-08T08:08:16,825][INFO ][o.e.n.Node               ] [5Viw2iF] node name derived from node ID [5Viw2iFFSraid8DsATRv0Q]; set [node.name] to override[2020-06-08T08:08:16,826][INFO ][o.e.n.Node               ] [5Viw2iF] version[6.8.8], pid[27460], build[default/tar/2f4c224/2020-03-18T23:22:18.622755Z], OS[Linux/3.10.0-957.el7.x86_64/amd64], JVM[Oracle Corporation/OpenJDK 64-Bit Server VM/1.8.0_181/25.181-b13][2020-06-08T08:08:16,826][INFO ][o.e.n.Node               ] [5Viw2iF] JVM arguments [-Xms1g, -Xmx1g, -XX:+UseConcMarkSweepGC, -XX:CMSInitiatingOccupancyFraction=75, -XX:+UseCMSInitiatingOccupancyOnly, -Des.networkaddress.cache.ttl=60, -Des.networkaddress.cache.negative.ttl=10, -XX:+AlwaysPreTouch, -Xss1m, -Djava.awt.headless=true, -Dfile.encoding=UTF-8, -Djna.nosys=true, -XX:-OmitStackTraceInFastThrow, -Dio.netty.noUnsafe=true, -Dio.netty.noKeySetOptimization=true, -Dio.netty.recycler.maxCapacityPerThread=0, -Dlog4j.shutdownHookEnabled=false, -Dlog4j2.disable.jmx=true, -Djava.io.tmpdir=/tmp/elasticsearch-2400007459533475276, -XX:+HeapDumpOnOutOfMemoryError, -XX:HeapDumpPath=data, -XX:ErrorFile=logs/hs_err_pid%p.log, -XX:+PrintGCDetails, -XX:+PrintGCDateStamps, -XX:+PrintTenuringDistribution, -XX:+PrintGCApplicationStoppedTime, -Xloggc:logs/gc.log, -XX:+UseGCLogFileRotation, -XX:NumberOfGCLogFiles=32, -XX:GCLogFileSize=64m, -Des.path.home=/usr/local/elasticsearch, -Des.path.conf=/usr/local/elasticsearch/config, -Des.distribution.flavor=default, -Des.distribution.type=tar]............[2020-06-08T08:08:54,664][INFO ][o.e.n.Node               ] [5Viw2iF] initialized[2020-06-08T08:08:54,665][INFO ][o.e.n.Node               ] [5Viw2iF] starting ...[2020-06-08T08:08:55,458][INFO ][o.e.t.TransportService   ] [5Viw2iF] publish_address {192.168.150.101:9300}, bound_addresses {192.168.150.101:9300}[2020-06-08T08:08:55,548][INFO ][o.e.b.BootstrapChecks    ] [5Viw2iF] bound or publishing to a non-loopback address, enforcing bootstrap checksERROR: [2] bootstrap checks failed[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535][2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144][2020-06-08T08:08:55,728][INFO ][o.e.n.Node               ] [5Viw2iF] stopping ...[2020-06-08T08:08:55,804][INFO ][o.e.n.Node               ] [5Viw2iF] stopped[2020-06-08T08:08:55,804][INFO ][o.e.n.Node               ] [5Viw2iF] closing ...[2020-06-08T08:08:55,865][INFO ][o.e.n.Node               ] [5Viw2iF] closed[2020-06-08T08:08:55,869][INFO ][o.e.x.m.p.NativeController] [5Viw2iF] Native controller process has stopped - no new native processes can be started[es@host101 elasticsearch]$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：</p><p>需要使用root用户去修改</p><p>[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]</p><pre class="line-numbers language-shell"><code class="language-shell">[root@host101 config]# vi /etc/security/limits.conf加入:* soft nofile 65536* hard nofile 65536保存！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</p><pre class="line-numbers language-shell"><code class="language-shell">[root@host101 config]# vi /etc/sysctl.conf加入vm.max_map_count=262144保存！[root@host101 config]# sysctl -pvm.max_map_count = 262144[root@host101 config]# <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-再次启动数据库，报错"><a href="#3-4-再次启动数据库，报错" class="headerlink" title="3.4 再次启动数据库，报错"></a>3.4 再次启动数据库，报错</h4><pre class="line-numbers language-shell"><code class="language-shell">[es@host101 elasticsearch]$ bin/elasticsearchOpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N[2020-06-08T08:15:41,388][INFO ][o.e.e.NodeEnvironment    ] [5Viw2iF] using [1] data paths, mounts [[/ (rootfs)]], net usable_space [7.4gb], net total_space [16.9gb], types [rootfs][2020-06-08T08:15:41,406][INFO ][o.e.e.NodeEnvironment    ] [5Viw2iF] heap size [1015.6mb], compressed ordinary object pointers [true][2020-06-08T08:15:41,409][INFO ][o.e.n.Node               ] [5Viw2iF] node name derived from node ID [5Viw2iFFSraid8DsATRv0Q]; set [node.name] to override[2020-06-08T08:15:41,409][INFO ][o.e.n.Node               ] [5Viw2iF] version[6.8.8], pid[28441], build[default/tar/2f4c224/2020-03-18T23:22:18.622755Z], OS[Linux/3.10.0-957.el7.x86_64/amd64], JVM[Oracle Corporation/OpenJDK 64-Bit Server VM/1.8.0_181/25.181-b13][2020-06-08T08:15:41,410][INFO ][o.e.n.Node               ] [5Viw2iF] JVM arguments [-Xms1g, -Xmx1g, -XX:+UseConcMarkSweepGC, -XX:CMSInitiatingOccupancyFraction=75, -XX:+UseCMSInitiatingOccupancyOnly, -Des.networkaddress.cache.ttl=60, -Des.networkaddress.cache.negative.ttl=10, -XX:+AlwaysPreTouch, -Xss1m, -Djava.awt.headless=true, -Dfile.encoding=UTF-8, -Djna.nosys=true, -XX:-OmitStackTraceInFastThrow, -Dio.netty.noUnsafe=true, -Dio.netty.noKeySetOptimization=true, -Dio.netty.recycler.maxCapacityPerThread=0, -Dlog4j.shutdownHookEnabled=false, -Dlog4j2.disable.jmx=true, -Djava.io.tmpdir=/tmp/elasticsearch-3859837246303122342, -XX:+HeapDumpOnOutOfMemoryError, -XX:HeapDumpPath=data, -XX:ErrorFile=logs/hs_err_pid%p.log, -XX:+PrintGCDetails, -XX:+PrintGCDateStamps, -XX:+PrintTenuringDistribution, -XX:+PrintGCApplicationStoppedTime, -Xloggc:logs/gc.log, -XX:+UseGCLogFileRotation, -XX:NumberOfGCLogFiles=32, -XX:GCLogFileSize=64m, -Des.path.home=/usr/local/elasticsearch, -Des.path.conf=/usr/local/elasticsearch/config, -Des.distribution.flavor=default, -Des.distribution.type=tar]............[2020-06-08T08:16:13,493][INFO ][o.e.n.Node               ] [5Viw2iF] starting ...[2020-06-08T08:16:13,960][INFO ][o.e.t.TransportService   ] [5Viw2iF] publish_address {192.168.150.101:9300}, bound_addresses {192.168.150.101:9300}[2020-06-08T08:16:14,078][INFO ][o.e.b.BootstrapChecks    ] [5Viw2iF] bound or publishing to a non-loopback address, enforcing bootstrap checksERROR: [1] bootstrap checks failed[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535][2020-06-08T08:16:14,170][INFO ][o.e.n.Node               ] [5Viw2iF] stopping ...[2020-06-08T08:16:14,212][INFO ][o.e.n.Node               ] [5Viw2iF] stopped[2020-06-08T08:16:14,213][INFO ][o.e.n.Node               ] [5Viw2iF] closing ...[2020-06-08T08:16:14,273][INFO ][o.e.n.Node               ] [5Viw2iF] closed[2020-06-08T08:16:14,276][INFO ][o.e.x.m.p.NativeController] [5Viw2iF] Native controller process has stopped - no new native processes can be started[es@host101 elasticsearch]$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：</p><p>这个报错刚才不是已经修复了么？ 怎么还报这个错误，因为没生效，退出es用户，再重新登录es用户，启动数据库就OK了</p><pre class="line-numbers language-shell"><code class="language-shell">[es@host101 elasticsearch]$   exitlogout[root@host101 elasticsearch]# su - esLast login: Mon Jun  8 07:56:20 CST 2020 on pts/0[es@host101 ~]$ cd /usr/local/elasticsearch/[es@host101 elasticsearch]$ bin/elasticsearchOpenJDK 64-Bit Server VM warning: If the number of processors is expected to increase from one, then you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N[2020-06-08T08:18:13,096][INFO ][o.e.e.NodeEnvironment    ] [5Viw2iF] using [1] data paths, mounts [[/ (rootfs)]], net usable_space [7.4gb], net total_space [16.9gb], types [rootfs][2020-06-08T08:18:13,102][INFO ][o.e.e.NodeEnvironment    ] [5Viw2iF] heap size [1015.6mb], compressed ordinary object pointers [true][2020-06-08T08:18:13,119][INFO ][o.e.n.Node               ] [5Viw2iF] node name derived from node ID [5Viw2iFFSraid8DsATRv0Q]; set [node.name] to override[2020-06-08T08:18:13,119][INFO ][o.e.n.Node               ] [5Viw2iF] version[6.8.8], pid[28711], build[default/tar/2f4c224/2020-03-18T23:22:18.622755Z], OS[Linux/3.10.0-957.el7.x86_64/amd64], JVM[Oracle Corporation/OpenJDK 64-Bit Server VM/1.8.0_181/25.181-b13][2020-06-08T08:18:13,120][INFO ][o.e.n.Node               ] [5Viw2iF] JVM arguments [-Xms1g, -Xmx1g, -XX:+UseConcMarkSweepGC, -XX:CMSInitiatingOccupancyFraction=75, -XX:+UseCMSInitiatingOccupancyOnly, -Des.networkaddress.cache.ttl=60, -Des.networkaddress.cache.negative.ttl=10, -XX:+AlwaysPreTouch, -Xss1m, -Djava.awt.headless=true, -Dfile.encoding=UTF-8, -Djna.nosys=true, -XX:-OmitStackTraceInFastThrow, -Dio.netty.noUnsafe=true, -Dio.netty.noKeySetOptimization=true, -Dio.netty.recycler.maxCapacityPerThread=0, -Dlog4j.shutdownHookEnabled=false, -Dlog4j2.disable.jmx=true, -Djava.io.tmpdir=/tmp/elasticsearch-7764616055026205076, -XX:+HeapDumpOnOutOfMemoryError, -XX:HeapDumpPath=data, -XX:ErrorFile=logs/hs_err_pid%p.log, -XX:+PrintGCDetails, -XX:+PrintGCDateStamps, -XX:+PrintTenuringDistribution, -XX:+PrintGCApplicationStoppedTime, -Xloggc:logs/gc.log, -XX:+UseGCLogFileRotation, -XX:NumberOfGCLogFiles=32, -XX:GCLogFileSize=64m, -Des.path.home=/usr/local/elasticsearch, -Des.path.conf=/usr/local/elasticsearch/config, -Des.distribution.flavor=default, -Des.distribution.type=tar][2020-06-08T08:18:22,569][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [aggs-matrix-stats][2020-06-08T08:18:22,569][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [analysis-common][2020-06-08T08:18:22,569][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [ingest-common][2020-06-08T08:18:22,569][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [ingest-geoip][2020-06-08T08:18:22,570][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [ingest-user-agent][2020-06-08T08:18:22,570][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [lang-expression][2020-06-08T08:18:22,570][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [lang-mustache][2020-06-08T08:18:22,570][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [lang-painless][2020-06-08T08:18:22,570][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [mapper-extras][2020-06-08T08:18:22,570][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [parent-join][2020-06-08T08:18:22,570][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [percolator][2020-06-08T08:18:22,570][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [rank-eval][2020-06-08T08:18:22,571][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [reindex][2020-06-08T08:18:22,571][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [repository-url][2020-06-08T08:18:22,571][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [transport-netty4][2020-06-08T08:18:22,571][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [tribe][2020-06-08T08:18:22,571][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-ccr][2020-06-08T08:18:22,571][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-core][2020-06-08T08:18:22,571][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-deprecation][2020-06-08T08:18:22,571][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-graph][2020-06-08T08:18:22,571][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-ilm][2020-06-08T08:18:22,572][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-logstash][2020-06-08T08:18:22,572][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-ml][2020-06-08T08:18:22,572][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-monitoring][2020-06-08T08:18:22,572][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-rollup][2020-06-08T08:18:22,572][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-security][2020-06-08T08:18:22,572][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-sql][2020-06-08T08:18:22,572][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-upgrade][2020-06-08T08:18:22,572][INFO ][o.e.p.PluginsService     ] [5Viw2iF] loaded module [x-pack-watcher][2020-06-08T08:18:22,573][INFO ][o.e.p.PluginsService     ] [5Viw2iF] no plugins loaded[2020-06-08T08:18:35,564][INFO ][o.e.x.s.a.s.FileRolesStore] [5Viw2iF] parsed [0] roles from file [/usr/local/elasticsearch/config/roles.yml][2020-06-08T08:18:37,435][INFO ][o.e.x.m.p.l.CppLogMessageHandler] [5Viw2iF] [controller/28769] [Main.cc@109] controller (64 bit): Version 6.8.8 (Build 398321ce7838fd) Copyright (c) 2020 Elasticsearch BV[2020-06-08T08:18:39,447][DEBUG][o.e.a.ActionModule       ] [5Viw2iF] Using REST wrapper from plugin org.elasticsearch.xpack.security.Security[2020-06-08T08:18:40,072][INFO ][o.e.d.DiscoveryModule    ] [5Viw2iF] using discovery type [zen] and host providers [settings][2020-06-08T08:18:43,133][INFO ][o.e.n.Node               ] [5Viw2iF] initialized[2020-06-08T08:18:43,134][INFO ][o.e.n.Node               ] [5Viw2iF] starting ...[2020-06-08T08:18:43,835][INFO ][o.e.t.TransportService   ] [5Viw2iF] publish_address {192.168.150.101:9300}, bound_addresses {192.168.150.101:9300}[2020-06-08T08:18:43,916][INFO ][o.e.b.BootstrapChecks    ] [5Viw2iF] bound or publishing to a non-loopback address, enforcing bootstrap checks[2020-06-08T08:18:47,216][INFO ][o.e.c.s.MasterService    ] [5Viw2iF] zen-disco-elected-as-master ([0] nodes joined), reason: new_master {5Viw2iF}{5Viw2iFFSraid8DsATRv0Q}{c6ZTtwwQQ1eGMmDmW6BvbA}{192.168.150.101}{192.168.150.101:9300}{ml.machine_memory=1907941376, xpack.installed=true, ml.max_open_jobs=20, ml.enabled=true}[2020-06-08T08:18:47,235][INFO ][o.e.c.s.ClusterApplierService] [5Viw2iF] new_master {5Viw2iF}{5Viw2iFFSraid8DsATRv0Q}{c6ZTtwwQQ1eGMmDmW6BvbA}{192.168.150.101}{192.168.150.101:9300}{ml.machine_memory=1907941376, xpack.installed=true, ml.max_open_jobs=20, ml.enabled=true}, reason: apply cluster state (from master [master {5Viw2iF}{5Viw2iFFSraid8DsATRv0Q}{c6ZTtwwQQ1eGMmDmW6BvbA}{192.168.150.101}{192.168.150.101:9300}{ml.machine_memory=1907941376, xpack.installed=true, ml.max_open_jobs=20, ml.enabled=true} committed version [1] source [zen-disco-elected-as-master ([0] nodes joined)]])[2020-06-08T08:18:47,607][INFO ][o.e.h.n.Netty4HttpServerTransport] [5Viw2iF] publish_address {192.168.150.101:9200}, bound_addresses {192.168.150.101:9200}[2020-06-08T08:18:47,608][INFO ][o.e.n.Node               ] [5Viw2iF] started[2020-06-08T08:18:48,134][WARN ][o.e.x.s.a.s.m.NativeRoleMappingStore] [5Viw2iF] Failed to clear cache for realms [[]][2020-06-08T08:18:48,371][INFO ][o.e.l.LicenseService     ] [5Viw2iF] license [25b1507f-4db2-4bdb-9f72-bf19ed92defe] mode [basic] - valid[2020-06-08T08:18:48,434][INFO ][o.e.g.GatewayService     ] [5Viw2iF] recovered [0] indices into cluster_state<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用curl命令测试一下，或在浏览器中输入 <a href="http://192.168.150.101:9200/">http://192.168.150.101:9200/</a> 也会返回相同的信息，单节点安装完成。</p><pre class="line-numbers language-shell"><code class="language-shell">[root@host101 config]# curl http://192.168.150.101:9200/{  "name" : "5Viw2iF",  "cluster_name" : "elasticsearch",  "cluster_uuid" : "IKcwVC2QSZyoMuq0CKC7cA",  "version" : {    "number" : "6.8.8",    "build_flavor" : "default",    "build_type" : "tar",    "build_hash" : "2f4c224",    "build_date" : "2020-03-18T23:22:18.622755Z",    "build_snapshot" : false,    "lucene_version" : "7.7.2",    "minimum_wire_compatibility_version" : "5.6.0",    "minimum_index_compatibility_version" : "5.0.0"  },  "tagline" : "You Know, for Search"}[root@host101 config]# <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-设置es开机自启动"><a href="#3-5-设置es开机自启动" class="headerlink" title="3.5 设置es开机自启动"></a>3.5 设置es开机自启动</h4><pre class="line-numbers language-shell"><code class="language-shell">创建es 的系统启动服务文件，进入到 cd /etc/init.d 目录；cd /etc/init.d    　　【进入到目录】vi elasticsearch 　　 【创建es系统启动服务文件】编写启动脚本:#!/bin/bash#chkconfig: 345 63 37#description: elasticsearch#processname: elasticsearchexport ES_HOME=/opt/es/case $1 in        start)                su es<<!                cd $ES_HOME                ./bin/elasticsearch -d -p pid                exit!                echo "elasticsearch is started"                ;;        stop)                pid=`cat $ES_HOME/pid`                kill -9 $pid                echo "elasticsearch is stopped"                ;;        restart)                pid=`cat $ES_HOME/pid`                kill -9 $pid                echo "elasticsearch is stopped"                sleep 1                su es<<!                cd $ES_HOME                ./bin/elasticsearch -d -p pid                exit!                echo "elasticsearch is started"        ;;    *)        echo "start|stop|restart"        ;;  esacexit 0#保存退出#修改文件权限:chmod 777 elasticsearch#添加和删除服务并设置启动方式:chkconfig --add elasticsearch　　　　#【添加系统服务】chkconfig --del elasticsearch　　　　#【删除系统服务】#若是在国产操作系统UOS或者Ubuntu上设置服务，可以使用systemctl enable elasticsearch     #【添加服务】systemctl disable elasticsearch    #【删除服务】#关闭和启动服务:service elasticsearch start　　　　　#【启动】service elasticsearch stop　　　　　 #【停止】#或者：systemctl start elasticsearchsystemctl stop elasticsearchservice elasticsearch restart　　   #【重启】#设置服务是否开机启动：chkconfig elasticsearch on　　　　　　#【开启】chkconfig elasticsearch off　　   　 #【关闭】________________________________________验证是否已启动命令：复制代码ps -ef | grep elasticsearch    #【查看是否有es的进程】结束进程命令用 kill -9 进程ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、安装Kibana"><a href="#4、安装Kibana" class="headerlink" title="4、安装Kibana"></a>4、安装Kibana</h3><h4 id="4-1下载解压："><a href="#4-1下载解压：" class="headerlink" title="4.1下载解压："></a>4.1下载解压：</h4><p>将kibana-6.8.8-linux-x86_64上传至/usr/local/下，解压</p><pre class="line-numbers language-shell"><code class="language-shell">tar -zxvf kibana-6.8.8-linux-x86_64.tar.gzmv kibana-6.8.8-linux-x86_64 kibana<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-2-编辑kibana配置"><a href="#4-2-编辑kibana配置" class="headerlink" title="4.2 编辑kibana配置"></a>4.2 编辑kibana配置</h4><pre class="line-numbers language-shell"><code class="language-shell">vi /usr/local/kibana/config/kibana.yml# Kibana is served by a back end server. This setting specifies the port to use.#server.port: 5601# Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.# The default is 'localhost', which usually means remote machines will not be able to connect.# To allow connections from remote users, set this parameter to a non-loopback address.server.host: "192.168.244.129"# Enables you to specify a path to mount Kibana at if you are running behind a proxy.# Use the `server.rewriteBasePath` setting to tell Kibana if it should remove the basePath# from requests it receives, and to prevent a deprecation warning at startup.# This setting cannot end in a slash.#server.basePath: ""# Specifies whether Kibana should rewrite requests that are prefixed with# `server.basePath` or require that they are rewritten by your reverse proxy.# This setting was effectively always `false` before Kibana 6.3 and will# default to `true` starting in Kibana 7.0.#server.rewriteBasePath: false# The maximum payload size in bytes for incoming server requests.#server.maxPayloadBytes: 1048576# The Kibana server's name.  This is used for display purposes.#server.name: "your-hostname"# The URLs of the Elasticsearch instances to use for all your queries.elasticsearch.hosts: ["http://192.168.244.129:9200"]# When this setting's value is true Kibana uses the hostname specified in the server.host# setting. When the value of this setting is false, Kibana uses the hostname of the host# that connects to this Kibana instance.#elasticsearch.preserveHost: true# Kibana uses an index in Elasticsearch to store saved searches, visualizations and# dashboards. Kibana creates a new index if the index doesn't already exist.#kibana.index: ".kibana"# The default application to load.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-启动kibana"><a href="#4-3-启动kibana" class="headerlink" title="4.3 启动kibana"></a>4.3 启动kibana</h4><pre class="line-numbers language-shell"><code class="language-shell">cd /usr/local/kibana/bin/./kibana浏览器地访问http://192.168.244.xx:5601看到如下界面即成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img2020.cnblogs.com/blog/1688934/202004/1688934-20200412224034576-1166938185.png" alt="img"></p><h4 id="4-4-设置kibana开机自启动"><a href="#4-4-设置kibana开机自启动" class="headerlink" title="4.4 设置kibana开机自启动"></a>4.4 设置kibana开机自启动</h4><pre class="line-numbers language-shell"><code class="language-shell">  cd /etc/init.d  touch kibana  chmod +x kibana  vi kibana并输入以下内容:#!/bin/bash# chkconfig:   345 98 02# description:  kibanaKIBANA_HOME=/usr/local/kibanacase $1 in        start) $KIBANA_HOME/bin/kibana &;;        *) echo "kibana is start";;esac#保存退出#修改文件权限:chmod 777 kibana#添加和删除服务并设置启动方式:chkconfig --add kibana　　　　#【添加系统服务】chkconfig --del kibana　　　　#【删除系统服务】#关闭和启动服务:service elasticsearch start　　　　　#【启动】service elasticsearch stop　　　　　 #【停止】service elasticsearch restart　　   #【重启】#设置服务是否开机启动：chkconfig kibana on　　　　　　#【开启】chkconfig kibana off　　   　 #【关闭】<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
            <tag> linux - install </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>install rabbitmq</title>
      <link href="2021/01/20/install-rabbitmq/"/>
      <url>2021/01/20/install-rabbitmq/</url>
      
        <content type="html"><![CDATA[<h2 id="已安装rabbitmq-server-3-8-5为例，具体环境："><a href="#已安装rabbitmq-server-3-8-5为例，具体环境：" class="headerlink" title="已安装rabbitmq-server-3.8.5为例，具体环境："></a>已安装rabbitmq-server-3.8.5为例，具体环境：</h2><table><thead><tr><th>环境</th><th>版本</th></tr></thead><tbody><tr><td>OS</td><td>linux7</td></tr><tr><td>rabbitmq</td><td>rabbitmq-server-3.8.5-1.el7.noarch.rpm</td></tr><tr><td>erlang</td><td>erlang-22.3.4.1-1.el7.x86_64.rpm</td></tr><tr><td>socat</td><td>socat-1.7.3.2-2.el7.x86_64.rpm</td></tr></tbody></table><h3 id="安装Erlang"><a href="#安装Erlang" class="headerlink" title="安装Erlang"></a>安装Erlang</h3><p>由于RabbitMQ依赖Erlang， 所以需要先安装Erlang。</p><p>Erlang的安装方式大概有两种：</p><ol><li><p>rpm方式安装Erlang</p><pre class="line-numbers language-shell"><code class="language-shell"> # 添加erlang solutions源 $ wget https://xxx/erlang-22.3.4.1-1.el7.x86_64.rpm $ wget --content-disposition https://packagecloud.io/rabbitmq/erlang/packages/el/7/erlang-23.3.4-1.el7.x86_64.rpm/download.rpm $ sudo rpm -Uvh erlang-22.3.4.1-1.el7.x86_64.rpm $ sudo yum install erlang<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>从EPEL源安装(<strong><em>\</em>此方式安装的Erlang版本可能不是最新的，有时候不能满足RabbitMQ需要的最低版本**</strong>)</p><pre class="line-numbers language-shell"><code class="language-shell"> # 启动EPEL源 $ sudo yum install epel-release  # 安装erlang $ sudo yum install erlang  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="安装socat"><a href="#安装socat" class="headerlink" title="安装socat"></a>安装socat</h3><p>先下载rpm：</p><pre class="line-numbers language-shell"><code class="language-shell">wget http://www.rpmfind.net/linux/centos/7.9.2009/os/x86_64/Packages/socat-1.7.3.2-2.el7.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载完成后安装：</p><pre class="line-numbers language-shell"><code class="language-shell">rpm -ivh  socat-1.7.3.2-2.el7.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h3><p>先下载rpm：</p><pre class="line-numbers language-shell"><code class="language-shell">wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.5/rabbitmq-server-3.8.5-1.el7.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下载完成后安装：</p><pre class="line-numbers language-shell"><code class="language-shell">rpm -ivh rabbitmq-server-3.8.5-1.el7.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="关于RabbitMQ的一些基本操作"><a href="#关于RabbitMQ的一些基本操作" class="headerlink" title="关于RabbitMQ的一些基本操作"></a>关于RabbitMQ的一些基本操作</h3><pre class="line-numbers language-shell"><code class="language-shell">$ systemctl enable rabbitmq-server  # 添加开机启动RabbitMQ服务$ systemctl start rabbitmq-server # 启动服务$ systemctl status rabbitmq-server  # 查看服务状态$ systemctl stop rabbitmq-server    # 停止服务# 查看当前所有用户$ sudo rabbitmqctl list_users# 查看默认guest用户的权限$ sudo rabbitmqctl list_user_permissions guest# 由于RabbitMQ默认的账号用户名和密码都是guest。为了安全起见, 先删掉默认用户$ sudo rabbitmqctl delete_user guest# 添加新用户$ sudo rabbitmqctl add_user username password# 设置用户tag$ sudo rabbitmqctl set_user_tags username administrator# 赋予用户默认vhost的全部操作权限$ sudo rabbitmqctl set_permissions -p / username ".*" ".*" ".*"# 查看用户的权限$ sudo rabbitmqctl list_user_permissions username<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多关于<code>rabbitmqctl</code>的使用，可以参考<a href="https://link.jianshu.com/?t=https://www.rabbitmq.com/man/rabbitmqctl.1.man.html">帮助手册</a>。</p><h3 id="开启web管理接口"><a href="#开启web管理接口" class="headerlink" title="开启web管理接口"></a>开启web管理接口</h3><p>如果只从命令行操作RabbitMQ，多少有点不方便。幸好RabbitMQ自带了web管理界面，只需要启动插件便可以使用。</p><pre class="line-numbers language-shell"><code class="language-shell">$ sudo rabbitmq-plugins enable rabbitmq_management<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后通过浏览器访问</p><p><a href="http://localhost:15672/">http://localhost:15672</a></p><p>输入用户名和密码访问web管理界面了。</p><h3 id="配置RabbitMQ"><a href="#配置RabbitMQ" class="headerlink" title="配置RabbitMQ"></a>配置RabbitMQ</h3><p>关于RabbitMQ的配置，可以下载RabbitMQ的<a href="https://link.jianshu.com/?t=https://raw.githubusercontent.com/rabbitmq/rabbitmq-server/stable/docs/rabbitmq.config.example">配置文件模板</a>到<code>/etc/rabbitmq/rabbitmq.config</code>, 然后按照需求更改即可。<br>关于每个配置项的具体作用，可以参考<a href="https://link.jianshu.com/?t=https://www.rabbitmq.com/configure.html">官方文档</a>。<br>更新配置后，别忘了重启服务哦！</p><h3 id="开启用户远程访问"><a href="#开启用户远程访问" class="headerlink" title="开启用户远程访问"></a>开启用户远程访问</h3><p>默认情况下，RabbitMQ的默认的<code>guest</code>用户只允许本机访问， 如果想让<code>guest</code>用户能够远程访问的话，只需要将配置文件中的<code>loopback_users</code>列表置为空即可，如下：</p><pre><code>{loopback_users, []}</code></pre><p>另外关于新添加的用户，直接就可以从远程访问的，如果想让新添加的用户只能本地访问，可以将用户名添加到上面的列表, 如只允许<code>admin</code>用户本机访问。</p><pre><code>{loopback_users, ["admin"]}</code></pre><p>更新配置后，别忘了重启服务哦！</p><pre class="line-numbers language-shell"><code class="language-shell">$ systemctl status rabbitmq-server   # 查看服务状态<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://images2015.cnblogs.com/blog/321801/201611/321801-20161123155611737-770552575.png" alt="img"></p><p>这里可以看到log文件的位置，转到文件位置，打开文件：</p><p><img src="http://images2015.cnblogs.com/blog/321801/201611/321801-20161123155722050-140847138.png" alt="img"></p><p>这里显示的是没有找到配置文件，我们可以自己创建这个文件</p><pre class="line-numbers language-shell"><code class="language-shell">$ cd /etc/rabbitmq/$ vi rabbitmq.config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>编辑内容如下：</p><pre class="line-numbers language-html"><code class="language-html">[{rabbit, [{loopback_users, []}]}].<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的意思是开放使用，rabbitmq默认创建的用户guest，密码也是guest，这个用户默认只能是本机访问，localhost或者127.0.0.1，从外部访问需要添加上面的配置。</p><p>保存配置后重启服务：</p><pre class="line-numbers language-shell"><code class="language-shell">$ systemctl stop rabbitmq-server $ systemctl start rabbitmq-server <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时就可以从外部访问了，但此时再看log文件，发现内容还是原来的，还是显示没有找到配置文件，可以手动删除这个文件再重启服务，不过这不影响使用</p><pre class="line-numbers language-shell"><code class="language-shell">$ rm rabbit\@mythsky.log $ systemctl stop rabbitmq-server $ systemctl start rabbitmq-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意:记得要开放5672和15672端口</p><pre class="line-numbers language-shell"><code class="language-shell">$ firewall-cmd --zone=public --add-port=5672/tcp --permanent$ firewall-cmd --zone=public --add-port=15672/tcp --permanent $ firewall-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> rabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitMQ </tag>
            
            <tag> linux - install </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 中@Transactional 注解失效的场景</title>
      <link href="2021/01/14/spring-zhong-transactional-zhu-jie-shi-xiao-de-chang-jing/"/>
      <url>2021/01/14/spring-zhong-transactional-zhu-jie-shi-xiao-de-chang-jing/</url>
      
        <content type="html"><![CDATA[<p><strong>引言</strong></p><p><code>@Transactional</code>注解哪些场景下会失效，一时语塞致使面试失败。所以今天简单的和大家分享一下<code>@Transactional</code>相关的知识。</p><p><code>@Transactional</code> 注解相信大家并不陌生，平时开发中很常用的一个注解，它能保证方法内多个数据库操作要么同时成功、要么同时失败。使用<code>@Transactional</code>注解时需要注意许多的细节，不然你会发现<code>@Transactional</code>总是莫名其妙的就失效了。</p><h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a><strong>一、事务</strong></h2><p>事务管理在系统开发中是不可缺少的一部分，<code>Spring</code>提供了很好事务管理机制，主要分为<code>编程式事务</code>和<code>声明式事务</code>两种。</p><p><strong>编程式事务</strong>：是指在代码中手动的管理事务的提交、回滚等操作，代码侵入性比较强，如下示例：</p><pre><code>1try {2    //TODO something3     transactionManager.commit(status);4} catch (Exception e) {5    transactionManager.rollback(status);6    throw new InvoiceApplyException("异常失败");7}</code></pre><p><strong>声明式事务</strong>：基于<code>AOP</code>面向切面的，它将具体业务与事务处理部分解耦，代码侵入性很低，所以在实际开发中声明式事务用的比较多。声明式事务也有两种实现方式，一是基于<code>TX</code>和<code>AOP</code>的xml配置文件方式，二种就是基于@Transactional注解了。</p><pre><code>1    @Transactional2    @GetMapping("/test")3    public String test() {45        int insert = cityInfoDictMapper.insert(cityInfoDict);6    }</code></pre><p><strong><em>\</em><br>**</strong></p><h2 id="二、-Transactional介绍"><a href="#二、-Transactional介绍" class="headerlink" title="二、@Transactional介绍"></a>二、@Transactional介绍</h2><h4 id="1、-Transactional注解可以作用于哪些地方？"><a href="#1、-Transactional注解可以作用于哪些地方？" class="headerlink" title="1、@Transactional注解可以作用于哪些地方？"></a>1、@Transactional注解可以作用于哪些地方？</h4><p>@Transactional 可以作用在<code>接口</code>、<code>类</code>、<code>类方法</code>。</p><ul><li><strong>作用于类</strong>：当把@Transactional 注解放在类上时，表示所有该类的<code>public</code>方法都配置相同的事务属性信息。</li><li><strong>作用于方法</strong>：当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息。</li><li><strong>作用于接口</strong>：不推荐这种使用方法，因为一旦标注在Interface上并且配置了Spring AOP 使用CGLib动态代理，将会导致@Transactional注解失效</li></ul><pre><code> 1@Transactional 2@RestController 3@RequestMapping 4public class MybatisPlusController { 5    @Autowired 6    private CityInfoDictMapper cityInfoDictMapper; 7 8    @Transactional(rollbackFor = Exception.class) 9    @GetMapping("/test")10    public String test() throws Exception {11        CityInfoDict cityInfoDict = new CityInfoDict();12        cityInfoDict.setParentCityId(2);13        cityInfoDict.setCityName("2");14        cityInfoDict.setCityLevel("2");15        cityInfoDict.setCityCode("2");16        int insert = cityInfoDictMapper.insert(cityInfoDict);17        return insert + "";18    }19}</code></pre><h4 id="2、-Transactional注有哪些属性？"><a href="#2、-Transactional注有哪些属性？" class="headerlink" title="2、@Transactional注有哪些属性？"></a>2、@Transactional注有哪些属性？</h4><h5 id="propagation属性"><a href="#propagation属性" class="headerlink" title="propagation属性"></a>propagation属性</h5><p><code>propagation</code> 代表事务的传播行为，默认值为 <code>Propagation.REQUIRED</code>，其他的属性信息如下：</p><ul><li><code>Propagation.REQUIRED</code>：如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。**(** 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 <strong>）</strong></li><li><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</li><li><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</li><li><code>Propagation.REQUIRES_NEW</code>：重新创建一个新的事务，如果当前存在事务，暂停当前的事务。**(** 当类A中的 a 方法用默认<code>Propagation.REQUIRED</code>模式，类B中的 b方法加上采用 <code>Propagation.REQUIRES_NEW</code>模式，然后在 a 方法中调用 b方法操作数据库，然而 a方法抛出异常后，b方法并没有进行回滚，因为<code>Propagation.REQUIRES_NEW</code>会暂停 a方法的事务 <strong>)</strong></li><li><code>Propagation.NOT_SUPPORTED</code>：以非事务的方式运行，如果当前存在事务，暂停当前的事务。</li><li><code>Propagation.NEVER</code>：以非事务的方式运行，如果当前存在事务，则抛出异常。</li><li><code>Propagation.NESTED</code> ：和 Propagation.REQUIRED 效果一样。</li></ul><h5 id="isolation-属性"><a href="#isolation-属性" class="headerlink" title="isolation 属性"></a>isolation 属性</h5><p><code>isolation</code> ：事务的隔离级别，默认值为 <code>Isolation.DEFAULT</code>。</p><ul><li>Isolation.DEFAULT：使用底层数据库默认的隔离级别。</li><li>Isolation.READ_UNCOMMITTED</li><li>Isolation.READ_COMMITTED</li><li>Isolation.REPEATABLE_READ</li><li>Isolation.SERIALIZABLE</li></ul><h5 id="timeout-属性"><a href="#timeout-属性" class="headerlink" title="timeout 属性"></a>timeout 属性</h5><p><code>timeout</code> ：事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p><h5 id="readOnly-属性"><a href="#readOnly-属性" class="headerlink" title="readOnly 属性"></a>readOnly 属性</h5><p><code>readOnly</code> ：指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</p><h5 id="rollbackFor-属性"><a href="#rollbackFor-属性" class="headerlink" title="rollbackFor 属性"></a>rollbackFor 属性</h5><p><code>rollbackFor</code> ：用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</p><h5 id="noRollbackFor属性"><a href="#noRollbackFor属性" class="headerlink" title="noRollbackFor属性**"></a><strong>noRollbackFor</strong>属性**</h5><p><code>noRollbackFor</code>：抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</p><h3 id=""><a href="#" class="headerlink" title="** **"></a>** **</h3><h2 id="二、-Transactional失效场景"><a href="#二、-Transactional失效场景" class="headerlink" title="二、@Transactional失效场景"></a><strong>二、@Transactional失效场景</strong></h2><p>接下来我们结合具体的代码分析一下哪些场景下，@Transactional 注解会失效。</p><h4 id="1、-Transactional-应用在非-public-修饰的方法上"><a href="#1、-Transactional-应用在非-public-修饰的方法上" class="headerlink" title="1、@Transactional 应用在非 public 修饰的方法上"></a>1、@Transactional 应用在非 public 修饰的方法上</h4><p>如果<code>Transactional</code>注解应用在非<code>public</code> 修饰的方法上，Transactional将会失效。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aOhsEJ0TtJSM5kcSOKZGJDOJoUPF0IHL2wvUHIzlHVYOib6bEN2tKkCyUn8fOxMVicBxvoKpgXU2HDQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">在这里插入图片描述</p><p>之所以会失效是因为在Spring AOP 代理时，如上图所示 <code>TransactionInterceptor</code> （事务拦截器）在目标方法执行前后进行拦截，<code>DynamicAdvisedInterceptor</code>（CglibAopProxy 的内部类）的 intercept 方法或 <code>JdkDynamicAopProxy</code> 的 invoke 方法会间接调用 <code>AbstractFallbackTransactionAttributeSource</code>的 <code>computeTransactionAttribute</code> 方法，获取Transactional 注解的事务配置信息。</p><pre><code>1protected TransactionAttribute computeTransactionAttribute(Method method,2    Class&lt;?&gt; targetClass) {3        // Don't allow no-public methods as required.4        if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {5        return null;6}</code></pre><p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。</p><p><strong>注意：**</strong><code>protected</code>、<code>private</code> 修饰的方法上使用 <code>@Transactional</code> 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。**</p><h4 id="2、-Transactional-注解属性-propagation-设置错误"><a href="#2、-Transactional-注解属性-propagation-设置错误" class="headerlink" title="2、@Transactional 注解属性 propagation 设置错误"></a>2、@Transactional 注解属性 propagation 设置错误</h4><p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p><p><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。<br><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。<br><code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</p><h4 id="3、-Transactional-注解属性-rollbackFor-设置错误"><a href="#3、-Transactional-注解属性-rollbackFor-设置错误" class="headerlink" title="3、@Transactional 注解属性 rollbackFor 设置错误"></a>3、@Transactional 注解属性 rollbackFor 设置错误</h4><p><code>rollbackFor</code> 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查<code>unchecked</code>异常（继承自 <code>RuntimeException</code>的异常）或者 <code>Error</code>才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 <strong>rollbackFor</strong>属性。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aOhsEJ0TtJSM5kcSOKZGJDOENdU9CHkPlMgJrCv3Du00eDAiaaqleo6D9Q49dQuwY4lddQOsRRiadPA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">在这里插入图片描述</p><pre><code>1// 希望自定义的异常可以进行回滚2@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class</code></pre><p>若在目标方法中抛出的异常是 <code>rollbackFor</code> 指定的异常的子类，事务同样会回滚。Spring源码如下：</p><pre><code> 1private int getDepth(Class&lt;?&gt; exceptionClass, int depth) { 2        if (exceptionClass.getName().contains(this.exceptionName)) { 3            // Found it! 4            return depth; 5} 6        // If we've gone as far as we can go and haven't found it... 7        if (exceptionClass == Throwable.class) { 8            return -1; 9}10return getDepth(exceptionClass.getSuperclass(), depth + 1);11}</code></pre><h4 id="4、同一个类中方法调用，导致-Transactional失效"><a href="#4、同一个类中方法调用，导致-Transactional失效" class="headerlink" title="4、同一个类中方法调用，导致@Transactional失效"></a>4、同一个类中方法调用，导致@Transactional失效</h4><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用<code>Spring AOP</code>代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由<code>Spring</code>生成的代理对象来管理。</p><pre><code> 1//@Transactional 2    @GetMapping("/test") 3    private Integer A() throws Exception { 4        CityInfoDict cityInfoDict = new CityInfoDict(); 5        cityInfoDict.setCityName("2"); 6        /** 7         * B 插入字段为 3的数据 8         */ 9        this.insertB();10        /**11         * A 插入字段为 2的数据12         */13        int insert = cityInfoDictMapper.insert(cityInfoDict);1415        return insert;16    }1718    @Transactional()19    public Integer insertB() throws Exception {20        CityInfoDict cityInfoDict = new CityInfoDict();21        cityInfoDict.setCityName("3");22        cityInfoDict.setParentCityId(3);2324        return cityInfoDictMapper.insert(cityInfoDict);25    }</code></pre><h4 id="5、异常被你的-catch“吃了”导致-Transactional失效"><a href="#5、异常被你的-catch“吃了”导致-Transactional失效" class="headerlink" title="5、异常被你的 catch“吃了”导致@Transactional失效"></a>5、异常被你的 catch“吃了”导致@Transactional失效</h4><p>这种情况是最常见的一种@Transactional注解失效场景</p><pre><code> 1    @Transactional 2    private Integer A() throws Exception { 3        int insert = 0; 4        try { 5            CityInfoDict cityInfoDict = new CityInfoDict(); 6            cityInfoDict.setCityName("2"); 7            cityInfoDict.setParentCityId(2); 8            /** 9             * A 插入字段为 2的数据10             */11            insert = cityInfoDictMapper.insert(cityInfoDict);12            /**13             * B 插入字段为 3的数据14             */15            b.insertB();16        } catch (Exception e) {17            e.printStackTrace();18        }19    }</code></pre><p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？</p><p>答案：不能！</p><p>会抛出异常：</p><pre><code>1org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</code></pre><p>因为当<code>ServiceB</code>中抛出了一个异常以后，<code>ServiceB</code>标识当前事务需要<code>rollback</code>。但是<code>ServiceA</code>中由于你手动的捕获这个异常并进行处理，<code>ServiceA</code>认为当前事务应该正常<code>commit</code>。此时就出现了前后不一致，也就是因为这样，抛出了前面的<code>UnexpectedRollbackException</code>异常。</p><p><code>spring</code>的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行<code>commit</code> or <code>rollback</code>，事务是否执行取决于是否抛出<code>runtime异常</code>。如果抛出<code>runtime exception</code> 并在你的业务方法中没有catch到的话，事务会回滚。</p><p>在业务方法中一般不需要catch异常，如果非要catch一定要抛出<code>throw new RuntimeException()</code>，或者注解中指定抛异常类型<code>@Transactional(rollbackFor=Exception.class)</code>，否则会导致事务失效，数据commit造成数据不一致，所以有些时候try catch反倒会画蛇添足。</p><h4 id="6、数据库引擎不支持事务"><a href="#6、数据库引擎不支持事务" class="headerlink" title="6、数据库引擎不支持事务"></a>6、数据库引擎不支持事务</h4><p>这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的<code>innodb</code>引擎。一旦数据库引擎切换成不支持事务的<code>myisam</code>，那事务就从根本上失效了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>@Transactional 注解的看似简单易用，但如果对它的用法一知半解，还是会踩到很多坑的。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transactional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring通过ClassPathResource类读取配置文件</title>
      <link href="2021/01/14/spring-tong-guo-classpathresource-lei-du-qu-pei-zhi-wen-jian/"/>
      <url>2021/01/14/spring-tong-guo-classpathresource-lei-du-qu-pei-zhi-wen-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在开发中读取项目中的配置或者静态文件是家常便饭的事情，我相信很多同学都从网上找下面的例子来进行文件加载读取操作。</p><p>利用<code>ClassLoader</code>获取<code>classpath</code>路径：</p><pre><code> ClassLoader loader = Thread.currentThread().getContextClassLoader(); String classPath =  loader.getResource("").getPath()</code></pre><p>或者利用<code>Class</code>对象来获取绝对路径或者<code>classpath</code>路径：</p><pre><code>String absolutepath =  this.getClass().getResource("").getPath();String classPath =  this.getClass().getResource("/").getPath();</code></pre><p>然后在拼接文件路径读取文件。为什么我这么清楚？因为我也这么干过。但是现在我已经不这么干了，因为我发现了 Spring 框架提供了更加好用的加载读取文件的方式。</p><h2 id="2-ClassPathResource"><a href="#2-ClassPathResource" class="headerlink" title="2. ClassPathResource"></a>2. ClassPathResource</h2><p>一般来说，我们项目的配置文件及静态资源都会放置在<code>resources</code>目录下。这时我们可以通过 Spring 提供的<code>ClassPathResource</code>来访问。例如在我最新的微信支付 SDK 项目中要加载微信支付的证书：</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zuF5sJGRDCvakK2oibDuENiazx6P6eSNjCrLAicDmUB5264Mq0yzJZ1JGtuL2ZeZ4bqogGufWSNS3Ds2ia3VFicT4eA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">微信证书的类路径为wechat/apiclient_cert.p12</p><p>对应读取方法为：</p><pre><code>ClassPathResource resource = new ClassPathResource(keyPath);InputStream is =  resource.getInputStream();</code></pre><p>然后你就能从流中读取配置文件的内容了，非常简单。</p><p>还有其它一些方法，例如判断文件是否存在、获取文件的<code>File</code>对象等等，也非常有用。</p><blockquote><p>微信支付开发包：<a href="https://felord.gitee.io/payment-spring-boot">https://felord.gitee.io/payment-spring-boot</a></p></blockquote><h3 id="ClassPathResource-的坑"><a href="#ClassPathResource-的坑" class="headerlink" title="ClassPathResource 的坑"></a>ClassPathResource 的坑</h3><p>说到获取文件对象的<code>getFile()</code>方法，这里是有一个小坑的。当你利用这个方法去读取 Jar 包里面类路径的文件的时候是行不通的。</p><p>经过代码调试，发现加载的地址是一个 Jar 文件协议地址，它类似这种格式<code>jar:file:/xxx/xx.jar!/xxxx</code>。</p><p>而<code>getFile()</code>方法只支持<strong>JBoss</strong>的<code>vfs</code>协议头和传统文件系统的<code>file</code>协议头。所以推荐使用<code>getInputStream()</code>。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p><code>ClassPathResource</code>在读取类路径下的文件配置、或者 Excel 模板、静态配置时非常有用，封装了很多好用的 API，推荐大家在合适的场景下使用。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java1.7后判空工具类Objects</title>
      <link href="2021/01/14/objects-tools/"/>
      <url>2021/01/14/objects-tools/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>Java 开发中经常要对对象进行非空判断以防止出现空指针。大部分同学都喜欢用下面这种方式来进行判断：</p><pre><code>if (obj!=null){    // 判断不等于空}if (obj==null){    // 判断等于空}</code></pre><p>这种方式没有什么问题。不过在 Java 7 中专门提供了一个工具类<code>java.util.Objects</code>可以处理的更好。</p><h2 id="2-Objects"><a href="#2-Objects" class="headerlink" title="2. Objects"></a>2. Objects</h2><p><code>java.util.Objects</code>提供了一系列的静态方法来处理日常一些针对对象的操作。</p><h3 id="空值判断"><a href="#空值判断" class="headerlink" title="空值判断"></a>空值判断</h3><p>比如开始提到的<code>null</code>值判断我们可以优化为：</p><pre><code>if (Objects.nonNull(obj)){    // 判断不等于空}if (Objects.isNull(obj)){    // 判断等于空}</code></pre><h3 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h3><p>空值检查并不等同于空值判断，空值判断是根据对象是否为空而执行不同的分支策略，而空值检查是要求对象不能为空。为此<code>Objects</code>提供了如下方法：</p><pre><code>public static &lt;T&gt; T requireNonNull(T obj) {    if (obj == null)        throw new NullPointerException();    return obj;}</code></pre><p>此方法主要用于在方法和构造函数中进行参数验证，例如：</p><pre><code>   public Foo(Bar bar) {           this.bar = Objects.requireNonNull(bar);   }</code></pre><p>如果你需要自定义抛出空指针信息时可以使用其重载方法<code>requireNonNull(T obj, String message)</code> ：</p><pre><code>public Foo(Bar bar, Baz baz) {       this.bar = Objects.requireNonNull(bar, "bar must not be null");       this.baz = Objects.requireNonNull(baz, "baz must not be null");}</code></pre><h3 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h3><p>一般情况下对象比较我们喜欢使用：</p><pre><code>obj.equals(other)</code></pre><p>但是并不是每次此方法都能凑效，如果<code>obj</code>为<code>null</code>则会抛出空指针异常，因此我们需要对<code>obj</code>进行前置非空判断。对此<code>Objects</code>也提供了对应的解决方案：</p><pre><code> public static boolean equals(Object a, Object b) {        return (a == b) || (a != null &amp;&amp; a.equals(b)); }</code></pre><p>但是使用的时候也需要注意一些坑，<code>Objects.equals</code>在处理基础数据类型和封装类型的比较时会出现一些让人意想不到的问题：</p><pre><code>Objects.equals(2,2L)</code></pre><p>上面的结果居然是<code>false</code>! 通过源码发现<code>Objects.equals</code>在进行比较时会自动对基本类型做封装，也就是说它把<code>2</code>封箱为<code>Integer</code>，<code>2L</code>封箱为<code>Long</code>，类型不同自然为<code>false</code>。</p><blockquote><p>尽量保证<code>Objects.equals</code>的两个对象类型一致。</p></blockquote><h3 id="对象深度比较"><a href="#对象深度比较" class="headerlink" title="对象深度比较"></a>对象深度比较</h3><p><code>Objects</code>中还有一个<code>deepEquals</code>方法，此方法的功能比较强大，不仅可以比较对象是否相同，如果该对象是数组还可以比较内容是否相同，但是胖哥并不常用。</p><h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><p><code>Objects</code>也对<code>hash</code>、<code>toString</code>以及对两个对象进行比较的方法（<code>Comparator</code>）<code>compare</code>的封装，其中也涉及了对空的处理，不过这几个方法确实不太常用，有兴趣的可以去研究一下。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Swagger2或Swagger3中增加Json Web Token</title>
      <link href="2021/01/14/ru-he-zai-swagger2-huo-swagger3-zhong-zeng-jia-json-web-token/"/>
      <url>2021/01/14/ru-he-zai-swagger2-huo-swagger3-zhong-zeng-jia-json-web-token/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p><strong>Swagger 3.0</strong>已经发布有一段时间了，作为一个非常有用的文档工具已经越来越多的项目在使用它。而<strong>JWT</strong>也是目前前后端分离最常用的安全技术。那么如何在<strong>Swagger 3.0</strong> 中添加<strong>JWT Token</strong>呢？今天胖哥就分享一下这个知识点。</p><h2 id="2-Swagger2-中添加-JWT"><a href="#2-Swagger2-中添加-JWT" class="headerlink" title="2. Swagger2 中添加 JWT"></a>2. Swagger2 中添加 JWT</h2><p>我们先来回顾在<strong>Swagger2</strong>中是如何添加<strong>JWT</strong>的。在<strong>Swagger2</strong>中我们声明<code>Docket</code>Bean 时利用全局参数注入一个<code>Authorization</code>请求头：</p><pre><code>private List&lt;Parameter&gt; jwtToken() {        String jwt = "Bearer {jwt}";        ParameterBuilder tokenPar = new ParameterBuilder();        List&lt;Parameter&gt; pars = new ArrayList&lt;&gt;();        // 声明 key        tokenPar.name("Authorization")                // 文字说明                .description("jwt令牌")                // 类型为字符串                .modelRef(new ModelRef("string"))                // 参数形式为 header 参数                .parameterType("header")                // 默认值                .defaultValue(jwt)                // 是否必须                .required(false);        pars.add(tokenPar.build());        return pars;    }   @Bean    public Docket api() {        return new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                .globalOperationParameters(jwtToken())                .select()                .apis(RequestHandlerSelectors.any())                .paths(PathSelectors.any())                .build();    }</code></pre><p>效果如下，你只需要填充一个可用的<strong>Jwt Token</strong>即可。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zuF5sJGRDCtGg6b4BibSmgrn0tSkP9LYIT5MRl4sJDDhc0vSGjKT3tjnaQvkibH9Vu4s21MBrSZjaKo2ZiaTjvG5w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">swagger2中注入jwt请求头</p><blockquote><p>但是这种方式只能适用于 Swagger2，在 Swagger3 中并不凑效。</p></blockquote><h2 id="3-Swagger3-中添加-JWT"><a href="#3-Swagger3-中添加-JWT" class="headerlink" title="3. Swagger3 中添加 JWT"></a>3. Swagger3 中添加 JWT</h2><p>那么<strong>Swagger3</strong>中应该如何做呢？<strong>Swagger3</strong>同样也是在声明<code>Docket</code>Bean 中注入，如下：</p><pre><code>    @Bean    public Docket api() {        return new Docket(DocumentationType.OAS_30)                .apiInfo(apiInfo())                .securitySchemes(Collections.singletonList(HttpAuthenticationScheme.JWT_BEARER_BUILDER//                        显示用                        .name("JWT")                        .build()))                .securityContexts(Collections.singletonList(SecurityContext.builder()                        .securityReferences(Collections.singletonList(SecurityReference.builder()                                .scopes(new AuthorizationScope[0])                                .reference("JWT")                                .build()))                        // 声明作用域                        .operationSelector(o -&gt; o.requestMappingPattern().matches("/.*"))                        .build()))                .select()                .apis(RequestHandlerSelectors.any())                .paths(PathSelectors.any())                .build();    }</code></pre><p>通过<strong>Swagger3</strong>中<code>Docket</code>提供的<code>securitySchemes</code>和<code>securityReferences</code>方法进行<code>JWT</code>的配置。效果以及流程如下：</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zuF5sJGRDCtGg6b4BibSmgrn0tSkP9LYInpK6oDzF9GrNGGBiaAYNzticTmTE93t4KdxDcT2JHv1ich6OKrB0jusXw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">Swagger3中jwt使用流程</p><p>我们可以看到请求时会携带一个<strong>Bearer Token</strong>:</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zuF5sJGRDCtGg6b4BibSmgrn0tSkP9LYIVJgazUMFfibncv3gnPFlk15fkvPIFGSHO3yiahkWGFvrDoqW6Ng5iaF4g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">Swagger3中携带jwt</p><blockquote><p>感觉<strong>Swagger3</strong>中设置<strong>JWT</strong>比<strong>Swagger2</strong>中要麻烦一些，不过能用就行。</p></blockquote><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>今天对<strong>Swagger2</strong>和<strong>Swagger3</strong>中设置<strong>JWT Token</strong>进行了分享，作为两种经常在项目中使用的工具，我们不需要知道具体的原理，只知道如何来简化我们的使用和开发即可。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jwt </tag>
            
            <tag> swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring操作对象类型</title>
      <link href="2021/01/14/spring-cao-zuo-dui-xiang-lei-xing/"/>
      <url>2021/01/14/spring-cao-zuo-dui-xiang-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>今天在看<strong>Spring Security</strong>源码的时候无意间注意到两行代码;</p><pre><code>ResolvableType type = ResolvableType.forClassWithGenerics(OAuth2UserService.class, OAuth2UserRequest.class, OAuth2User.class);ApplicationContext context = getContext();String[] names= context.getBeanNamesForType(type);if (names.length == 1) { OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; bean =  (OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt;) context.getBean(names[0]);}</code></pre><p><code>ResolvableType</code>居然可以这样获取一个带泛型的类型，于是就研究了一番。</p><h2 id="2-ResolvableType"><a href="#2-ResolvableType" class="headerlink" title="2. ResolvableType"></a>2. ResolvableType</h2><p>通常我们想获取一个类型的信息都要通过 Java 反射从对应的<code>Class</code>类型中来获取信息，API 非常地底层，操作也十分繁琐。<code>ResolvableType</code>的出现简化了这一过程，文章的开头就是<code>ResolvableType</code>通过其静态方法来描述了一个带泛型的类型<code>OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt;</code>，然后就可以从<strong>Spring IoC</strong>中获取对应的<strong>Spring Bean</strong>。那么它还有其它那些功能呢？</p><p><code>ResolvableType</code>不能被直接实例化，不过它提供了很多的静态方法。</p><h3 id="forClass"><a href="#forClass" class="headerlink" title="forClass"></a>forClass</h3><p>从<code>Class</code>对象中获取类型的信息，它有一个重载方法可以从基类和实现类中获取组合的类型信息，例如：</p><pre><code>//  java.lang.StringResolvableType resolvableType1 = ResolvableType.forClass(String.class);//  java.util.Map&lt;?, ?&gt;ResolvableType resolvableType2 = ResolvableType.forClass(Map.class, HashMap.class);</code></pre><h3 id="forClassWithGenerics"><a href="#forClassWithGenerics" class="headerlink" title="forClassWithGenerics"></a>forClassWithGenerics</h3><p>从<code>Class</code>对象中获取类型的信息,并且携带泛型，文章开头的例子就是。</p><h3 id="forConstructorParameter"><a href="#forConstructorParameter" class="headerlink" title="forConstructorParameter"></a>forConstructorParameter</h3><p>获取构造函数中特定参数的元信息，例如</p><pre><code>User user = new User(“张三”); Constructor&lt;?&gt; constructor = user.getClass().getConstructors()[0]// java.lang.StringResolvableType.forConstructorParameter(constructor,0)</code></pre><h3 id="forField"><a href="#forField" class="headerlink" title="forField"></a>forField</h3><p>从成员属性中获取成员属性的类型信息。例如：</p><pre><code>    private HashMap&lt;String, List&lt;Object&gt;&gt; map;    public void test() throws NoSuchFieldException {        Field field = getClass().getDeclaredField("map");        // java.util.HashMap&lt;java.lang.String, java.util.List&lt;java.lang.Object&gt;&gt;        ResolvableType resolvableType = ResolvableType.forField(field);    }</code></pre><h3 id="forMethodParameter"><a href="#forMethodParameter" class="headerlink" title="forMethodParameter"></a>forMethodParameter</h3><p>获取方法的参数类型信息。</p><pre><code>User user = new User(“张三”);// setName(String)Method method = user.getClass().getMethods()[0];// java.lang.StringResolvableType.forMethodParameter(method,0)</code></pre><h3 id="forMethodReturnType"><a href="#forMethodReturnType" class="headerlink" title="forMethodReturnType"></a>forMethodReturnType</h3><p>获取方法返回值的类型信息。</p><h3 id="forArrayComponent"><a href="#forArrayComponent" class="headerlink" title="forArrayComponent"></a>forArrayComponent</h3><p>获取特定类型组成的数组形式。例如</p><pre><code>ResolvableType resolvableType = ResolvableType.forClass(String.class);// java.lang.String []ResolvableType arrayComponent = ResolvableType.forArrayComponent(resolvableType);</code></pre><h3 id="forInstance"><a href="#forInstance" class="headerlink" title="forInstance"></a>forInstance</h3><p>甚至还可以从对象实例中获取该对象的类型信息。</p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><blockquote><p>那么问题来了，这到底有什么用呢？</p></blockquote><p>当你需要利用反射获取 类实例、成员变量、方法的信息时就可以使用该操作类。它提供了获取基类、接口、<code>Class</code>对象、泛型类型等解析功能。例如我们可以从一个成员变量中可以获取：</p><pre><code> private HashMap&lt;Integer, List&lt;String&gt;&gt; myMap;   public void example() {       ResolvableType t = ResolvableType.forField(getClass().getDeclaredField("myMap"));       t.getSuperType(); // AbstractMap&lt;Integer, List&lt;String&gt;&gt;       t.asMap(); // Map&lt;Integer, List&lt;String&gt;&gt;       t.getGeneric(0).resolve(); // Integer       t.getGeneric(1).resolve(); // List       t.getGeneric(1); // List&lt;String&gt;       t.resolveGeneric(1, 0); // String   }</code></pre><p>感觉可以替代一些常见的反射操作，而且易用性更强。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造测试数据</title>
      <link href="2021/01/14/gou-zao-ce-shi-shu-ju/"/>
      <url>2021/01/14/gou-zao-ce-shi-shu-ju/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>老板说，明天甲方要来看产品，你得搞点数据，而且数据必须是“真”的，演示效果要好看一些，这样甲方才会采购咱们的产品。一般开发接到这种过分要求都不会很乐意去做，这完全是体力劳动了，而且很棘手。今天胖哥教你一招，让你做出逼真的“假”数据。</p><h2 id="2-javafaker"><a href="#2-javafaker" class="headerlink" title="2. javafaker"></a>2. javafaker</h2><p>这张图大家都很熟悉吧。我们Java也能搞<strong>Fake</strong>，它就是<strong>Javafaker</strong>，专门用来制作仿真数据。你只需要在项目中引入：</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;com.github.javafaker&lt;/groupId&gt;            &lt;artifactId&gt;javafaker&lt;/artifactId&gt;            &lt;version&gt;1.0.2&lt;/version&gt;        &lt;/dependency&gt;</code></pre><blockquote><p>❝</p><p>忘记说了它主要的使用场景就是为了制造仿真测试数据，而并不是用来造假。</p></blockquote><p>然后胖哥来演示一下它的用法，先定义一个 Java Bean :</p><pre><code>/** * User info. * * @author felord.cn * @since 10 :50 */@Datapublic class UserInfo {  /**   * 真实姓名   */  private String realName;  /**   * 手机   */  private String cellPhone;  /**   * 大学   */  private String universityName;  /**   * 城市   */  private String city;  /**   * 地址   */  private String street;}</code></pre><p>然后声明一个<code>Faker</code>对象，你可以根据需要进行本地化声明，如果是使用中国的：</p><pre><code>        Faker fakerWithCN = new Faker(Locale.CHINA);</code></pre><p>你要是想造点美帝的数据就改成这样：</p><pre><code>        Faker fakerWithCN = new Faker(Locale.US);</code></pre><p>这里我们使用中国来生成模拟 10 条仿真数据：</p><pre><code>for (int i = 0; i &lt; 10; i++) {    UserInfo userInfo = new UserInfo();    userInfo.setRealName(fakerWithCN.name().fullName());    userInfo.setCellPhone(fakerWithCN.phoneNumber().cellPhone());    userInfo.setCity(fakerWithCN.address().city());    userInfo.setStreet(fakerWithCN.address().streetAddress());    userInfo.setUniversityName(fakerWithCN.university().name());    System.out.println("userInfo = " + userInfo);}</code></pre><p>我们来看下结果：</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zuF5sJGRDCueqhr8q4kQuiacDNLwxBXuO3knp3dRAUfLmk1fnBcMPQwXIUNUrtWOzTCiaMTA6GgLAjeiaiaqr6gvow/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">javafaker生成的仿真数据</p><p>是不是看上去跟真的一样，但是一定要用到正途，不要用到歪门邪道上。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>用了<strong>javafaker</strong>之后我们不但可以完成老板提出的需求，而且可以减少我们平常使用测试的时候用各种<code>test</code>填充的局面。好了今天的分享就到这里。我是 <strong>码农小胖哥</strong>，多多关注，获取更多有用的编程干货。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全传输存储用户密码</title>
      <link href="2021/01/14/an-quan-chuan-shu-cun-chu-yong-hu-mi-ma/"/>
      <url>2021/01/14/an-quan-chuan-shu-cun-chu-yong-hu-mi-ma/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们开发网站或者APP的时候，首先要解决的问题，就是<strong>「如何安全传输和存储用户的密码」</strong>。一些大公司的用户数据库泄露事件也时有发生，带来非常大的负面影响。因此，如何安全传输存储用户密码，是每位程序员必备的基础。本文将跟大家一起学习，如何安全传输存储用户的密码。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzEpk6ntEX7b3mqStzjpnnFxe5TAf5e8Ix53yb0o2xspwja37ajQXMqicP19D86ASAJZsvsicoSxlKyg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h3 id="1-如何安全地传输用户的密码"><a href="#1-如何安全地传输用户的密码" class="headerlink" title="1. 如何安全地传输用户的密码"></a>1. 如何安全地传输用户的密码</h3><p>要拒绝用户密码在网络上裸奔，我们很容易就想到使用https协议，那先来回顾下https相关知识吧~</p><h4 id="1-1-https-协议"><a href="#1-1-https-协议" class="headerlink" title="1.1 https 协议"></a>1.1 https 协议</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzEpk6ntEX7b3mqStzjpnnFx0ic83NnKib58cJ5rJb3PMdN2vVyoUwmicooAnHYXLPvelFJBmnnfqAP9w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><ul><li><strong>「http的三大风险」</strong></li></ul><p>为什么要使用https协议呢？<strong>「http它不香」</strong>吗? 因为http是明文信息传输的。如果在茫茫的网络海洋，使用http协议，有以下三大风险：</p><blockquote><p>❝</p><ul><li>窃听/嗅探风险：第三方可以截获通信数据。</li><li>数据篡改风险：第三方获取到通信数据后，会进行恶意修改。</li><li>身份伪造风险：第三方可以冒充他人身份参与通信。</li></ul><p>❞</p></blockquote><p>如果传输不重要的信息还好，但是传输用户密码这些敏感信息，那可不得了。所以一般都要使用<strong>「https协议」</strong>传输用户密码信息。</p><ul><li><strong>「https 原理」</strong></li></ul><p>https原理是什么呢？为什么它能解决http的三大风险呢？</p><blockquote><p>❝</p><p>https = http + SSL/TLS, SSL/TLS 是传输层加密协议，它提供内容加密、身份认证、数据完整性校验，以解决数据传输的安全性问题。</p><p>❞</p></blockquote><p>为了加深https原理的理解，我们一起复习一下<strong>「一次完整https的请求流程」</strong>吧~</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzEpk6ntEX7b3mqStzjpnnFxoWOZ4MdCiaerUozt14GTRURqdSbPHOVznb0Liamz0BkBIJLTlJ1EIAgA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><blockquote><p>❝</p><ul><li><ol><li>客户端发起https请求</li></ol></li></ul><ol start="2"><li>服务器必须要有一套数字证书，可以自己制作，也可以向权威机构申请。这套证书其实就是一对公私钥。</li></ol><ol start="3"><li>服务器将自己的数字证书（含有公钥、证书的颁发机构等）发送给客户端。</li></ol><ol start="4"><li>客户端收到服务器端的数字证书之后，会对其进行验证，主要验证公钥是否有效，比如颁发机构，过期时间等等。如果不通过，则弹出警告框。如果证书没问题，则生成一个密钥（对称加密算法的密钥，其实是一个随机值），并且用证书的公钥对这个随机值加密。</li></ol><ol start="5"><li>客户端会发起https中的第二个请求，将加密之后的客户端密钥(随机值)发送给服务器。</li></ol><ol start="6"><li>服务器接收到客户端发来的密钥之后，会用自己的私钥对其进行非对称解密，解密之后得到客户端密钥，然后用客户端密钥对返回数据进行对称加密，这样数据就变成了密文。</li></ol><ol start="7"><li>服务器将加密后的密文返回给客户端。</li></ol><ol start="8"><li>客户端收到服务器发返回的密文，用自己的密钥（客户端密钥）对其进行对称解密，得到服务器返回的数据。</li></ol><p>❞</p></blockquote><ul><li><strong>「https一定安全吗？」</strong></li></ul><p>https的数据传输过程，数据都是密文的，那么，使用了https协议传输密码信息，一定是安全的吗？其实<strong>「不然」</strong>~</p><blockquote><p>❝</p><ul><li>比如，https 完全就是建立在证书可信的基础上的呢。但是如果遇到中间人伪造证书，一旦客户端通过验证，安全性顿时就没了哦！平时各种钓鱼不可描述的网站，很可能就是黑客在诱导用户安装它们的伪造证书！</li><li>通过伪造证书，https也是可能被抓包的哦。</li></ul><p>❞</p></blockquote><h4 id="1-2-对称加密算法"><a href="#1-2-对称加密算法" class="headerlink" title="1.2 对称加密算法"></a>1.2 对称加密算法</h4><p>既然使用了https协议传输用户密码，还是<strong>「不一定安全」</strong>，那么，我们就给用户密码<strong>「加密再传输」</strong>呗~</p><p>加密算法有<strong>「对称加密」</strong>和<strong>「非对称加密」</strong>两大类。用哪种类型的加密算法<strong>「靠谱」</strong>呢？</p><blockquote><p>❝</p><p>对称加密：加密和解密使用<strong>「相同密钥」</strong>的加密算法。<img src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzEpk6ntEX7b3mqStzjpnnFx5IzaN1j8Ko3z7SBfiaiavItIib2gYBC0nhkL8vR1EHptOxeQPodMuoLcA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>❞</p></blockquote><p>常用的对称加密算法主要有以下几种哈：<img src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzEpk6ntEX7b3mqStzjpnnFxfH1zNeLbd72hHqE4ibYhvofMrCbKtiaPEgYBoicLQciaxDzPEE0ksiaaVjg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>如果使用对称加密算法，需要考虑<strong>「密钥如何给到对方」</strong>，如果密钥还是网络传输给对方，传输过程，被中间人拿到的话，也是有风险的哦。</p><h4 id="1-3-非对称加密算法"><a href="#1-3-非对称加密算法" class="headerlink" title="1.3 非对称加密算法"></a>1.3 非对称加密算法</h4><p>再考虑一下非对称加密算法呢？</p><blockquote><p>❝</p><p><strong>「非对称加密：」</strong> 非对称加密算法需要两个密钥（公开密钥和私有密钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。</p><p>❞</p></blockquote><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzEpk6ntEX7b3mqStzjpnnFxDGl5SL4GnT8Tfic1ypegKGCtm98DUmjMh8MWibeibVB7j3omrVT78omUA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>常用的非对称加密算法主要有以下几种哈：<img src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzEpk6ntEX7b3mqStzjpnnFxWPnwZ9nVMDOxsjEaZIh4FHffj7BXYrpzU5mfzrmzC0ILTCBdmpMNibA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><blockquote><p>❝</p><p>如果使用非对称加密算法，也需要考虑<strong>「密钥公钥如何给到对方」</strong>，如果公钥还是网络传输给对方，传输过程，被中间人拿到的话，会有什么问题呢？<strong>「他们是不是可以伪造公钥，把伪造的公钥给客户端，然后，用自己的私钥等公钥加密的数据过来？」</strong> 大家可以思考下这个问题哈~</p><p>❞</p></blockquote><p>我们直接<strong>「登录一下百度」</strong>，抓下接口请求，验证一发大厂是怎么加密的。可以发现有获取公钥接口，如下:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzEpk6ntEX7b3mqStzjpnnFx2s1LyoAF3VZPmrzkr0kCSfHP51bGxvJJKXEZpdIRKcYwl67goGicZ2A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>再看下登录接口，发现就是RSA算法，RSA就是<strong>「非对称加密算法」</strong>。其实百度前端是用了JavaScript库<strong>「jsencrypt」</strong>，在github的star还挺多的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzEpk6ntEX7b3mqStzjpnnFxZlRKN6pK1oArib3ATpnjnO3pL28cCicicJtvLORFbkKpIYT6YVjfaIS7Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>因此，我们可以用<strong>「https + 非对称加密算法（如RSA）」</strong> 传输用户密码~</p><h3 id="2-如何安全地存储你的密码？"><a href="#2-如何安全地存储你的密码？" class="headerlink" title="2. 如何安全地存储你的密码？"></a>2. 如何安全地存储你的密码？</h3><p>假设密码已经安全到达服务端啦，那么，如何存储用户的密码呢？一定不能明文存储密码到数据库哦！可以用<strong>「哈希摘要算法加密密码」</strong>，再保存到数据库。</p><blockquote><p>❝</p><p>哈希摘要算法：只能从明文生成一个对应的哈希值，不能反过来根据哈希值得到对应的明文。</p><p>❞</p></blockquote><h4 id="2-1-MD5摘要算法保护你的密码"><a href="#2-1-MD5摘要算法保护你的密码" class="headerlink" title="2.1  MD5摘要算法保护你的密码"></a>2.1  MD5摘要算法保护你的密码</h4><p>MD5 是一种非常经典的哈希摘要算法，被广泛应用于数据完整性校验、数据（消息）摘要、数据加密等。但是仅仅使用 MD5 对密码进行摘要，并不安全。我们看个例子，如下：</p><pre><code>public class MD5Test {    public static void main(String[] args) {        String password = "abc123456";        System.out.println(DigestUtils.md5Hex(password));    }}</code></pre><p>运行结果：</p><pre><code>0659c7992e268962384eb17fafe88364</code></pre><p>在MD5免费破解网站一输入，马上就可以看到原密码了。。。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sMmr4XOCBzEpk6ntEX7b3mqStzjpnnFxmL08riaXaiadq1tMibqOYqt5Mg2cvBKQXicsPibB7j2dZgO4nu7PjaibYXaw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>试想一下，如果黑客构建一个超大的数据库，把所有20位数字以内的数字和字母组合的密码全部计算MD5哈希值出来，并且把密码和它们对应的哈希值存到里面去（这就是<strong>「彩虹表」</strong>）。在破解密码的时候，只需要查一下这个彩虹表就完事了。所以<strong>「单单MD5对密码取哈希值存储」</strong>，已经不安全啦~</p><h4 id="2-2-MD5-盐摘要算法保护用户的密码"><a href="#2-2-MD5-盐摘要算法保护用户的密码" class="headerlink" title="2.2  MD5+盐摘要算法保护用户的密码"></a>2.2  MD5+盐摘要算法保护用户的密码</h4><p>那么，为什么不试一下MD5+盐呢？什么是<strong>「加盐」</strong>？</p><blockquote><p>❝</p><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</p><p>❞</p></blockquote><p>用户密码+盐之后，进行哈希散列，再保存到数据库。这样可以有效应对彩虹表破解法。但是呢，使用加盐，需要注意一下几点：</p><blockquote><p>❝</p><ul><li>不能在代码中写死盐，且盐需要有一定的长度（盐写死太简单的话，黑客可能注册几个账号反推出来）</li><li>每一个密码都有独立的盐，并且盐要长一点，比如超过 20 位。(盐太短，加上原始密码太短，容易破解)</li><li>最好是随机的值，并且是全球唯一的，意味着全球不可能有现成的彩虹表给你用。</li></ul><p>❞</p></blockquote><h4 id="2-3-提升密码存储安全的利器登场，Bcrypt"><a href="#2-3-提升密码存储安全的利器登场，Bcrypt" class="headerlink" title="2.3 提升密码存储安全的利器登场，Bcrypt"></a>2.3 提升密码存储安全的利器登场，Bcrypt</h4><p>即使是加了盐，密码仍有可能被暴力破解。因此，我们可以采取更<strong>「慢一点」</strong>的算法，让黑客破解密码付出更大的代价，甚至迫使他们放弃。提升密码存储安全的利器~Bcrypt，可以闪亮登场啦。</p><blockquote><p>❝</p><p>实际上，Spring Security 已经废弃了 MessageDigestPasswordEncoder，推荐使用BCryptPasswordEncoder，也就是BCrypt来进行密码哈希。BCrypt 生而为保存密码设计的算法，相比 MD5 要慢很多。</p><p>❞</p></blockquote><p>看个例子对比一下吧：</p><pre><code>public class BCryptTest {    public static void main(String[] args) {        String password = "123456";        long md5Begin = System.currentTimeMillis();        DigestUtils.md5Hex(password);        long md5End = System.currentTimeMillis();        System.out.println("md5 time:"+(md5End - md5Begin));        long bcrytBegin = System.currentTimeMillis();        BCrypt.hashpw(password, BCrypt.gensalt(10));        long bcrytEnd = System.currentTimeMillis();        System.out.println("bcrypt Time:" + (bcrytEnd- bcrytBegin));    }}</code></pre><p>运行结果：</p><pre><code>md5 time:47bcrypt Time:1597</code></pre><p>粗略对比发现，BCrypt比MD5慢几十倍，黑客想暴力破解的话，就需要花费几十倍的代价。因此一般情况，建议使用Bcrypt来存储用户的密码</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul><li>因此，一般使用https 协议 + 非对称加密算法（如RSA）来传输用户密码，为了更加安全，可以在前端构造一下随机因子哦。</li><li>使用BCrypt + 盐存储用户密码。</li><li>在感知到暴力破解危害的时候，<strong>「开启短信验证、图形验证码、账号暂时锁定」</strong>等防御机制来抵御暴力破解。</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1]如何正确保存和传输敏感数据？:<a href="https://time.geekbang.org/column/article/239150">https://time.geekbang.org/column/article/239150</a></p><p>[2]如何加密传输和存储用户密码:<a href="https://juejin.cn/post/6844903604944371726#heading-8">https://juejin.cn/post/6844903604944371726#heading-8</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encryption </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java deploy by docker</title>
      <link href="2021/01/14/java-deploy-by-docker/"/>
      <url>2021/01/14/java-deploy-by-docker/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p><strong>Docker</strong> 是啥？好处是啥？ 什么现在如果作为一名开发你还不知道甚至没有用过我都感觉你落伍了。<strong>Docker</strong> 是一种虚拟化的容器技术，目的为了打造持续集成、版本控制、可移植性、隔离性和安全性的应用集成。这都是官话。其实我认为最简单的理解就是 <strong>Docker</strong> 能给你的应用打造一套隔离的应用环境。只要能跑docker的环境，不管是<strong>Linux</strong>，还是 <strong>Mac</strong>，还是 <strong>windows</strong> 都能快速把你的应用部署过来甚至达到秒级启动。如果你有个<strong>Mysql</strong>集群镜像，你瞬间就能启动一个 <strong>Mysql</strong> 集群，如果让你用手撸一个估计得一袋烟的工夫。看到这里如果没用过 <strong>Docker</strong>，赶紧找资料学习去，并不难学。 别忘记关注一下，回来接着下面的干货分享。 那么今天我将如何将 <strong>Spring Boot</strong> 应用容器化。</p><h2 id="2-环境"><a href="#2-环境" class="headerlink" title="2. 环境"></a>2. 环境</h2><ul><li>Spring Boot 版本2.2.0.RELEASE</li><li><code>Jdk</code> 版本 <code>java 8</code> 这里可以选择 <code>openjdk8</code> 或者 <code>oracle jdk8</code></li><li><code>Docker</code> 环境自己可以选择 <code>Linux</code>，<code>Mac</code>或者<code>Win10专业版</code> 没有太多区别</li><li>开发工具 <code>Idea 2019</code> 旗舰版</li></ul><h2 id="3-Spring-Boot-应用"><a href="#3-Spring-Boot-应用" class="headerlink" title="3. Spring Boot 应用"></a>3. Spring Boot 应用</h2><p>通过 Idea 搭建一个简单的名称为<code>docker-springboot</code> 的 springboot web maven应用。 并编写一个 Spring MVC 接口。</p><pre><code>    @GetMapping("/hello")  public Map&lt;String,String&gt; hello(){      Map&lt;String, String&gt; map = new HashMap&lt;&gt;(3);           map.put("aud","码农小胖哥");           map.put("msg","关注我学习更多的原创知识");           map.put("time", LocalDateTime.now().format(DateTimeFormatter.ofPattern("YYYY-MM-dd HH:MM:ss")));           return  map;  }</code></pre><p>接下来我们要把spring boot打包成可执行jar</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/zuF5sJGRDCtPdxEBibUJl86CVxEFpGnFibYmDpaEUbrO8dMybajibuTIEZMnKqc25vH2INRTbCVTXNWOgCzABia8zQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>点击上图的 <code>package</code> 或者熟悉 <strong>Maven</strong>的用高逼格命令行操作 <code>mvn clean package</code> 编译好后会在 <code>target</code> 目录下找到一个打包好的 <code>jar</code> 文件。</p><h2 id="4-编写-Docker-脚本"><a href="#4-编写-Docker-脚本" class="headerlink" title="4. 编写 Docker 脚本"></a>4. 编写 Docker 脚本</h2><p>下来该编写 <strong>Docker</strong> 创建镜像的打包脚本，名称必须是 <strong>Dockerfile</strong>，位置为项目根目录，还有通过 Maven 插件来操作位置不尽相同。内容如下</p><pre><code>   # 使用aws 的 openjdk8   FROM amazoncorretto:8   # 作者署名   MAINTAINER Felordcn   # 挂载的容器磁盘   VOLUME ["/tmp"]   # 使用东八区时间 环境 其他环境参数也可以通过ENV 声明   ENV TZ=Asia/Shanghai   RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone   #  add 命令是 将主机构建环境（上下文）目录中的文件和目录、以及一个URL标记的文件 拷贝到镜像中   ADD /target/docker-springboot-0.0.1-SNAPSHOT.jar app.jar   # 暴露端口 跟springboot 默认应用端口一样   EXPOSE 8080   #  启动镜像就执行的命令操作   相当于执行  java -jar  app.jar  -Djava.security.egd=file:/dev/./urandom     最后的指令是为了加快启动   ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","app.jar"]</code></pre><h2 id="5-构建镜像"><a href="#5-构建镜像" class="headerlink" title="5. 构建镜像"></a>5. 构建镜像</h2><p>然后在项目目录下打开命令行工具（idea 自带有）执行脚本（记得启动docker）不要忘记最后的点 代表当前路径 其他路径 写相对路径</p><pre><code>   docker build -t docker-springboot:0.0.1 .</code></pre><p>然后进入下面的分层构建阶段，走到最后镜像就成了</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/zuF5sJGRDCtPdxEBibUJl86CVxEFpGnFibxWSjwFGwibpbBAAsDxHD9qicicxwocCOr8LBj6Z9lsoO3BfMib8XZ6CXaQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h2 id="6-启动容器"><a href="#6-启动容器" class="headerlink" title="6. 启动容器"></a>6. 启动容器</h2><p>命令行 执行 <code>docker images</code> 查看一下是否存在 一个 <code>docker-springboot：0.0.1</code> 的镜像，只要结果跟上图一样就一定存在。然后从镜像启动一个容器，命令行如下</p><pre><code>   docker run --name docker-app -p 8088:8080 docker-springboot:0.0.1</code></pre><p>该命令的意思是 我前台从 <code>docker-springboot:0.0.1</code> 镜像启动一个名字叫 <code>docker-app</code>的容器应用，同时将容器<code>内部端口8080</code>映射到<code>宿主机端口8088</code> ，这样我们可以通过本地端口<code>8088</code>访问容器端口<code>8080</code> 。然后你访问上面写好的那个接口 <code>http://localhost:8088/docker/hello</code></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/zuF5sJGRDCtPdxEBibUJl86CVxEFpGnFibfyYxBiaQxw5OE0ibyJJgnf1JicW32vseSicomUyiakQCUTgTiamSbgK6mn6Q/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>大功告成。 这样我们就简单的实现了 <strong>Spring Boot</strong> 应用的容器化</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>应用容器化是近年来的热点。而且容器技术层出不穷，掌握应用的容器化技术还是很有必要的。今天我们一步一步从零利用 <strong>Docker</strong> 构建了一个 <code>Spring Boot</code> 容器 。希望对你有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.0 的配置绑定类Bindable居然如此强大</title>
      <link href="2021/01/14/spring-boot-2-0-de-pei-zhi-bang-ding-lei-bindable-ju-ran-ru-ci-qiang-da/"/>
      <url>2021/01/14/spring-boot-2-0-de-pei-zhi-bang-ding-lei-bindable-ju-ran-ru-ci-qiang-da/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在开发<strong>Spring Boot</strong>应用时会用到根据条件来向<strong>Spring IoC</strong>容器注入<strong>Bean</strong>。比如配置文件存在了某个配置属性才注入<strong>Bean</strong> ：</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zuF5sJGRDCtztsjKj45H5hianGghoUWD89obARqhYETibdyH0iabmnLMzZWx8aRwMRgia0nh9MfSuxLcUxPZ3v5YMQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">根据配置属性来动态注入Bean</p><p>图中红色的部分是说，只有<code>ali.pay.v1.app-id</code>存在于<strong>Spring</strong>的环境配置中时这个<code>@Configuration</code>标记的类才能注入<strong>Spring IoC</strong>。</p><p>这里面的<code>@ConditionalOnProperty</code>就是条件注解系列的一种。它还有很多种来满足各种场景的条件注解：</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zuF5sJGRDCtztsjKj45H5hianGghoUWD8kMUXIcWyZs5VT9RbibPy1zLEicNH44eeVU6sNFzy6qwKiaBdGiaGwqbv4Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">条件注解家族</p><blockquote><p>❝</p><p>其实数量远不止截图中这几个，在 Spring 家族的其它框架中也有实现。</p></blockquote><p>这里扯得有点远了，今天不是来讲这些条件控制注解的用法的，只是我发现了一个使用条件注解<code>@ConditionalOnProperty</code>无法解决的问题。</p><h2 id="2-配置文件存在-Map-结构的场景"><a href="#2-配置文件存在-Map-结构的场景" class="headerlink" title="2. 配置文件存在 Map 结构的场景"></a>2. 配置文件存在 Map 结构的场景</h2><p>下面是一段配置文件：</p><pre><code>app: v1:  foo:    name: felord.cn    description: 码农小胖哥  bar:    name: ooxx.cn    description: xxxxxx</code></pre><p>对应配置类：</p><pre><code>@Data@ConfigurationProperties("app")public class AppProperties {    /**     *     */    private Map&lt;String, V1&gt; v1 = new HashMap&lt;&gt;();    /**     *     *     * @author felord.cn     * @since 1.0.0.RELEASE     */    @Data    public static class V1 {        /**         * name         */        private String name;        /**         * description         */        private String description;    }}</code></pre><p>特殊之处来了<code>yml</code>配置里的 <code>foo</code>、<code>bar</code>其实是作为<code>Map</code>中的<code>key</code>来标识<code>V1</code>的，和其它配置参数不同这个<code>key</code>用户可以随意定义一个<code>String</code>来标识，可能是<code>foo</code>，可能是<code>bar</code>，完全根据开发者的喜好进行主观定义。这个时候 你想根据<code>app.v1.*.name</code>（暂时用通配符<code>*</code>）来进行<code>@ConditionalOnProperty</code>判断是行不通的，因为你不确定<code>*</code>的值，该怎么办呢？</p><h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h2><p>这里我花了一天的时间去摸索，最开始我认为 Spring 提供通配符（<code>app.v1.*.name</code>）甚至是<code>SpringEL</code>表达式可以拿到，但是搞了半天无功而返。</p><p>突然我想到之前看<strong>Spring Security OAuth2</strong>源码中有类似的逻辑。用过<strong>Spring Security OAuth2</strong>相关的都知道<strong>Spring Security OAuth2</strong>也要求用户自定义一个<code>key</code>来标识自己的<strong>OAuth2</strong>客户端。比如我用<strong>Gitee</strong>的：</p><pre><code>spring:  security:    oauth2:      client:        registration:          gitee:            client-id: xxxxxx            client-secret: xxxxx</code></pre><blockquote><p>❝</p><p>这里的<code>key</code>就是<code>gitee</code>,当然这根据您的心情决定，甚至你用<code>zhangshan</code>作为<code>key</code>都可以。</p></blockquote><p><strong>Spring Security OAuth2</strong> 提供了相关的条件注入思路，下面是其条件注入判断的核心类：</p><pre><code>public class ClientsConfiguredCondition extends SpringBootCondition {   private static final Bindable&lt;Map&lt;String, OAuth2ClientProperties.Registration&gt;&gt; STRING_REGISTRATION_MAP = Bindable         .mapOf(String.class, OAuth2ClientProperties.Registration.class);   @Override   public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {      ConditionMessage.Builder message = ConditionMessage.forCondition("OAuth2 Clients Configured Condition");      Map&lt;String, OAuth2ClientProperties.Registration&gt; registrations = getRegistrations(context.getEnvironment());      if (!registrations.isEmpty()) {         return ConditionOutcome.match(message.foundExactly("registered clients " + registrations.values().stream()               .map(OAuth2ClientProperties.Registration::getClientId).collect(Collectors.joining(", "))));      }      return ConditionOutcome.noMatch(message.notAvailable("registered clients"));   }   private Map&lt;String, OAuth2ClientProperties.Registration&gt; getRegistrations(Environment environment) {      return Binder.get(environment).bind("spring.security.oauth2.client.registration", STRING_REGISTRATION_MAP)            .orElse(Collections.emptyMap());   }}</code></pre><p>显然<code>OAuth2ClientProperties</code>的结构和我们要验证的<code>AppProperties</code>结构是一样的。所以上面的逻辑是可以抄过来的，它可以将环境配置中的带有不确定<code>key</code>的配置绑定到我们的配置类<code>AppProperties</code>中。核心的绑定逻辑是这一段：</p><pre><code>Binder.get(environment).bind("spring.security.oauth2.client.registration", STRING_REGISTRATION_MAP)</code></pre><p>首先通过<code>Bindable</code>来声明一个可绑定的数据结构,这里调用了<code>mapOf</code>方法声明了一个<code>Map</code>的数据绑定结构。然后通过绑定的具体操作对象<code>Binder</code>从配置环境接口<code>Environment</code>中提取了<code>spring.security.oauth2.client.registration</code>开头的配置属性并注入到<code>Map</code>中去。既然我们能够获取到了<code>Map</code>，根据什么策略判断就完全掌握在我们手中了。</p><blockquote><p>❝</p><p><code>Bindable</code>为 Spring Boot 2.0 提供的数据绑定新特性，这里只是它的运用的场景之一。有兴趣可从 spring.io 获取更多信息。</p></blockquote><p>接下来不用我说了吧，照葫芦画瓢还有谁不会呢？配合<code>@Conditional</code>注解就能实现根据<code>app.v1</code>下参数的实际情况来动态的进行 Bean 注入。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>今天利用<strong>Spring Boot 2.0</strong>的数据绑定特性解决了一个实际需求，花了不少时间。当我们解决问题陷入困境时，首先要去想想有没有类似场景以及对应的解决方案。这同样说明平时的积累很重要，很多粉丝的问题其实公众号都有讲过，所以处处留心解释学问。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动安装nginx</title>
      <link href="2021/01/06/install-nginx/"/>
      <url>2021/01/06/install-nginx/</url>
      
        <content type="html"><![CDATA[<h4 id="安装gcc等编译环境"><a href="#安装gcc等编译环境" class="headerlink" title="安装gcc等编译环境"></a>安装gcc等编译环境</h4><pre class="line-numbers language-shell"><code class="language-shell">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="下载nginx-1-18-0-tar-gz并解压"><a href="#下载nginx-1-18-0-tar-gz并解压" class="headerlink" title="下载nginx-1.18.0.tar.gz并解压"></a>下载nginx-1.18.0.tar.gz并解压</h4><pre class="line-numbers language-shell"><code class="language-shell">wget http://nginx.org/download/nginx-1.18.0.tar.gztar -zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><pre class="line-numbers language-shell"><code class="language-shell">mkdir -p /var/tempmkdir -p /var/temp/nginxmkdir -p /var/temp/run/nginxchmod a+wrx -R temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置编译选项"><a href="#配置编译选项" class="headerlink" title="配置编译选项"></a>配置编译选项</h4><pre class="line-numbers language-shell"><code class="language-shell">./configure \--prefix=/usr/local/nginx \--pid-path=/var/temp/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>切记，pid-path不能设置为/var/run/nginx/nginx.pid。因为CentOS每次重启后，都会删除/var/run目录中的自建目录和文件，从而导致nginx自启动失败。</p></blockquote><h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><pre class="line-numbers language-shell"><code class="language-shell">make && make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>进入/usr/local/nginx查看文件是否存在conf、sbin、html文件夹，若存在则安装成功</p></blockquote><h4 id="测试启动"><a href="#测试启动" class="headerlink" title="测试启动"></a>测试启动</h4><pre class="line-numbers language-shell"><code class="language-shell">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果不指定-c，nginx在启动时默认加载conf/nginx.conf文件，此文件的地址也可以在编译安装nginx时指定./configure的参数(–conf-path= 指向配置文件（nginx.conf）)</p></blockquote><h4 id="测试访问"><a href="#测试访问" class="headerlink" title="测试访问"></a>测试访问</h4><pre class="line-numbers language-shell"><code class="language-shell">curl localhost<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>浏览器如果不能访问，就打开防火墙或者开端口。</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell"># 关闭防火墙systemctl stop firewalld.service# 开放端口firewall-cmd --zone=public --add-port=80/tcp --permanent，firewall-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h2><h4 id="在系统服务目录里创建nginx-service文件"><a href="#在系统服务目录里创建nginx-service文件" class="headerlink" title="在系统服务目录里创建nginx.service文件"></a>在系统服务目录里创建nginx.service文件</h4><pre class="line-numbers language-shell"><code class="language-shell">vi /usr/lib/systemd/system/nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="写入内容如下："><a href="#写入内容如下：" class="headerlink" title="写入内容如下："></a>写入内容如下：</h4><pre class="line-numbers language-shell"><code class="language-shell">[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明:</p><ul><li>[Unit]服务的说明</li><li>Description:描述服务</li><li>After:描述服务类别</li><li>[Service]服务运行参数的设置</li><li>Type=forking是后台运行的形式</li><li>ExecStart为服务的具体运行命令</li><li>ExecReload为重启命令</li><li>ExecStop为停止命令</li><li>PrivateTmp=True表示给服务分配独立的临时空间</li><li>注意：[Service]的启动、重启、停止命令全部要求使用绝对路径</li><li>[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</li></ul><h4 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h4><pre class="line-numbers language-shell"><code class="language-shell">systemctl enable nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="查看nginx状态"><a href="#查看nginx状态" class="headerlink" title="查看nginx状态"></a>查看nginx状态</h4><pre class="line-numbers language-shell"><code class="language-shell">systemctl status nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>很奇怪，明明启动成功了，为什么显示Active: inactive (dead)？</p></blockquote><h4 id="杀死nginx重启nginx"><a href="#杀死nginx重启nginx" class="headerlink" title="杀死nginx重启nginx"></a>杀死nginx重启nginx</h4><pre class="line-numbers language-shell"><code class="language-shell">pkill -9 nginxps aux | grep nginxsystemctl start nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>再次查看状态，变成了active，搞定。</p></blockquote><h4 id="重启服务器"><a href="#重启服务器" class="headerlink" title="重启服务器"></a>重启服务器</h4><pre class="line-numbers language-shell"><code class="language-shell">reboot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="再次连接后，查看服务状态"><a href="#再次连接后，查看服务状态" class="headerlink" title="再次连接后，查看服务状态"></a>再次连接后，查看服务状态</h4><pre class="line-numbers language-shell"><code class="language-shell">systemctl status nginx.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>看到nginx已经启动，至此，nginx自启动配置成功。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> linux - install </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用nginx代理centos yum 源</title>
      <link href="2021/01/06/nginx-proxy-yum/"/>
      <url>2021/01/06/nginx-proxy-yum/</url>
      
        <content type="html"><![CDATA[<p>我们在安装centos 服务器时，可能会有以下情况：</p><p>　　局域网内有若干台服务器，但是只有一台服务器可以连接外网，其余服务器都不可以连接外网，但通过局域网与外网机器联通。</p><p>那么我们再使用 yum 安装软件时，可以采用以下方式</p><ul><li>搭建本地 yum 源</li><li>使用nginx 代理 yum 源</li></ul><p>其中方法1比较复杂且一旦需要第三方数据源时，更麻烦，因此我们这里介绍使用方法2。</p><h3 id="在有外网的服务器上安装-nginx"><a href="#在有外网的服务器上安装-nginx" class="headerlink" title="在有外网的服务器上安装 nginx"></a>在有外网的服务器上安装 nginx</h3><p>　　安装 epel 源</p><pre class="line-numbers language-shell"><code class="language-shell">[root@localhost ~] yum -y install epel-release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　安装 nginx</p><pre class="line-numbers language-shell"><code class="language-shell">[root@localhost ~] yum -y install nginx   #我习惯手动编译安装<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者手动安装：</p><pre class="line-numbers language-shell"><code class="language-shell">[root@localhost ~] yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel[root@localhost ~] wget http://nginx.org/download/nginx-1.18.0.tar.gz[root@localhost ~] tar -zxvf nginx-1.18.0.tar.gz[root@localhost ~] cd nginx-1.18.0[root@localhost nginx-1.18.0] ./configure[root@localhost nginx-1.18.0]make && make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置nginx-代理-yum-源"><a href="#配置nginx-代理-yum-源" class="headerlink" title="配置nginx 代理 yum 源"></a>配置nginx 代理 yum 源</h3><p>新增 nginx 配置文件</p><pre><code>[root@localhost ~] vim /etc/nginx/conf/nginx.conf</code></pre><p>输入以下内容，这里添加了一些常用的yum源，如果需要其他yum源可以自行添加</p><pre><code>    # centos 7 yum local source    server {        listen       7000;        server_name  192.168.1.101;        add_header Access-Control-Allow-Origin *;        add_header Access-Control-Allow-Headers X-Requested-With;        add_header Access-Control-Allow-Methods GET,POST,OPTIONS;        location / {            root   html;            index  index.html index.htm;        }        location /centos/ {            proxy_pass http://mirrors.aliyun.com/centos/;        }        location /epel/ {            proxy_pass http://mirrors.aliyun.com/epel/;        }        location /mariadb/ {            proxy_pass http://mirrors.ustc.edu.cn/mariadb/;        }    }</code></pre><p>检查nginx 配置，并重载nginx配置</p><pre><code>[root@localhost sbin] nginx -t[root@localhost sbin] nginx -s reload</code></pre><p>　　</p><h3 id="在没有外网的服务器上面配置-yum-源"><a href="#在没有外网的服务器上面配置-yum-源" class="headerlink" title="在没有外网的服务器上面配置 yum 源"></a>在没有外网的服务器上面配置 yum 源</h3><p>备份以前的yum 源配置文件</p><pre><code>[root@localhost ~] cd /etc/yum.repos.d[root@localhost yum.repos.d] mv CentOS-Base.repo CentOS-Base.repo.bak</code></pre><p>根据上方代理的 yum 源，创建如下配置文件，注意将ip 192.168.1.101 换成对应的有外网服务器的局域网ip</p><p>　　<em>CentOS-Base-nginx.repo</em></p><pre><code># CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client.  You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead.##[base]name=CentOS-$releasever - Base - 163.com#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=osbaseurl=http://192.168.1.101:7000/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=http://192.168.1.101:7000/centos/RPM-GPG-KEY-CentOS-7#released updates[updates]name=CentOS-$releasever - Updates - 163.com#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updatesbaseurl=http://192.168.1.101:7000/centos/$releasever/updates/$basearch/gpgcheck=1gpgkey=http://192.168.1.101:7000/centos/RPM-GPG-KEY-CentOS-7#additional packages that may be useful[extras]name=CentOS-$releasever - Extras - 163.com#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extrasbaseurl=http://192.168.1.101:7000/centos/$releasever/extras/$basearch/gpgcheck=1gpgkey=http://192.168.1.101:7000/centos/RPM-GPG-KEY-CentOS-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - 163.combaseurl=http://192.168.1.101:7000/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=http://192.168.1.101:7000/centos/RPM-GPG-KEY-CentOS-7</code></pre><p>　　<em>epel-nginx.repo</em></p><pre><code>[epel]name=Extra Packages for Enterprise Linux 7 - $basearchbaseurl=http://192.168.1.101:7000/epel/7/$basearchfailovermethod=priorityenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7[epel-debuginfo]name=Extra Packages for Enterprise Linux 7 - $basearch - Debugbaseurl=http://192.168.1.101:7000/epel/7/$basearch/debugfailovermethod=priorityenabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7gpgcheck=1[epel-source]name=Extra Packages for Enterprise Linux 7 - $basearch - Sourcebaseurl=http://192.168.1.101:7000/epel/7/SRPMSfailovermethod=priorityenabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</code></pre><p>　　MariaDB-nginx.repo</p><pre><code># MariaDB 10.2 CentOS repository list - created 2017-07-03 06:59 UTC# http://downloads.mariadb.org/mariadb/repositories/[mariadb]name = MariaDBbaseurl = http://192.168.1.101:7000/mariadb/yum/10.3/centos7-amd64gpgkey=http://192.168.1.101:7000/mariadb/yum/RPM-GPG-KEY-MariaDBgpgcheck=1</code></pre><h3 id="刷新-yum-源"><a href="#刷新-yum-源" class="headerlink" title="刷新 yum 源"></a>刷新 yum 源</h3><pre><code>yum clean allyum makecache</code></pre>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> linux </tag>
            
            <tag> yum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离线yum源</title>
      <link href="2021/01/06/chi-xian-yum-yuan/"/>
      <url>2021/01/06/chi-xian-yum-yuan/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS-7-制作离线yum源"><a href="#CentOS-7-制作离线yum源" class="headerlink" title="CentOS 7 制作离线yum源"></a>CentOS 7 制作离线yum源</h2><h3 id="1-建立本地yum源仓库"><a href="#1-建立本地yum源仓库" class="headerlink" title="1.建立本地yum源仓库"></a>1.建立本地yum源仓库</h3><pre class="line-numbers language-shell"><code class="language-shell">mkdir -p /root/data/yum<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-安装createrepo"><a href="#2-安装createrepo" class="headerlink" title="2.安装createrepo"></a>2.安装createrepo</h3><pre class="line-numbers language-shell"><code class="language-shell">1 yum install -y createrepo# 或者2 rpm -ivh http://mirror.centos.org/centos/7/os/x86_64/Packages/createrepo-0.9.9-23.el7.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-下载需要的rpm包到第一步的文件夹中"><a href="#3-下载需要的rpm包到第一步的文件夹中" class="headerlink" title="3.下载需要的rpm包到第一步的文件夹中"></a>3.下载需要的rpm包到第一步的文件夹中</h3><pre class="line-numbers language-shell"><code class="language-shell">yum  install   createrepo --downloadonly --downloaddir=/root/data/yum<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-确保防火墙关闭状态"><a href="#4-确保防火墙关闭状态" class="headerlink" title="4.确保防火墙关闭状态"></a>4.确保防火墙关闭状态</h3><h3 id="5-开始创建yum仓库，在rpm包存放的所在的目录下执行createrepo命令。"><a href="#5-开始创建yum仓库，在rpm包存放的所在的目录下执行createrepo命令。" class="headerlink" title="5.开始创建yum仓库，在rpm包存放的所在的目录下执行createrepo命令。"></a>5.开始创建yum仓库，在rpm包存放的所在的目录下执行createrepo命令。</h3><pre class="line-numbers language-shell"><code class="language-shell">createrepo /root/data/yum<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/01/06/chi-xian-yum-yuan/20190423180205896.png"></p><p>成功后会出现一个repodata</p><h3 id="6-在-etc-yum-repos-d目录下创建配置文件。"><a href="#6-在-etc-yum-repos-d目录下创建配置文件。" class="headerlink" title="6.在/etc/yum.repos.d目录下创建配置文件。"></a>6.在/etc/yum.repos.d目录下创建配置文件。</h3><p>（我这里是以本地file的形式给自己的主机提供yum源，如果你要在局域网内的其他主机可以访问到，则使用http或ftp的形式进行，比如：base=http://{当前yum源所在主机的IP}/{RPM软件包目录}）</p><pre class="line-numbers language-shell"><code class="language-shell">cd /etc/yum.repos.dcat CentOS-Local.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>[CentOS-Local]name=Centos Local yum repobaseurl=file:///root/data/yumenabled=1gpgcheck=0priority=1</code></pre><h3 id="7-更新本地缓存"><a href="#7-更新本地缓存" class="headerlink" title="7.更新本地缓存"></a>7.更新本地缓存</h3><pre class="line-numbers language-shell"><code class="language-shell">yum clean allyum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="8-检测是否使用了本地yum源"><a href="#8-检测是否使用了本地yum源" class="headerlink" title="8.检测是否使用了本地yum源"></a>8.检测是否使用了本地yum源</h3><pre class="line-numbers language-shell"><code class="language-shell">yum repolist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/01/06/chi-xian-yum-yuan/20190423185158468.png"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> yum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ消息确认、消息持久化等核心知识总结</title>
      <link href="2020/12/31/rabbitmq-xiao-xi-que-ren-xiao-xi-chi-jiu-hua-deng-he-xin-zhi-shi-zong-jie/"/>
      <url>2020/12/31/rabbitmq-xiao-xi-que-ren-xiao-xi-chi-jiu-hua-deng-he-xin-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="一、消息中间件选型"><a href="#一、消息中间件选型" class="headerlink" title="一、消息中间件选型"></a>一、消息中间件选型</h3><h5 id="1-ActiveMQ"><a href="#1-ActiveMQ" class="headerlink" title="1. ActiveMQ:"></a>1. ActiveMQ:</h5><ul><li>优点: ActiveMQ是老牌的消息中间件，国内很多公司过去运用的还是非常广泛的，功能很强大。</li><li>缺点: 没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景，在国内互联网公司落地较少。而且使用较多的是一些传统企业，用ActiveMQ做异步调用和系统解耦。</li></ul><h5 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2. RabbitMQ:"></a>2. RabbitMQ:</h5><ul><li>优点: 可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。另外，他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。而且经过调研，国内各大互联网公司落地大规模RabbitMQ集群支撑自身业务的case较多，国内各种中小型互联网公司使用RabbitMQ的实践也比较多。除此之外，RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化，因此，综合对比后，RabbitMQ是一个不错的消息中间件选择。</li><li>缺点: 基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以。</li></ul><h5 id="3-RocketMQ"><a href="#3-RocketMQ" class="headerlink" title="3. RocketMQ:"></a>3. RocketMQ:</h5><ul><li>优点: 阿里开源的，经过阿里的生产环境的超高并发、高吞吐的考验，性能卓越，同时还支持分布式事务等特殊场景。而且RocketMQ是基于Java语言开发的，适合深入阅读源码，有需要可以站在源码层面解决线上生产问题，包括源码的二次开发和改造。</li><li>缺点: 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码</li></ul><h5 id="4-Kafka"><a href="#4-Kafka" class="headerlink" title="4. Kafka:"></a>4. Kafka:</h5><ul><li>优点: 专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景来设计。在大数据领域中配合实时计算技术（比如Spark Streaming、Storm、Flink）使用的较多。</li><li>缺点: 相对于以上几种中间件来说，功能较少，在传统的MQ中间件使用场景中较少采用。</li></ul><h3 id="二、消息中间件的常见使用场景"><a href="#二、消息中间件的常见使用场景" class="headerlink" title="二、消息中间件的常见使用场景"></a>二、消息中间件的常见使用场景</h3><ul><li>复杂系统的解耦: 多个系统间通过中间件进行数据交互, 避免牵一发而动全身, 减少耦合, 提升系统稳定性与可扩展性</li><li>复杂链路的异步调用: 某些业务场景可以通过异步执行减少同步调用的时间, 从而大大提高系统响应时间而不影响核心逻辑</li><li>瞬时高峰的削峰处理: 流量高峰期, 可以将请求积压在MQ中, 服务器不用一下处理所有请求从而导致系统崩溃, 高峰期后, 消费者可以慢慢消费</li></ul><h3 id="三、系统架构引入消息中间件后会有哪些缺点"><a href="#三、系统架构引入消息中间件后会有哪些缺点" class="headerlink" title="三、系统架构引入消息中间件后会有哪些缺点"></a>三、系统架构引入消息中间件后会有哪些缺点</h3><ul><li>系统可用性降低: 引入MQ，系统多了一个依赖。依赖如果出现问题，就会导致系统可用性降低。一旦引入中间件，就必须考虑这个中间件是如何部署的，如何保证高可用性</li><li>系统稳定性降低: 引入MQ, 可能由于网络故障、中间件故障、消费者异常等原因导致各种各样乱七八糟的问题产生, 从而使系统稳定性下降</li><li>分布式一致性问题: 多系统协同处理一个业务, 不能保证所有系统都正常处理, 有可能出现系统数据不一致的情况, 所以此时又需要使用可靠消息最终一致性的分布式事务方案来保障数据一致性。</li></ul><h3 id="四、消息发送确认"><a href="#四、消息发送确认" class="headerlink" title="四、消息发送确认"></a>四、消息发送确认</h3><p>生产者发送消息, 先发送消息到Exchange, 然后Exchange再路由到Queue, 这中间就需要确认两个事情</p><ul><li>确认消息是否成功发送到Exchange</li><li>确认消息是否从Exchange成功路由到Queue</li></ul><p>spring提供了两个回调函数来处理这两种消息发送确认</p><h5 id="1-确认消息是否成功发送到Exchange"><a href="#1-确认消息是否成功发送到Exchange" class="headerlink" title="1. 确认消息是否成功发送到Exchange"></a>1. 确认消息是否成功发送到Exchange</h5><p>有2种方式, 一种是重量级的事务消息机制。采用类事务的机制把消息投递到MQ，可以保证消息不丢失，但是性能极差，经过测试性能会呈现几百倍的下降。</p><p>所以说现在一般是不会用这种过于重量级的机制，而是会用轻量级的confirm机制。</p><p>另一种方式是confirm机制, 跟手动ack机制类似, 生产者将消息投递到RabbitMQ, 且将消息持久化到硬盘后, RabbitMQ会通过一个回调方法将confirm信息回传给生产端, 这样, 如果生产端的服务接收到了这个confirm消息，就知道是已经持久化到磁盘了。否则如果没有接收到confirm消息，那么就说明这条消息可能半路丢失了，此时你就可以重新投递消息到MQ去，确保消息不会丢失。</p><p>1.1 通过AMQP的事务机制可以保证消息发送确认<br> 事务机制主要是通过对channel的设置实现</p><pre class="line-numbers language-cpp"><code class="language-cpp">channel<span class="token punctuation">.</span><span class="token function">txSelect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 声明启动事务模式</span>channel<span class="token punctuation">.</span><span class="token function">txComment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 提交事务</span>channel<span class="token punctuation">.</span><span class="token function">txRollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 回滚事务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>1.2 使用confirm确认机制<br> 实现ConfirmCallback并重写confirm回调方法, 消息发送到Broker后触发回调, 可以确认消息是否成功发送到Exchange</p><p><code>application.properties</code>:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 开启confirms回调 P -> Exchange</span>spring.rabbitmq.publisher-confirms<span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>回调:</p><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token comment" spellcheck="true">// 消息是否成功发送到Exchange</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setConfirmCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>correlationData<span class="token punctuation">,</span> ack<span class="token punctuation">,</span> cause<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ack<span class="token punctuation">)</span> <span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"消息成功发送到Exchange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"消息发送到Exchange失败: cause: {}"</span><span class="token punctuation">,</span> correlationData<span class="token punctuation">,</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-确认消息是否从Exchange成功路由到Queue"><a href="#2-确认消息是否从Exchange成功路由到Queue" class="headerlink" title="2. 确认消息是否从Exchange成功路由到Queue"></a>2. 确认消息是否从Exchange成功路由到Queue</h5><p>实现ReturnCallback并重写returnedMessage回调方法, 可以确认消息从EXchange路由到Queue失败, 注意: 这里的回调是一个失败回调, 只有消息从Exchange路由到Queue失败才会回调这个方法</p><p><code>application.properties</code>:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 开启returnedMessage回调 Exchange -> Queue</span>spring.rabbitmq.publisher-returns<span class="token operator">=</span>true<span class="token comment" spellcheck="true"># 触发returnedMessage回调必须设置mandatory=true, 否则Exchange没有找到Queue就会丢弃掉消息, 而不会触发回调</span>spring.rabbitmq.template.mandatory<span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>回调:</p><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token comment" spellcheck="true">// 消息是否从Exchange路由到Queue, 注意: 这是一个失败回调, 只有消息从Exchange路由到Queue失败才会回调这个方法</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setReturnCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> replyCode<span class="token punctuation">,</span> replyText<span class="token punctuation">,</span> exchange<span class="token punctuation">,</span> routingKey<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"消息从Exchange路由到Queue失败: exchange: {}, route: {}, replyCode: {}, replyText: {}, message: {}"</span><span class="token punctuation">,</span> exchange<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span> replyCode<span class="token punctuation">,</span> replyText<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="五、消息接收确认"><a href="#五、消息接收确认" class="headerlink" title="五、消息接收确认"></a>五、消息接收确认</h3><p>消息怎样才算消费成功?</p><p>RabbitMQ默认**自动确认(ack)**消息被正确消费, 即消息投递到消费者后就自动确认消息被处理完毕, 并且会将该消息删除, 即使消费者意外宕机, 或者抛出异常, 如果消费者接收到消息, 还没处理完成就down掉或者抛出异常, 那么, 这条消息就丢失了</p><p>分析一下问题出在哪, 问题出在RabbitMQ只管消息投递出去, 而不管消息是否被正确处理就自动删除消息, 所以, 只要将自动ack修改为手动ack, 消费成功才通知RabbitMQ可以删除该消息即可, 如果消费者宕机, 消费失败, 由于RabbitMQ并未收到ack通知, 且感知到该消费者状态异常(如抛出异常), 就会将该消息重新推送给其他消费者, 让其他消费者继续执行, 这样就保证消费者挂掉但消息不会丢失</p><p>消息确认模式有:</p><ul><li>AcknowledgeMode.NONE：自动确认</li><li>AcknowledgeMode.AUTO：根据情况确认</li><li>AcknowledgeMode.MANUAL：手动确认</li></ul><p>默认情况下消息消费者是自动ack(确认)消息的, 如果要手动ack(确认), 则需要修改确认模式为manual</p><p><code>application.properties</code>:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 设置手动确认(ack) Queue -> C</span>spring.rabbitmq.listener.simple.acknowledge-mode<span class="token operator">=</span>manual<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>消费消息并手动确认:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LogUserConsumer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    UserLogService userLogService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"log.user.queue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logUserConsumer</span><span class="token punctuation">(</span>Message message<span class="token punctuation">,</span> Channel channel<span class="token punctuation">,</span> <span class="token annotation punctuation">@Header</span> <span class="token punctuation">(</span>AmqpHeaders<span class="token punctuation">.</span>DELIVERY_TAG<span class="token punctuation">)</span> <span class="token keyword">long</span> tag<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"收到消息: {}"</span><span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            userLogService<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>MessageHelper<span class="token punctuation">.</span><span class="token function">msgToObj</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> UserLog<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"logUserConsumer error"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            channel<span class="token punctuation">.</span><span class="token function">basicNack</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>tag<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>重点在<code>channel.basicAck(tag, false)</code>方法, 第一个参数deliveryTag（唯一标识 ID）：当一个消费者向 RabbitMQ 注册后，会建立起一个 Channel ，RabbitMQ 会用 basic.deliver 方法向消费者推送消息，这个方法携带了一个 delivery tag， 它代表了 RabbitMQ 向该 Channel 投递的这条消息的唯一标识 ID，是一个单调递增的正整数，delivery tag 的范围仅限于 Channel</li><li>第二个参数multiple：为了减少网络流量，手动确认可以被批处理，当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的所有消息</li></ul><h3 id="六、消息持久化"><a href="#六、消息持久化" class="headerlink" title="六、消息持久化"></a>六、消息持久化</h3><p>消息被投递到RabbitMQ的内存中, 还没投递到消费者实例之前宕机了, 消息不就丢失了?</p><p>可以进行消息持久化, 将Exchange、queue和message都持久化到硬盘, 这样, RabbitMQ重启时, 会把持久化的Exchange、queue和message从硬盘重新加载出来, 重新投递消息</p><p>1.1 <strong>Exchange的持久化</strong>, 声明交换机时指定持久化参数为<code>true</code>即可</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> DirectExchange <span class="token function">logUserExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">"log.user.exchange"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二个参数<code>durable</code>: 是否持久化, 第三个参数<code>autoDelete</code>: 当所有绑定队列都不再使用时, 是否自动删除交换器, true: 删除, false: 不删除</p><p>1.2 <strong>queue的持久化</strong>, 声明队列时指定持久化参数为<code>true</code>即可</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Queue <span class="token function">logUserQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"log.user.queue.name"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二个参数<code>durable</code>, 是否持久化</p><p>1.3 <strong>message的持久化</strong>, 是通过配置<code>deliveryMode</code>实现的, 生产者投递时, 指定<code>deliveryMode</code>为<code>MessageDeliveryMode.PERSISTENT</code>即可实现消息的持久化, 投递和消费都需要通过<code>Message</code>对象进行交互, 为了不每次都写配置转换的代码, 我们写一个消息帮助类<code>MessageHelper</code>:</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageHelper</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Message <span class="token function">objToMsg</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Message message <span class="token operator">=</span> MessageBuilder<span class="token punctuation">.</span><span class="token function">withBody</span><span class="token punctuation">(</span>JsonUtil<span class="token punctuation">.</span><span class="token function">objToStr</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDeliveryMode</span><span class="token punctuation">(</span>MessageDeliveryMode<span class="token punctuation">.</span>PERSISTENT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 消息持久化</span>        message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span>MessageProperties<span class="token punctuation">.</span>CONTENT_TYPE_JSON<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> message<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">msgToObj</span><span class="token punctuation">(</span>Message message<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> message <span class="token operator">||</span> <span class="token keyword">null</span> <span class="token operator">==</span> clazz<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        T obj <span class="token operator">=</span> JsonUtil<span class="token punctuation">.</span><span class="token function">strToObj</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>消息投递时:</p><pre class="line-numbers language-css"><code class="language-css">rabbitTemplate<span class="token number">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"log.user.exchange.name"</span>, <span class="token string">"log.user.routing.key.name"</span>, MessageHelper<span class="token number">.</span><span class="token function">objToMsg</span><span class="token punctuation">(</span>userLog<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>消息消费时(参考<code>五、消息接收确认</code>):</p><pre class="line-numbers language-java"><code class="language-java">UserLog userLog <span class="token operator">=</span> MessageHelper<span class="token punctuation">.</span><span class="token function">msgToObj</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> UserLog<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不需要消息持久化, 则不需要通过Message进行转换, 可以直接通过字符串或者对象投递和消费</p><h3 id="七、unack消息的积压问题"><a href="#七、unack消息的积压问题" class="headerlink" title="七、unack消息的积压问题"></a>七、unack消息的积压问题</h3><p>什么叫unack消息的积压问题, 简单来说就是消费者处理能力有限, 无法一下将MQ投递过来的所有消息消费完, 如果MQ推送消息过多, 比如可能有几千上万条消息积压在某个消费者实例内存中, 此时这些积压的消息就处于unack状态, 如果一直积压, 就有可能导致消费者服务实例内存溢出、内存消耗过大、甚至内存泄露</p><p>所以, RabbitMQ是必须要考虑一下消费者服务的处理能力的。</p><p>如何解决?</p><p>RabbitMQ基于一个prefetch count来控制这个unack message的数量。</p><p>你可以通过 “channel.basicQos(10)” 这个方法来设置当前channel的prefetch count。也可以通过配置文件设置: <code>spring.rabbitmq.listener.simple.prefetch=10</code></p><p>举个例子，比如你要是设置为10的话，那么意味着当前这个channel里，unack message的数量不能超过10个，以此来避免消费者服务实例积压unack message过多。</p><p>这样的话，就意味着RabbitMQ正在投递到channel过程中的unack message，以及消费者服务在处理中的unack message，以及异步ack之后还没完成ack的unack message，所有这些message加起来，一个channel也不能超过10个。</p><p>如果你要简单粗浅的理解的话，也大致可以理解为这个prefetch count就代表了一个消费者服务同时最多可以获取多少个message来处理。</p><p>prefetch就是预抓取的意思，就意味着你的消费者服务实例预抓取多少条message过来处理，但是最多只能同时处理这么多消息。</p><p>如果一个channel里的unack message超过了prefetch count指定的数量，此时RabbitMQ就会停止给这个channel投递消息了，必须要等待已经投递过去的消息被ack了，此时才能继续投递下一个消息。</p><p>设置多大合理?</p><p>RabbitMQ官方给出的建议是prefetch count一般设置在100 - 300之间。也就是一个消费者服务最多接收到100 - 300个message来处理，允许处于unack状态。</p><p>这个状态下可以兼顾吞吐量也很高，同时也不容易造成内存溢出的问题。</p><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><ul><li>配置汇总</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># rabbitmq</span>spring.rabbitmq.host<span class="token operator">=</span>localhostspring.rabbitmq.port<span class="token operator">=</span>5672spring.rabbitmq.username<span class="token operator">=</span>guestspring.rabbitmq.password<span class="token operator">=</span>guest<span class="token comment" spellcheck="true"># 开启confirms回调 P -> Exchange</span>spring.rabbitmq.publisher-confirms<span class="token operator">=</span>true<span class="token comment" spellcheck="true"># 开启returnedMessage回调 Exchange -> Queue</span>spring.rabbitmq.publisher-returns<span class="token operator">=</span>true<span class="token comment" spellcheck="true"># 触发returnedMessage回调必须设置mandatory=true, 否则Exchange没有找到Queue就会丢弃掉消息, 而不会触发回调</span>spring.rabbitmq.template.mandatory<span class="token operator">=</span>true<span class="token comment" spellcheck="true"># 设置手动确认(ack) Queue -> C</span>spring.rabbitmq.listener.simple.acknowledge-mode<span class="token operator">=</span>manualspring.rabbitmq.listener.simple.prefetch<span class="token operator">=</span>100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Github</strong><br> 完整项目请查看我的GitHub, 通过RabbitMQ实现了用户登录日志的记录<br> <a href="https://links.jianshu.com/go?to=https://github.com/wangzaiplus/springboot/tree/wxw">https://github.com/wangzaiplus/springboot/tree/wxw</a></li><li>另外, 关于windows安装RabbitMQ详细教程, 请参考:<br> <a href="https://www.jianshu.com/p/c7726ba4b046">https://www.jianshu.com/p/c7726ba4b046</a></li><li>关于Linux centos7安装RabbitMQ详细教程, 请参考:<br> <a href="https://www.jianshu.com/p/ee9f7594212b">https://www.jianshu.com/p/ee9f7594212b</a></li></ul><p>作者：wangzaiplus<br>链接：<a href="https://www.jianshu.com/p/cc3d2017e7b3">https://www.jianshu.com/p/cc3d2017e7b3</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> rabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在浏览器中异步下载文件监听下载进度</title>
      <link href="2020/12/29/java-download/"/>
      <url>2020/12/29/java-download/</url>
      
        <content type="html"><![CDATA[<p>在浏览器中异步下载文件，其实就是把服务器响应的文件先保存在内存中。然后再一次<strong>下载</strong>到磁盘。第二次<strong>下载</strong>过程，就是把内存的数据IO到磁盘，没有网络开销。速度极快。</p><p>之所以要先保存在内存，主要是可以在下载开始之前和下载结束后可以做一些业务逻辑（例如：校验，判断），还可以监听下载的进度。</p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>这里演示一个Demo，在点击下载摁钮后，弹出加loading框。在读取到服务器的响应的文件后。关闭loading框。并且在控制台中输出下载的进度。</p><blockquote><p>有点像是监听文件下载完毕的意思，也只能是像。从内存IO到磁盘的这个过程，JS代码，再也无法染指过程。更谈不上监听了。</p></blockquote><h1 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h1><p>服务端的下载实现</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>BufferedInputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Files<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Path<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Paths<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServletRequest<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpServletResponse<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Controller<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>GetMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestParam<span class="token punctuation">;</span><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/download"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DownloadController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">download</span> <span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>                            HttpServletResponse response<span class="token punctuation">,</span>                            <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">)</span> String file<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        Path path <span class="token operator">=</span> Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Files<span class="token punctuation">.</span><span class="token function">notExists</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token operator">||</span> Files<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 文件不存在，或者它是一个目录</span>            response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>HttpServletResponse<span class="token punctuation">.</span>SC_NOT_FOUND<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String contentType <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMimeType</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>contentType <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 如果没读取到ContentType，则设置为默认的二进制文件类型</span>            contentType <span class="token operator">=</span> <span class="token string">"application/octet-stream"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span>BufferedInputStream bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>Files<span class="token punctuation">.</span><span class="token function">newInputStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span>contentType<span class="token punctuation">)</span><span class="token punctuation">;</span>            response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"Content-Disposition"</span><span class="token punctuation">,</span> <span class="token string">"attachment; filename="</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">getFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"GBK"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 关键点，给客户端响应Content-Length头，客户端需要用此来计算下载进度</span>            response<span class="token punctuation">.</span><span class="token function">setContentLengthLong</span><span class="token punctuation">(</span>Files<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            OutputStream outputStream <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">8192</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> bufferedInputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                outputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Index-html"><a href="#Index-html" class="headerlink" title="Index.html"></a>Index.html</h1><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="UTF-8"&gt;        &lt;title&gt;异步下载&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input name="name" value="D:\\eclipse-jee-2019-12-R-win32-x86_64.zip" placeholder="输入你要下载的文件路径" id="file" /&gt;        &lt;button id="button" onclick="downlod();"&gt;开始下载&lt;/button&gt;    &lt;/body&gt;    &lt;script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.10.0/jquery.min.js"&gt;&lt;/script&gt;    &lt;script src="/layer/layer.js"&gt;&lt;/script&gt;    &lt;script type="text/javascript"&gt;        function downlod(){            const file = document.querySelector('#file').value;            if (!file){                alert('请输入合法的文件地址');            }            // 打开加载动画            const index = layer.load(1, {                  shade: [0.1,'#fff']            });            const xhr = new XMLHttpRequest();            xhr.open('GET', '/download?file=' + encodeURIComponent(file));            xhr.send(null);            // 设置服务端的响应类型            xhr.responseType = "blob";            // 监听下载            xhr.addEventListener('progress', event =&gt; {                // 计算出百分比                const percent  = ((event.loaded / event.total) * 100).toFixed(2);                console.log(`下载进度：${percent}`);            }, false);            xhr.onreadystatechange = event =&gt; {                if(xhr.readyState == 4){                    if (xhr.status == 200){                        // 获取ContentType                        const contentType = xhr.getResponseHeader('Content-Type');                        // 文件名称                        const fileName = xhr.getResponseHeader('Content-Disposition').split(';')[1].split('=')[1];                        // 创建一个a标签用于下载                        const donwLoadLink = document.createElement('a');                        donwLoadLink.download = fileName;                        donwLoadLink.href = URL.createObjectURL(xhr.response);                        // 触发下载事件，IO到磁盘                        donwLoadLink.click();                        // 释放内存中的资源                        URL.revokeObjectURL(donwLoadLink.href);                        // 关闭加载动画                        layer.close(index);                    } else if (response.status == 404){                        alert(`文件：${file} 不存在`);                    } else if (response.status == 500){                        alert('系统异常');                    }                }            }        }    &lt;/script&gt;&lt;/html&gt;</code></pre><p>现在的ajax请求，几乎都是用ES6的fetch，支持异步，而且代码也更优雅。API设计得更合理。但是目前为止，好像fetch并没有progress事件，也就说<strong>它不支持监听上传下载的进度</strong>。所以没辙，还是得用XMLHttpRequest。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这种方式弊端也是显而易见，如果文件过大。那么内存就炸了。我觉得浏览器应该暴露一个js的接口。允许通过异步的方式直接下载文件IO到磁盘，通过回调给出下载的进度，IO的进度。</p><p>原文：<a href="https://springboot.io/t/topic/2734">https://springboot.io/t/topic/2734</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> download </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Java中实现Zip文件的压缩与解压缩</title>
      <link href="2020/12/29/java-zip/"/>
      <url>2020/12/29/java-zip/</url>
      
        <content type="html"><![CDATA[<p>zip这里就不多说了，在网上找了很多代码，都觉得实现不够优雅，所以自己写了一个工具类。</p><ul><li>解压zip文件</li><li>指定的文件进行zip压缩，</li><li>对指定的目录进行zip压缩</li></ul><h1 id="ZipUtils"><a href="#ZipUtils" class="headerlink" title="ZipUtils"></a>ZipUtils</h1><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>OutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>FileVisitResult<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>FileVisitor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Files<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Path<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>StandardOpenOption<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>attribute<span class="token punctuation">.</span>BasicFileAttributes<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>Collectors<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>zip<span class="token punctuation">.</span>ZipEntry<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>zip<span class="token punctuation">.</span>ZipFile<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>zip<span class="token punctuation">.</span>ZipInputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>zip<span class="token punctuation">.</span>ZipOutputStream<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZipUtils</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 解压文件      * @param file        压缩文件     * @param targetDir    解压文件输出的目录     * @throws IOException      */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">unPacket</span><span class="token punctuation">(</span>Path file<span class="token punctuation">,</span> Path targetDir<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Files<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span>targetDir<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Files<span class="token punctuation">.</span><span class="token function">createDirectories</span><span class="token punctuation">(</span>targetDir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 创建zip对象</span>        ZipFile zipFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipFile</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">toFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 读取zip流</span>            <span class="token keyword">try</span><span class="token punctuation">(</span>ZipInputStream zipInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipInputStream</span><span class="token punctuation">(</span>Files<span class="token punctuation">.</span><span class="token function">newInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ZipEntry zipEntry <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 遍历每一个zip项</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>zipEntry <span class="token operator">=</span> zipInputStream<span class="token punctuation">.</span><span class="token function">getNextEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 获取zip项目名称</span>                    String entryName <span class="token operator">=</span> zipEntry<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 构建绝对路径</span>                    Path entryFile <span class="token operator">=</span> targetDir<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>entryName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>zipEntry<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 文件夹</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Files<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span>entryFile<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            Files<span class="token punctuation">.</span><span class="token function">createDirectories</span><span class="token punctuation">(</span>entryFile<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// 文件</span>                        <span class="token comment" spellcheck="true">// 读取zip项数据流</span>                        <span class="token keyword">try</span><span class="token punctuation">(</span>InputStream zipEntryInputStream <span class="token operator">=</span> zipFile<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span>zipEntry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            <span class="token keyword">try</span><span class="token punctuation">(</span>OutputStream fileOutputStream <span class="token operator">=</span> Files<span class="token punctuation">.</span><span class="token function">newOutputStream</span><span class="token punctuation">(</span>entryFile<span class="token punctuation">,</span> StandardOpenOption<span class="token punctuation">.</span>CREATE_NEW<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                                <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>length <span class="token operator">=</span> zipEntryInputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                    fileOutputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                                fileOutputStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            zipFile<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 压缩指定的文件     * @param files                目标文件     * @param zipFile            生成的压缩文件     * @throws IOException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">packet</span><span class="token punctuation">(</span>Path<span class="token punctuation">[</span><span class="token punctuation">]</span> files<span class="token punctuation">,</span> Path zipFile<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        OutputStream outputStream <span class="token operator">=</span> Files<span class="token punctuation">.</span><span class="token function">newOutputStream</span><span class="token punctuation">(</span>zipFile<span class="token punctuation">,</span> StandardOpenOption<span class="token punctuation">.</span>CREATE_NEW<span class="token punctuation">)</span><span class="token punctuation">;</span>        ZipOutputStream zipOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipOutputStream</span><span class="token punctuation">(</span>outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Path file <span class="token operator">:</span> files<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Files<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">try</span> <span class="token punctuation">(</span>InputStream inputStream <span class="token operator">=</span> Files<span class="token punctuation">.</span><span class="token function">newInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 创建一个压缩项，指定名称</span>                    ZipEntry zipEntry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipEntry</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 添加到压缩流</span>                    zipOutputStream<span class="token punctuation">.</span><span class="token function">putNextEntry</span><span class="token punctuation">(</span>zipEntry<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 写入数据</span>                    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        zipOutputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    zipOutputStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 完成所有压缩项的添加</span>            zipOutputStream<span class="token punctuation">.</span><span class="token function">closeEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            zipOutputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            outputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 压缩指定的目录      * @param folder     * @param zipFile     * @throws IOException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">packet</span><span class="token punctuation">(</span>Path folder<span class="token punctuation">,</span> Path zipFile<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Files<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span>folder<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>folder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" 不是合法的文件夹"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        OutputStream outputStream <span class="token operator">=</span> Files<span class="token punctuation">.</span><span class="token function">newOutputStream</span><span class="token punctuation">(</span>zipFile<span class="token punctuation">,</span> StandardOpenOption<span class="token punctuation">.</span>CREATE_NEW<span class="token punctuation">)</span><span class="token punctuation">;</span>        ZipOutputStream zipOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipOutputStream</span><span class="token punctuation">(</span>outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        LinkedList<span class="token operator">&lt;</span>String<span class="token operator">></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Files<span class="token punctuation">.</span><span class="token function">walkFileTree</span><span class="token punctuation">(</span>folder<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FileVisitor</span><span class="token operator">&lt;</span>Path<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> FileVisitResult <span class="token function">preVisitDirectory</span><span class="token punctuation">(</span>Path dir<span class="token punctuation">,</span> BasicFileAttributes attrs<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dir<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>folder<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 开始遍历目录</span>                        String folder <span class="token operator">=</span> dir<span class="token punctuation">.</span><span class="token function">getFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        path<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>folder<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 写入目录 </span>                        ZipEntry zipEntry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipEntry</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            zipOutputStream<span class="token punctuation">.</span><span class="token function">putNextEntry</span><span class="token punctuation">(</span>zipEntry<span class="token punctuation">)</span><span class="token punctuation">;</span>                            zipOutputStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">return</span> FileVisitResult<span class="token punctuation">.</span>CONTINUE<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> FileVisitResult <span class="token function">visitFile</span><span class="token punctuation">(</span>Path file<span class="token punctuation">,</span> BasicFileAttributes attrs<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 开始遍历文件</span>                    <span class="token keyword">try</span> <span class="token punctuation">(</span>InputStream inputStream <span class="token operator">=</span> Files<span class="token punctuation">.</span><span class="token function">newInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 创建一个压缩项，指定名称</span>                        String fileName <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span>                                 <span class="token operator">?</span> path<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> file<span class="token punctuation">.</span><span class="token function">getFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                <span class="token operator">:</span> file<span class="token punctuation">.</span><span class="token function">getFileName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        ZipEntry zipEntry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipEntry</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 添加到压缩流</span>                        zipOutputStream<span class="token punctuation">.</span><span class="token function">putNextEntry</span><span class="token punctuation">(</span>zipEntry<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 写入数据</span>                        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            zipOutputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        zipOutputStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">return</span> FileVisitResult<span class="token punctuation">.</span>CONTINUE<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> FileVisitResult <span class="token function">visitFileFailed</span><span class="token punctuation">(</span>Path file<span class="token punctuation">,</span> IOException exc<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    <span class="token keyword">return</span> FileVisitResult<span class="token punctuation">.</span>CONTINUE<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> FileVisitResult <span class="token function">postVisitDirectory</span><span class="token punctuation">(</span>Path dir<span class="token punctuation">,</span> IOException exc<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 结束遍历目录</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>path<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">return</span> FileVisitResult<span class="token punctuation">.</span>CONTINUE<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            zipOutputStream<span class="token punctuation">.</span><span class="token function">closeEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            zipOutputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            outputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>原文:<a href="https://springboot.io/t/topic/2869">https://springboot.io/t/topic/2869</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压缩20M文件从30秒到1秒的优化过程</title>
      <link href="2020/12/28/java-zip-optimize/"/>
      <url>2020/12/28/java-zip-optimize/</url>
      
        <content type="html"><![CDATA[<h2 id="压缩20M文件从30秒到1秒的优化过程"><a href="#压缩20M文件从30秒到1秒的优化过程" class="headerlink" title="压缩20M文件从30秒到1秒的优化过程"></a>压缩20M文件从30秒到1秒的优化过程</h2><p>有一个需求需要将前端传过来的10张照片，然后后端进行处理以后压缩成一个压缩包通过网络流传输出去。之前没有接触过用Java压缩文件的，所以就直接上网找了一个例子改了一下用了，改完以后也能使用，但是随着前端所传图片的大小越来越大的时候，耗费的时间也在急剧增加，最后测了一下压缩20M的文件竟然需要30秒的时间。压缩文件的代码如下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">zipFileNoBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    File zipFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>ZIP_FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>ZipOutputStream zipOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>zipFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//开始时间</span>        <span class="token keyword">long</span> beginTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">(</span>InputStream input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>JPG_FILE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                zipOut<span class="token punctuation">.</span><span class="token function">putNextEntry</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ZipEntry</span><span class="token punctuation">(</span>FILE_NAME <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>temp <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    zipOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">printInfo</span><span class="token punctuation">(</span>beginTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里找了一张2M大小的图片，并且循环十次进行测试。打印的结果如下，时间大概是30秒。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token property">fileSize</span><span class="token punctuation">:</span><span class="token number">20</span>Mconsum <span class="token property">time</span><span class="token punctuation">:</span><span class="token number">29599</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="第一次优化过程-从30秒到2秒"><a href="#第一次优化过程-从30秒到2秒" class="headerlink" title="第一次优化过程-从30秒到2秒"></a>第一次优化过程-从30秒到2秒</h2><p>进行优化首先想到的是利用<strong>缓冲区</strong><code>BufferInputStream</code>。在<code>FileInputStream</code>中<code>read()</code>方法每次只读取一个字节。源码中也有说明。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Reads a byte of data from this input stream. This method blocks * if no input is yet available. * * @return     the next byte of data, or &lt;code>-1&lt;/code> if the end of the *             file is reached. * @exception  IOException  if an I/O error occurs. */</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一个调用本地方法与原生操作系统进行交互，从磁盘中读取数据。每读取一个字节的数据就调用一次本地方法与操作系统交互，是非常耗时的。例如我们现在有30000个字节的数据，如果使用<code>FileInputStream</code>那么就需要调用30000次的本地方法来获取这些数据，而如果使用缓冲区的话（这里假设初始的缓冲区大小足够放下30000字节的数据）那么只需要调用一次就行。因为缓冲区在第一次调用<code>read()</code>方法的时候会直接从磁盘中将数据直接读取到内存中。随后再一个字节一个字节的慢慢返回。</p><blockquote><p><code>BufferedInputStream</code>内部封装了一个byte数组用于存放数据，默认大小是8192</p></blockquote><p>优化过后的代码如下</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">zipFileBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    File zipFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>ZIP_FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>ZipOutputStream zipOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>zipFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            BufferedOutputStream bufferedOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span>zipOut<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//开始时间</span>        <span class="token keyword">long</span> beginTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">(</span>BufferedInputStream bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>JPG_FILE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                zipOut<span class="token punctuation">.</span><span class="token function">putNextEntry</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ZipEntry</span><span class="token punctuation">(</span>FILE_NAME <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>temp <span class="token operator">=</span> bufferedInputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    bufferedOutputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">printInfo</span><span class="token punctuation">(</span>beginTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出</p><pre class="line-numbers language-css"><code class="language-css">------Buffer<span class="token property">fileSize</span><span class="token punctuation">:</span><span class="token number">20</span>Mconsum <span class="token property">time</span><span class="token punctuation">:</span><span class="token number">1808</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到相比较于第一次使用<code>FileInputStream</code>效率已经提升了许多了</p><h2 id="第二次优化过程-从2秒到1秒"><a href="#第二次优化过程-从2秒到1秒" class="headerlink" title="第二次优化过程-从2秒到1秒"></a>第二次优化过程-从2秒到1秒</h2><p>使用缓冲区<code>buffer</code>的话已经是满足了我的需求了，但是秉着学以致用的想法，就想着用NIO中知识进行优化一下。</p><h3 id="使用Channel"><a href="#使用Channel" class="headerlink" title="使用Channel"></a>使用Channel</h3><p>为什么要用<code>Channel</code>呢？因为在NIO中新出了<code>Channel</code>和<code>ByteBuffer</code>。正是因为它们的结构更加符合操作系统执行I/O的方式，所以其速度相比较于传统IO而言速度有了显著的提高。<code>Channel</code>就像一个包含着煤矿的矿藏，而<code>ByteBuffer</code>则是派送到矿藏的卡车。也就是说我们与数据的交互都是与<code>ByteBuffer</code>的交互。</p><p>在NIO中能够产生<code>FileChannel</code>的有三个类。分别是<code>FileInputStream</code>、<code>FileOutputStream</code>、以及既能读又能写的<code>RandomAccessFile</code>。</p><p>源码如下</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">zipFileChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//开始时间</span>    <span class="token keyword">long</span> beginTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    File zipFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>ZIP_FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>ZipOutputStream zipOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>zipFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            WritableByteChannel writableByteChannel <span class="token operator">=</span> Channels<span class="token punctuation">.</span><span class="token function">newChannel</span><span class="token punctuation">(</span>zipOut<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">(</span>FileChannel fileChannel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>JPG_FILE<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                zipOut<span class="token punctuation">.</span><span class="token function">putNextEntry</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ZipEntry</span><span class="token punctuation">(</span>i <span class="token operator">+</span> SUFFIX_FILE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                fileChannel<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> FILE_SIZE<span class="token punctuation">,</span> writableByteChannel<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">printInfo</span><span class="token punctuation">(</span>beginTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看到这里并没有使用<code>ByteBuffer</code>进行数据传输，而是使用了<code>transferTo</code>的方法。这个方法是将两个通道进行直连。</p><pre class="line-numbers language-csharp"><code class="language-csharp">This method <span class="token keyword">is</span> potentially much more efficient than a simple loop<span class="token operator">*</span> that reads <span class="token keyword">from</span> <span class="token keyword">this</span> channel and writes to the target channel<span class="token punctuation">.</span>  Many<span class="token operator">*</span> operating systems can transfer bytes directly <span class="token keyword">from</span> the filesystem cache<span class="token operator">*</span> to the target channel without actually copying them<span class="token punctuation">.</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这是源码上的描述文字，大概意思就是使用<code>transferTo</code>的效率比循环一个<code>Channel</code>读取出来然后再循环写入另一个<code>Channel</code>好。操作系统能够直接传输字节从文件系统缓存到目标的<code>Channel</code>中，而不需要实际的<code>copy</code>阶段。</p><blockquote><p>copy阶段就是从内核空间转到用户空间的一个过程</p></blockquote><p>可以看到速度相比较使用缓冲区已经有了一些的提高。</p><pre class="line-numbers language-css"><code class="language-css">------Channel<span class="token property">fileSize</span><span class="token punctuation">:</span><span class="token number">20</span>Mconsum <span class="token property">time</span><span class="token punctuation">:</span><span class="token number">1416</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h4><p>那么为什么从内核空间转向用户空间这段过程会慢呢？首先我们需了解的是什么是内核空间和用户空间。在常用的操作系统中为了保护系统中的核心资源，于是将系统设计为四个区域，越往里权限越大，所以Ring0被称之为内核空间，用来访问一些关键性的资源。Ring3被称之为用户空间。</p><p><img src="https://upload-images.jianshu.io/upload_images/13146186-38f92e6466efaf60.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image</p><blockquote><p>用户态、内核态：线程处于内核空间称之为内核态，线程处于用户空间属于用户态</p></blockquote><p>那么我们如果此时应用程序（应用程序是都属于用户态的）需要访问核心资源怎么办呢？那就需要调用内核中所暴露出的接口用以调用，称之为<strong>系统调用</strong>。例如此时我们应用程序需要访问磁盘上的文件。此时应用程序就会调用系统调用的接口<code>open</code>方法，然后内核去访问磁盘中的文件，将文件内容返回给应用程序。大致的流程如下</p><p><img src="https://upload-images.jianshu.io/upload_images/13146186-53cc9499caddb485.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image</p><h4 id="直接缓冲区和非直接缓冲区"><a href="#直接缓冲区和非直接缓冲区" class="headerlink" title="直接缓冲区和非直接缓冲区"></a>直接缓冲区和非直接缓冲区</h4><p>既然我们要读取一个磁盘的文件，要废这么大的周折。有没有什么简单的方法能够使我们的应用直接操作磁盘文件，不需要内核进行中转呢？有，那就是建立直接缓冲区了。</p><ul><li><p>非直接缓冲区：非直接缓冲区就是我们上面所讲内核态作为中间人，每次都需要内核在中间作为中转。</p><p><img src="https://upload-images.jianshu.io/upload_images/13146186-6bbfb5446221cb2d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/812/format/webp" alt="img"></p><p>image</p></li><li><p>直接缓冲区：直接缓冲区不需要内核空间作为中转copy数据，而是直接在物理内存申请一块空间，这块空间映射到内核地址空间和用户地址空间，应用程序与磁盘之间数据的存取通过这块直接申请的物理内存进行交互。</p><p><img src="https://upload-images.jianshu.io/upload_images/13146186-92211d2b9a85215e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/790/format/webp" alt="img"></p><p>image</p></li></ul><p>既然直接缓冲区那么快，我们为什么不都用直接缓冲区呢？其实直接缓冲区有以下的缺点。直接缓冲区的缺点：</p><ol><li>不安全</li><li>消耗更多，因为它不是在JVM中直接开辟空间。这部分内存的回收只能依赖于垃圾回收机制，垃圾什么时候回收不受我们控制。</li><li>数据写入物理内存缓冲区中，程序就丧失了对这些数据的管理，即什么时候这些数据被最终写入从磁盘只能由操作系统来决定，应用程序无法再干涉。</li></ol><blockquote><p>综上所述，所以我们使用<code>transferTo</code>方法就是直接开辟了一段直接缓冲区。所以性能相比而言提高了许多</p></blockquote><h3 id="使用内存映射文件"><a href="#使用内存映射文件" class="headerlink" title="使用内存映射文件"></a>使用内存映射文件</h3><p>NIO中新出的另一个特性就是内存映射文件，内存映射文件为什么速度快呢？其实原因和上面所讲的一样，也是在内存中开辟了一段直接缓冲区。与数据直接作交互。源码如下</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Version 4 使用Map映射文件</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">zipFileMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//开始时间</span>    <span class="token keyword">long</span> beginTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    File zipFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>ZIP_FILE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>ZipOutputStream zipOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>zipFile<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            WritableByteChannel writableByteChannel <span class="token operator">=</span> Channels<span class="token punctuation">.</span><span class="token function">newChannel</span><span class="token punctuation">(</span>zipOut<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            zipOut<span class="token punctuation">.</span><span class="token function">putNextEntry</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ZipEntry</span><span class="token punctuation">(</span>i <span class="token operator">+</span> SUFFIX_FILE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//内存中的映射文件</span>            MappedByteBuffer mappedByteBuffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span>JPG_FILE_PATH<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>FileChannel<span class="token punctuation">.</span>MapMode<span class="token punctuation">.</span>READ_ONLY<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> FILE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            writableByteChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>mappedByteBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printInfo</span><span class="token punctuation">(</span>beginTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印如下</p><pre class="line-numbers language-css"><code class="language-css">---------Map<span class="token property">fileSize</span><span class="token punctuation">:</span><span class="token number">20</span>Mconsum <span class="token property">time</span><span class="token punctuation">:</span><span class="token number">1305</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到速度和使用Channel的速度差不多的。</p><h3 id="使用Pipe"><a href="#使用Pipe" class="headerlink" title="使用Pipe"></a>使用Pipe</h3><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。其中source通道用于读取数据，sink通道用于写入数据。可以看到源码中的介绍，大概意思就是写入线程会阻塞至有读线程从通道中读取数据。如果没有数据可读，读线程也会阻塞至写线程写入数据。直至通道关闭。</p><pre class="line-numbers language-ruby"><code class="language-ruby"> <span class="token constant">Whether</span> <span class="token keyword">or</span> <span class="token keyword">not</span> a thread writing bytes to a pipe will block <span class="token keyword">until</span> another thread reads those bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://upload-images.jianshu.io/upload_images/13146186-3fbae68c65487c14.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/860/format/webp" alt="img"></p><p>image</p><p>我想要的效果是这样的。源码如下</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Version 5 使用Pip</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">zipFilePip</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> beginTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">(</span>WritableByteChannel out <span class="token operator">=</span> Channels<span class="token punctuation">.</span><span class="token function">newChannel</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>ZIP_FILE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Pipe pipe <span class="token operator">=</span> Pipe<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//异步任务</span>        CompletableFuture<span class="token punctuation">.</span><span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">runTask</span><span class="token punctuation">(</span>pipe<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取读通道</span>        ReadableByteChannel readableByteChannel <span class="token operator">=</span> pipe<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> FILE_SIZE<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>readableByteChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>            buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printInfo</span><span class="token punctuation">(</span>beginTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//异步任务</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">runTask</span><span class="token punctuation">(</span>Pipe pipe<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">(</span>ZipOutputStream zos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipOutputStream</span><span class="token punctuation">(</span>Channels<span class="token punctuation">.</span><span class="token function">newOutputStream</span><span class="token punctuation">(</span>pipe<span class="token punctuation">.</span><span class="token function">sink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            WritableByteChannel out <span class="token operator">=</span> Channels<span class="token punctuation">.</span><span class="token function">newChannel</span><span class="token punctuation">(</span>zos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            zos<span class="token punctuation">.</span><span class="token function">putNextEntry</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ZipEntry</span><span class="token punctuation">(</span>i<span class="token operator">+</span>SUFFIX_FILE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            FileChannel jpgChannel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>JPG_FILE_PATH<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jpgChannel<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> FILE_SIZE<span class="token punctuation">,</span> out<span class="token punctuation">)</span><span class="token punctuation">;</span>            jpgChannel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>生活处处都需要学习，有时候只是一个简单的优化，可以让你深入学习到各种不同的知识。所以在学习中要不求甚解，不仅要知道这个知识也要了解为什么要这么做。</li><li>知行合一：学习完一个知识要尽量应用一遍。这样才能记得牢靠。</li></ul><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a><a href="https://links.jianshu.com/go?to=https://github.com/modouxiansheng/Doraemon">源码地址</a></h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.jianshu.com/p/f90866dcbffc">https://www.jianshu.com/p/f90866dcbffc</a></li><li><a href="https://links.jianshu.com/go?to=https://juejin.im/post/5af942c6f265da0b7026050c">https://juejin.im/post/5af942c6f265da0b7026050c</a></li><li><a href="https://links.jianshu.com/go?to=https://time.geekbang.org/column/article/90109">趣谈Linux操作系统</a></li><li><a href="https://links.jianshu.com/go?to=https://my.oschina.net/happyBKs/blog/1592329">JAVA NIO 直接缓冲区和非直接缓冲区</a></li></ul><p>作者：不学无数的程序员<br>链接：<a href="https://www.jianshu.com/p/25b328753017">https://www.jianshu.com/p/25b328753017</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史上最全面的 Lombok 注解介绍</title>
      <link href="2020/12/28/lombok/"/>
      <url>2020/12/28/lombok/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-Getter-and-Setter"><a href="#一、-Getter-and-Setter" class="headerlink" title="一、@Getter and @Setter"></a><strong>一、@Getter and @Setter</strong></h2><p>使用<code>@Getter</code>和/或<code>@Setter</code>注释任何字段，以使<code>lombok</code>自动生成默认的<code>getter / setter</code>。</p><p>默认的<code>getter</code>只是返回该字段，如果该字段被称为<code>foo</code>，则名为<code>getFoo</code>（如果该字段的类型为<code>boolean</code>，则为<code>isFoo</code>）。</p><p>默认生成的 <code>getter / setter</code>方法是公共的，除非你明确指定一个<code>AccessLevel</code>。合法访问级别为<code>PUBLIC，PROTECTED，PACKAGE和PRIVATE</code>。</p><p>你还可以在类上添加<code>@Getter</code>和/或<code>@Setter</code>注释。在这种情况下，就好像你使用该注释来注释该类中的所有非静态字段一样。</p><p>你始终可以使用特殊的<code>AccessLevel.NONE</code>访问级别来手动禁用任何字段的<code>getter / setter</code>生成。这使你可以覆盖类上的<code>@Getter，@Setter或@Data</code>注释的行为。</p><p>With Lombok：</p><pre><code>import lombok.AccessLevel;import lombok.Getter;import lombok.Setter;public class GetterSetterExample {  @Getter   @Setter   private int age = 10;  @Setter(AccessLevel.PROTECTED)   private String name;  @Override   public String toString() {    return String.format("%s (age: %d)", name, age);  }}</code></pre><p>Native Java：</p><pre><code>public class GetterSetterExample {  private int age = 10;  private String name;  @Override   public String toString() {    return String.format("%s (age: %d)", name, age);  }  public int getAge() {    return age;  }  public void setAge(int age) {    this.age = age;  }  protected void setName(String name) {    this.name = name;  }}</code></pre><h2 id="二、-ToString"><a href="#二、-ToString" class="headerlink" title="二、@ToString"></a><strong>二、@ToString</strong></h2><p>任何类定义都可以使用<code>@ToString</code>注释，以使<code>lombok</code>生成<code>toString()</code>方法的实现。</p><p>默认情况下，将打印所有非静态字段。如果要跳过某些字段，可以使用<code>@ ToString.Exclude</code>注释这些字段。或者，可以通过使用<code>@ToString（onlyExplicitlyIncluded = true）</code>，然后使用<code>@ToString.Include</code>标记要包含的每个字段，来确切指定希望使用的字段。</p><p>通过将<code>callSuper</code>设置为<code>true</code>，可以将<code>toString</code>的超类实现的输出包含到输出中。请注意，<code>java.lang.Object中toString()</code> 的默认实现几乎毫无意义。</p><p>With Lombok：</p><pre><code>import lombok.ToString;@ToStringpublic class ToStringExample {  private static final int STATIC_VAR = 10;  private String name;  private Shape shape = new Square(5, 10);  private String[] tags;  @ToString.Exclude   private int id;  public String getName() {    return this.name;  }  @ToString(callSuper=true, includeFieldNames=true)  public static class Square extends Shape {    private final int width, height;    public Square(int width, int height) {      this.width = width;      this.height = height;    }  }}</code></pre><p>Native Java：</p><pre><code>import java.util.Arrays;public class ToStringExample {  private static final int STATIC_VAR = 10;  private String name;  private Shape shape = new Square(5, 10);  private String[] tags;  private int id;  public String getName() {    return this.name;  }  public static class Square extends Shape {    private final int width, height;    public Square(int width, int height) {      this.width = width;      this.height = height;    }    @Override     public String toString() {      return "Square(super=" + super.toString() + ", width=" + this.width + ", height=" + this.height + ")";    }  }  @Override   public String toString() {    return "ToStringExample(" + this.getName() + ", " + this.shape + ", " + Arrays.deepToString(this.tags) + ")";  }}</code></pre><h2 id="三、-EqualsAndHashCode"><a href="#三、-EqualsAndHashCode" class="headerlink" title="三、@EqualsAndHashCode"></a><strong>三、@EqualsAndHashCode</strong></h2><p>任何类定义都可以使用<code>@EqualsAndHashCode</code>进行注释，以使<code>lombok</code>生成<code>equals(Object other)</code>和<code>hashCode()</code>方法的实现。默认情况下，它将使用所有非静态，非瞬态字段，但是您可以通过使用<code>@EqualsAndHashCode.Include</code>标记类型成员来修改使用哪些字段（甚至指定要使用各种方法的输出）。 <code>@EqualsAndHashCode.Exclude</code>。或者，可以通过使用@ <code>EqualsAndHashCode.Include</code>标记并使用<code>@EqualsAndHashCode(onlyExplicitlyIncluded = true)</code>来精确指定要使用的字段或方法。</p><p>如果将<code>@EqualsAndHashCode</code>应用于扩展另一个类的类，则此功能会有些棘手。通常，为此类自动生成<code>equals</code>和<code>hashCode</code>方法是一个坏主意，因为超类还定义了字段，该字段也需要<code>equals / hashCode</code>代码，但不会生成此代码。通过将<code>callSuper</code>设置为<code>true</code>，可以在生成的方法中包括超类的<code>equals</code>和<code>hashCode</code>方法。</p><p>With Lombok：</p><pre><code>import lombok.EqualsAndHashCode;@EqualsAndHashCodepublic class EqualsAndHashCodeExample {  private transient int transientVar = 10;  private String name;  private double score;  @EqualsAndHashCode.Exclude   private Shape shape = new Square(5, 10);  private String[] tags;  @EqualsAndHashCode.Exclude   private int id;  public String getName() {    return this.name;  }  @EqualsAndHashCode(callSuper=true)  public static class Square extends Shape {    private final int width, height;    public Square(int width, int height) {      this.width = width;      this.height = height;    }  }}</code></pre><p>Native Java：</p><pre><code>import java.util.Arrays;public class EqualsAndHashCodeExample {  private transient int transientVar = 10;  private String name;  private double score;  private Shape shape = new Square(5, 10);  private String[] tags;  private int id;  public String getName() {    return this.name;  }  @Override   public boolean equals(Object o) {    if (o == this) return true;    if (!(o instanceof EqualsAndHashCodeExample)) return false;    EqualsAndHashCodeExample other = (EqualsAndHashCodeExample) o;    if (!other.canEqual((Object)this)) return false;    if (this.getName() == null ? other.getName() != null : !this.getName().equals(other.getName())) return false;    if (Double.compare(this.score, other.score) != 0) return false;    if (!Arrays.deepEquals(this.tags, other.tags)) return false;    return true;  }  @Override   public int hashCode() {    final int PRIME = 59;    int result = 1;    final long temp1 = Double.doubleToLongBits(this.score);    result = (result*PRIME) + (this.name == null ? 43 : this.name.hashCode());    result = (result*PRIME) + (int)(temp1 ^ (temp1 &gt;&gt;&gt; 32));    result = (result*PRIME) + Arrays.deepHashCode(this.tags);    return result;  }  protected boolean canEqual(Object other) {    return other instanceof EqualsAndHashCodeExample;  }  public static class Square extends Shape {    private final int width, height;    public Square(int width, int height) {      this.width = width;      this.height = height;    }    @Override     public boolean equals(Object o) {      if (o == this) return true;      if (!(o instanceof Square)) return false;      Square other = (Square) o;      if (!other.canEqual((Object)this)) return false;      if (!super.equals(o)) return false;      if (this.width != other.width) return false;      if (this.height != other.height) return false;      return true;    }    @Override     public int hashCode() {      final int PRIME = 59;      int result = 1;      result = (result*PRIME) + super.hashCode();      result = (result*PRIME) + this.width;      result = (result*PRIME) + this.height;      return result;    }    protected boolean canEqual(Object other) {      return other instanceof Square;    }  }}</code></pre><h2 id="四、-AllArgsConstructor"><a href="#四、-AllArgsConstructor" class="headerlink" title="四、@AllArgsConstructor"></a><strong>四、@AllArgsConstructor</strong></h2><p><strong>@RequiredArgsConstructor</strong></p><p><strong>@NoArgsConstructor</strong></p><p><code>@NoArgsConstructor</code>将生成没有参数的构造函数。如果字段由final修饰，则将导致编译器错误，除非使用<code>@NoArgsConstructor(force = true)</code>，否则所有final字段都将初始化为<code>0 / false / null</code>。对于具有约束的字段(例如<code>@NonNull</code>字段)，不会生成任何检查。</p><p><code>@RequiredArgsConstructor</code>为每个需要特殊处理的字段生成一个带有1个参数的构造函数。所有未初始化的final字段都会获取一个参数，以及所有未声明其位置的未标记为<code>@NonNull</code>的字段。</p><p><code>@AllArgsConstructor</code>为类中的每个字段生成一个带有1个参数的构造函数。标有<code>@NonNull</code>的字段将对这些参数进行空检查。</p><p>With Lombok：</p><pre><code>import lombok.AccessLevel;import lombok.RequiredArgsConstructor;import lombok.AllArgsConstructor;import lombok.NonNull;@RequiredArgsConstructor(staticName = "of")@AllArgsConstructor(access = AccessLevel.PROTECTED)public class ConstructorExample&lt;T&gt; {  private int x, y;  @NonNull   private T description;  @NoArgsConstructor  public static class NoArgsExample {    @NonNull     private String field;  }}</code></pre><p>Native Java：</p><pre><code>public class ConstructorExample&lt;T&gt; {  private int x, y;  @NonNull   private T description;  private ConstructorExample(T description) {    if (description == null) throw new NullPointerException("description");    this.description = description;  }  public static &lt;T&gt; ConstructorExample&lt;T&gt; of(T description) {    return new ConstructorExample&lt;T&gt;(description);  }  @java.beans.ConstructorProperties({"x", "y", "description"})  protected ConstructorExample(int x, int y, T description) {    if (description == null) throw new NullPointerException("description");    this.x = x;    this.y = y;    this.description = description;  }  public static class NoArgsExample {    @NonNull     private String field;    public NoArgsExample() {    }  }}</code></pre><h2 id="五、-Data"><a href="#五、-Data" class="headerlink" title="五、@Data"></a><strong>五、@Data</strong></h2><p><code>@Data</code>是一个方便的快捷方式批注，它将<code>@ToString</code>，<code>@EqualsAndHashCode</code>，<code>@ Getter / @Setter</code>和<code>@RequiredArgsConstructor</code>的功能捆绑在一起：换句话说，<code>@Data</code>生成通常与简单<code>POJO</code>关联的所有样板（普通的旧<code>Java</code>对象）和<code>bean</code>：所有字段的<code>getter</code>，所有<code>非final</code>字段的<code>setter</code>，以及涉及类字段的适当的<code>toString</code>，<code>equals</code>和<code>hashCode</code>实现，以及初始化所有<code>final</code>字段以及所有<code>非final</code>字段的构造函数没有使用<code>@NonNull</code>标记的初始化程序，以确保该字段永远不会为<code>null</code>。</p><p>With Lombok：</p><pre><code>import lombok.AccessLevel;import lombok.Setter;import lombok.Data;import lombok.ToString;@Data public class DataExample {  private final String name;  @Setter(AccessLevel.PACKAGE)   private int age;  private double score;  private String[] tags;  @ToString(includeFieldNames=true)  @Data(staticConstructor="of")  public static class Exercise&lt;T&gt; {    private final String name;    private final T value;  }}</code></pre><p>Native Java：</p><pre><code>import java.util.Arrays;public class DataExample {  private final String name;  private int age;  private double score;  private String[] tags;  public DataExample(String name) {    this.name = name;  }  public String getName() {    return this.name;  }  void setAge(int age) {    this.age = age;  }  public int getAge() {    return this.age;  }  public void setScore(double score) {    this.score = score;  }  public double getScore() {    return this.score;  }  public String[] getTags() {    return this.tags;  }  public void setTags(String[] tags) {    this.tags = tags;  }  @Override   public String toString() {    return "DataExample(" + this.getName() + ", " + this.getAge() + ", " + this.getScore() + ", " + Arrays.deepToString(this.getTags()) + ")";  }  protected boolean canEqual(Object other) {    return other instanceof DataExample;  }  @Override   public boolean equals(Object o) {    if (o == this) return true;    if (!(o instanceof DataExample)) return false;    DataExample other = (DataExample) o;    if (!other.canEqual((Object)this)) return false;    if (this.getName() == null ? other.getName() != null : !this.getName().equals(other.getName())) return false;    if (this.getAge() != other.getAge()) return false;    if (Double.compare(this.getScore(), other.getScore()) != 0) return false;    if (!Arrays.deepEquals(this.getTags(), other.getTags())) return false;    return true;  }  @Override   public int hashCode() {    final int PRIME = 59;    int result = 1;    final long temp1 = Double.doubleToLongBits(this.getScore());    result = (result*PRIME) + (this.getName() == null ? 43 : this.getName().hashCode());    result = (result*PRIME) + this.getAge();    result = (result*PRIME) + (int)(temp1 ^ (temp1 &gt;&gt;&gt; 32));    result = (result*PRIME) + Arrays.deepHashCode(this.getTags());    return result;  }  public static class Exercise&lt;T&gt; {    private final String name;    private final T value;    private Exercise(String name, T value) {      this.name = name;      this.value = value;    }    public static &lt;T&gt; Exercise&lt;T&gt; of(String name, T value) {      return new Exercise&lt;T&gt;(name, value);    }    public String getName() {      return this.name;    }    public T getValue() {      return this.value;    }    @Override     public String toString() {      return "Exercise(name=" + this.getName() + ", value=" + this.getValue() + ")";    }    protected boolean canEqual(Object other) {      return other instanceof Exercise;    }    @Override     public boolean equals(Object o) {      if (o == this) return true;      if (!(o instanceof Exercise)) return false;      Exercise&lt;?&gt; other = (Exercise&lt;?&gt;) o;      if (!other.canEqual((Object)this)) return false;      if (this.getName() == null ? other.getValue() != null : !this.getName().equals(other.getName())) return false;      if (this.getValue() == null ? other.getValue() != null : !this.getValue().equals(other.getValue())) return false;      return true;    }    @Override     public int hashCode() {      final int PRIME = 59;      int result = 1;      result = (result*PRIME) + (this.getName() == null ? 43 : this.getName().hashCode());      result = (result*PRIME) + (this.getValue() == null ? 43 : this.getValue().hashCode());      return result;    }  }}</code></pre><h2 id="六、-Value"><a href="#六、-Value" class="headerlink" title="六、@Value"></a><strong>六、@Value</strong></h2><p>@Value注解和<code>@Data</code>类似，区别在于它会把所有成员变量默认定义为<code>private final</code>修饰，并且不会生成<code>set</code>方法。</p><h2 id="七、-Builder"><a href="#七、-Builder" class="headerlink" title="七、@Builder"></a><strong>七、@Builder</strong></h2><p>构建者模式</p><p>只能标注到类上，将生成类的一个当前流程的一种链式构造工厂，如下：</p><pre><code>User buildUser = User.builder().username("riemann").password("123").build();</code></pre><p>可配合<code>@Singular</code>注解使用，<code>@Singular</code>注解使用在jdk内部集合类型的属性，<code>Map</code>类型的属性以及<code>Guava</code>的<code>com.google.common.collect</code> 的属性上。例如 未标注<code>@Singular</code>的属性，一般<code>setter</code>时，会直接覆盖原来的引用，标注了<code>@Singular</code>的属性，集合属性支持添加操作，会在属性原来的基础上增加。</p><p>With Lombok：</p><pre><code>import lombok.Builder;import lombok.Singular;import java.util.Set;@Builderpublic class BuilderExample {  @Builder.Default   private long created = System.currentTimeMillis();  private String name;  private int age;  @Singular   private Set&lt;String&gt; occupations;}</code></pre><p>Native Java：</p><pre><code>import java.util.Set;public class BuilderExample {  private long created;  private String name;  private int age;  private Set&lt;String&gt; occupations;  BuilderExample(String name, int age, Set&lt;String&gt; occupations) {    this.name = name;    this.age = age;    this.occupations = occupations;  }  private static long $default$created() {    return System.currentTimeMillis();  }  public static BuilderExampleBuilder builder() {    return new BuilderExampleBuilder();  }  public static class BuilderExampleBuilder {    private long created;    private boolean created$set;    private String name;    private int age;    private java.util.ArrayList&lt;String&gt; occupations;    BuilderExampleBuilder() {    }    public BuilderExampleBuilder created(long created) {      this.created = created;      this.created$set = true;      return this;    }    public BuilderExampleBuilder name(String name) {      this.name = name;      return this;    }    public BuilderExampleBuilder age(int age) {      this.age = age;      return this;    }    public BuilderExampleBuilder occupation(String occupation) {      if (this.occupations == null) {        this.occupations = new java.util.ArrayList&lt;String&gt;();      }      this.occupations.add(occupation);      return this;    }    public BuilderExampleBuilder occupations(Collection&lt;? extends String&gt; occupations) {      if (this.occupations == null) {        this.occupations = new java.util.ArrayList&lt;String&gt;();      }      this.occupations.addAll(occupations);      return this;    }    public BuilderExampleBuilder clearOccupations() {      if (this.occupations != null) {        this.occupations.clear();      }      return this;    }    public BuilderExample build() {      // complicated switch statement to produce a compact properly sized immutable set omitted.      Set&lt;String&gt; occupations = ...;      return new BuilderExample(created$set ? created : BuilderExample.$default$created(), name, age, occupations);    }    @java.lang.Override    public String toString() {      return "BuilderExample.BuilderExampleBuilder(created = " + this.created + ", name = " + this.name + ", age = " + this.age + ", occupations = " + this.occupations + ")";    }  }}</code></pre><h2 id="八、-Accessors"><a href="#八、-Accessors" class="headerlink" title="八、@Accessors"></a><strong>八、@Accessors</strong></h2><p>链式风格</p><p><code>@Accessors</code>批注用于配置<code>lombok</code>如何生成和查找<code>getter</code>和<code>setter</code>。</p><p>默认情况下，<code>lombok</code>遵循针对<code>getter</code>和<code>setter</code>的<code>bean</code>规范：例如，名为<code>Pepper</code>的字段的<code>getter</code>是<code>getPepper</code>。但是，有些人可能希望打破<code>bean</code>规范，以得到更好看的<code>API</code>。 <code>@Accessors</code>允许您执行此操作。</p><p>可标注在类或属性上，当然最实用的功能还是标注到类上。</p><p>标注到类上，<code>chain</code>属性设置为<code>true</code>时，类的所有属性的<code>setter</code>方法返回值将为<code>this</code>，用来支持<code>setter</code>方法的链式写法。如：</p><pre><code>new User().setUsername("riemann").setPassword("123");</code></pre><p><code>fluent</code>属性设置为<code>true</code>时，类的所有<code>getter</code>，<code>setter</code>方法将省略<code>get</code>和<code>set</code>前缀，获取属性值直接使用属性名相同的无参方法，设置属性值使用属性名相同的有参方法，并且返回值为this。如：</p><pre><code>User user = new User().username("riemann").password("123");String username = user.username();String password = user.password();</code></pre><p>标注到属性上，使用<code>prefix</code>设置需要省略的属性生成<code>getter</code>，<code>setter</code>方法时的前缀，且属性必须为驼峰式命名。</p><pre><code>@Accessors(prefix = "r")@Getter@Setterprivate String rUsername = "riemann";</code></pre><p>编译之后为</p><pre><code>public String getUsername() {    return rUsername;}public void setUsername(String rUsername) {    this.rUsername = rUsername;}</code></pre><h2 id="九、-Slf4j-and-Log4j"><a href="#九、-Slf4j-and-Log4j" class="headerlink" title="九、@Slf4j and @Log4j"></a><strong>九、@Slf4j and @Log4j</strong></h2><p>在需要打印日志的类中使用，项目中使用<code>slf4j</code>、<code>log4j</code>日志框架</p><h2 id="十、-NonNull"><a href="#十、-NonNull" class="headerlink" title="十、@NonNull"></a><strong>十、@NonNull</strong></h2><p>该注解快速判断是否为空,为空抛出<code>java.lang.NullPointerException</code>。</p><h2 id="十一、-Synchronized"><a href="#十一、-Synchronized" class="headerlink" title="十一、@Synchronized"></a><strong>十一、@Synchronized</strong></h2><p>注解自动添加到同步机制，生成的代码并不是直接锁方法,而是锁代码块， 作用范围是方法上。</p><h2 id="十二、-Cleanup"><a href="#十二、-Cleanup" class="headerlink" title="十二、@Cleanup"></a><strong>十二、@Cleanup</strong></h2><p>注解用于确保已分配的资源被释放（<code>IO</code>的连接关闭）。</p><blockquote><p>作者：riemann_</p><p>blog.csdn.net/riemann_/article/details/105374987</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String对象的那些事，几行代码就解释得清清楚楚</title>
      <link href="2020/12/26/string/"/>
      <url>2020/12/26/string/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>String是Java中十分常用的类，在面试题中也是出镜率很高的常客，本文将我自己学习中遇到的一些问题进行整理，如果有误，欢迎指正。</p><h2 id="String对象判等"><a href="#String对象判等" class="headerlink" title="String对象判等"></a>String对象判等</h2><p>千万不要用 == 去判断String对象是否相等，==比较的是地址。JVM只会共享字符串常量，因此，即使是“看起来”值相同的字符串，用==判断也可能不相等。</p><p>举例来说，下面这段代码中，变量x和y都指向了常量池中共享的”a”，地址相同，但是z是Java堆中的新建对象的引用，其地址与x不同，所以返回了false。</p><p>并且每次new一个String对象时，即使字符串内容相同，也会新开辟一片空间存储对象，因此z和zCopy地址也是不用的。</p><p>这部分的细节原理在下一部分中解释。总而言之，如果你只是想判断两个String对象的内容是否一样，请使用x.equals(z)的形式。</p><p><strong>代码一</strong></p><pre class="line-numbers language-java"><code class="language-java">String x <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span>String y <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span>String z <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String zCopy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token operator">==</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token operator">==</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>z<span class="token operator">==</span>zCopy<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="String与常量池"><a href="#String与常量池" class="headerlink" title="String与常量池"></a>String与常量池</h2><p><strong>我们在给String类型的引用赋值的时候会先看常量池中是否存在这个字符串对象的引用，若有就直接返回这个引用，若没有，就在堆里创建这个字符串对象并在字符串常量池中记录下这个引用。</strong></p><p><strong>注意：常量池中存放的是引用，并不是实例！！！</strong></p><p>下面结合具体代码来理解这段话，看下面这段代码</p><p><strong>代码二</strong></p><pre class="line-numbers language-java"><code class="language-java">String x <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span>String y <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token string">"b"</span><span class="token punctuation">;</span>String z <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>用javap -v -c对.class文件进行反编译后，得到如下结果</p><p><img src="https://p1-tt.byteimg.com/origin/pgc-image/fcfcda2b505843dd912bc8e68131ff2a?from=pc" alt="String对象的那些事，几行代码就解释得清清楚楚"></p><p>可以看到，常量池中最中只保留了一份”a”的引用。因为在String z = “a”;执行时，字符串常量池中已经有”a”的引用了，不会重复创建。</p><p>同时我们注意到，对应String y = “a” + “b”;这条语句，因为”a”和”b”都是编译器就能确定的常量，所以常量池只保留了最终计算的结果，并没有单独保留”b”。</p><p>我们将代码稍作修改，然后再次反编译。</p><p><strong>代码三</strong></p><pre class="line-numbers language-java"><code class="language-java">String witcher <span class="token operator">=</span> <span class="token string">"Geralt"</span><span class="token punctuation">;</span>String sorceress <span class="token operator">=</span> <span class="token string">"Yennefer"</span><span class="token punctuation">;</span>String date <span class="token operator">=</span> witcher <span class="token operator">+</span> sorceress<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://p3-tt.byteimg.com/origin/pgc-image/8ce7520200314d68a74f91dd51309ea2?from=pc" alt="String对象的那些事，几行代码就解释得清清楚楚"></p><p>可以看出，最终常量池只存储了”Geralt”和”Yennefer”两个引用，而没有存放拼接的结果。因为witcher和sorceress变量要运行时才能确定。<strong>但是如果将变量witcher和sorceress都声明为final，那编译期就可以确定，因此拼接结果的引用信息也会放入常量池。</strong></p><p><strong>总结：</strong></p><p>对于字符串表达式而言</p><p>1、对于编译期能直接确定的值（字面量、声明为final的变量），会直接将表达式的结果放入常量池。</p><p>2、如果编译期不能直接直接确定（非final的变量），那么只将已经声明字符串字面常量放入常量池，表达式的结果不放入常量池。</p><p>关于常量池的更多介绍欢迎查看我的另一篇博客一张图秒懂JVM内存区域的划分</p><p><strong>另一个出镜率很高的问题是如下的这段代码创建了几个对象？</strong></p><pre class="line-numbers language-java"><code class="language-java">String s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"xyz"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于这个问题网上众说纷纭，这里放上一种比较靠谱的说法。参考自R神的博客请别再拿“String s = new String(“xyz”);创建了多少个String实例”来面试了吧</p><p>首先，换个问法，这段代码在运行时涉及几个String实例？</p><p>一种合理的解释是：两个，一个是字符串字面量”xyz”所对应的、驻留（intern）在一个全局共享的字符串常量池中的实例，另一个是通过new String(String)创建并初始化的、内容与”xyz”相同的实例。</p><h2 id="StringBuilder与StringBuffer"><a href="#StringBuilder与StringBuffer" class="headerlink" title="StringBuilder与StringBuffer"></a>StringBuilder与StringBuffer</h2><p>如果你查看过源码，就会发现String对象是被final修饰的，这意味着它是不可变的。因此，当我们拼接字符串时，会产生新的对象。为此，设计者们提供了StringBuilder类来避免产生过多的中间对象。当我们用+拼接字符串时，编译器会自动帮我们使用StringBuilder进行优化。</p><p>这次使用jad对<strong>代码二</strong>进行反编译（直接用javap -v也可以，但是使用jad产生的结果更容易看懂)</p><p>得到如下结果 可以看到编译器自动为我们使用了StringBuilder</p><pre class="line-numbers language-java"><code class="language-java">String witcher <span class="token operator">=</span> <span class="token string">"Geralt"</span><span class="token punctuation">;</span>String sorceress <span class="token operator">=</span> <span class="token string">"Yennefer"</span><span class="token punctuation">;</span>String date <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>witcher<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>sorceress<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>有人会说，既然编译器已经优化，我们就直接使用+拼接字符串就可以啊，为什么还要用StringBuilder?</p><p>来看这段代码</p><p><strong>代码四</strong></p><pre class="line-numbers language-java"><code class="language-java">String witcher <span class="token operator">=</span> <span class="token string">"Geralt"</span><span class="token punctuation">;</span>String sorceress <span class="token operator">=</span> <span class="token string">"Yennefer"</span><span class="token punctuation">;</span>String res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    res <span class="token operator">+=</span> sorceress<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对其反编译，可得</p><pre class="line-numbers language-java"><code class="language-java">String witcher <span class="token operator">=</span> <span class="token string">"Geralt"</span><span class="token punctuation">;</span>String sorceress <span class="token operator">=</span> <span class="token string">"Yennefer"</span><span class="token punctuation">;</span>String res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>sorceress<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，每一轮的for循环都新建了一个StringBuilder，这是完全没有必要的。因此，我们应该在for循环外部先定义一个StringBuilder对象，这样只新建了一个对象就完成了任务，效率大增。</p><p>StringBuffer和StringBuilder基本相同，但是它保证了线程安全，如果有多线程需求，可以按需使用。</p><h2 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h2><p>我们用下面这段代码来分析intern的作用</p><p><strong>代码五</strong></p><pre class="line-numbers language-java"><code class="language-java">String witcher1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Geralt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String witcher2 <span class="token operator">=</span> <span class="token string">"Geralt"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>witcher1 <span class="token operator">==</span> witcher2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false </span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>witcher1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> witcher2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第三行显然是false，这在本文最开始已经解释过。</p><p>但是witcher1调用intern之后，地址就与witcher2相同了，这是为什么？</p><p>原来，当一个对象调用intern方法时，会查看常量池是否有与当前对象内容相同的字面量，如果有，就直接返回常量池中的引用信息，如果没有，就在常量池中补充当前对象的字面量，然后返回引用。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h2><p>以上就是String类型经常引起疑惑的一些知识点。总结不易，如果有帮到你，希望可以点个赞，谢谢~</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapStruct(entity优雅的转dto)</title>
      <link href="2020/12/25/mapstruct/"/>
      <url>2020/12/25/mapstruct/</url>
      
        <content type="html"><![CDATA[<p>开发中我们可能使用JPA、通用Mapper或者MyBatis-Plus去查询数据，而这类框架都是返回的实体，实体是和数据库中的表是一一对应的，而作为接口的返回值我们无需把整个实体都暴露给前端，通常会将实体转换成另一个DTO对象来返回，通常有以下转换方式：</p><ul><li>自己写代码手动转换（这种方式代码量多，而且不优雅）</li><li>BeanUtils.copyProperties(entity, dto)，这种方式是通过反射来实现的，一般反射效率相对有点低</li><li>使用ModelMapper框架（这种方式是通过反射来实现的，一般反射效率相对有点低）</li><li>使用MapStruct框架（这种方式是在编译器自动生成转换代码，将原来的手动改为自动，相对于使用反射实现的此种方式效率更好）</li></ul><p>综合比较性能、问题排查、文档、成熟度、扩展性等因素来考虑，MapStruct 是一个不错的选择，实体映射转换各个工具比较 <a href="https://java.libhunt.com/compare-mapstruct-vs-selma">https://java.libhunt.com/compare-mapstruct-vs-selma</a></p><p><img src="https://p1-tt.byteimg.com/origin/pgc-image/8bed760a38814c578aec5fa81ed632fd?from=pc" alt="MapStruct(entity优雅的转dto)"></p><ul><li>MapStruct官网地址： <a href="http://mapstruct.org/%EF%BC%8C">http://mapstruct.org/，</a></li><li>GitHub示例程序：<a href="https://github.com/mapstruct/mapstruct-examples">https://github.com/mapstruct/mapstruct-examples</a></li></ul><h2 id="1-添加依赖-和-配置插件"><a href="#1-添加依赖-和-配置插件" class="headerlink" title="1. 添加依赖 和 配置插件"></a><strong>1. 添加依赖 和 配置插件</strong></h2><p>注意：如果使用了lombok应尽量使用比较高的版本，maven-compiler-plugin 插件也最好使用较高的版本。否则有可能报这个错：</p><p>Error:(12, 5) java: No property named “xxx” exists in source parameter(s). Did you mean “null”?</p><p>maven pom.xml：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.source</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.source</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.target</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.target</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>org.mapstruct.version</span><span class="token punctuation">></span></span>1.4.1.Final<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>org.mapstruct.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>org.projectlombok.version</span><span class="token punctuation">></span></span>1.18.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>org.projectlombok.version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mapstruct<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mapstruct<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${org.mapstruct.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${org.projectlombok.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-lang3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pluginManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.8.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>annotationProcessorPaths</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>path</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mapstruct<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mapstruct-processor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${org.mapstruct.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>path</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>path</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${org.projectlombok.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>path</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>annotationProcessorPaths</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pluginManagement</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-实体"><a href="#2-实体" class="headerlink" title="2. 实体"></a><strong>2. 实体</strong></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Getter</span><span class="token keyword">public</span> <span class="token keyword">enum</span> UserStatusEnum <span class="token punctuation">{</span>   <span class="token function">NORMAL</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"正常"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token function">LOCK</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"锁定"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> Integer code<span class="token punctuation">;</span>   <span class="token keyword">private</span> String desc<span class="token punctuation">;</span>   <span class="token function">UserStatusEnum</span><span class="token punctuation">(</span>Integer code<span class="token punctuation">,</span> String desc<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>desc <span class="token operator">=</span> desc<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserInfo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> String remark<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token keyword">private</span> UserStatusEnum userStatusEnum<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date createTime<span class="token punctuation">;</span>    <span class="token keyword">private</span> UserInfo userInfo<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-DTO"><a href="#3-DTO" class="headerlink" title="3. DTO"></a><strong>3. DTO</strong></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDTO</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String realName<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer status<span class="token punctuation">;</span>    <span class="token keyword">private</span> String address<span class="token punctuation">;</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token keyword">private</span> String createTimeFormat<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-实体与DTO属性映射配置"><a href="#4-实体与DTO属性映射配置" class="headerlink" title="4. 实体与DTO属性映射配置"></a><strong>4. 实体与DTO属性映射配置</strong></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span><span class="token punctuation">(</span>componentModel<span class="token operator">=</span><span class="token string">"spring"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserConverter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Mappings</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Mapping</span><span class="token punctuation">(</span>source <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">"realName"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Mapping</span><span class="token punctuation">(</span>target <span class="token operator">=</span> <span class="token string">"status"</span><span class="token punctuation">,</span> expression <span class="token operator">=</span> <span class="token string">"java(user.getUserStatusEnum().getCode())"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Mapping</span><span class="token punctuation">(</span>source <span class="token operator">=</span> <span class="token string">"createTime"</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">"createTimeFormat"</span><span class="token punctuation">,</span> dateFormat <span class="token operator">=</span> <span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Mapping</span><span class="token punctuation">(</span>source <span class="token operator">=</span> <span class="token string">"userInfo.address"</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Mapping</span><span class="token punctuation">(</span>target <span class="token operator">=</span> <span class="token string">"password"</span><span class="token punctuation">,</span> ignore <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    UserDTO <span class="token function">entity2dto</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>@Mapper 只有在接口加上这个注解，MapStruct 才会去实现该接口,@Mapper 里有个 componentModel 属性，主要是指定实现类的类型，一般用到两个:</li><li>default：默认，可以通过 Mappers.getMapper(Class) 方式获取实例对象。</li><li>spring：在接口的实现类上自动添加注解 @Component，可通过 @Autowired 方式注入。</li><li>@Mappings：配置多个@Mapping</li><li>@Mapping：属性映射，若源对象属性与目标对象名字一致，会自动映射对应属性</li><li>source：源属性</li><li>target：目标属性</li><li>dateFormat：String 到 Date 日期之间相互转换，通过 SimpleDateFormat，该值为 SimpleDateFormat的日期格式</li><li>expression：使用Java方法来格式化值</li><li>ignore: 忽略这个字段</li></ul><p>@Mapper可以单独放在一个类中配置，也可以在JPA或者MyBatis中的Mapper类中来配置。</p><p>手工编译（mvn compile）或者启动 IDE 的时候， 会自动在 target/classes 下生成对应的实现类。</p><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/2e81ec6f2dd641ac83215083b7b3dd0a?from=pc" alt="MapStruct(entity优雅的转dto)"></p><h2 id="5-Test"><a href="#5-Test" class="headerlink" title="5. Test"></a><strong>5. Test</strong></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">SpringbootMapstructApplicationTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserConverter userConverter<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMapStruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        UserInfo userInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userInfo<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">"上海市"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userInfo<span class="token punctuation">.</span><span class="token function">setRemark</span><span class="token punctuation">(</span><span class="token string">"此人非常懒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"周某人"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUserStatusEnum</span><span class="token punctuation">(</span>UserStatusEnum<span class="token punctuation">.</span>LOCK<span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setCreateTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUserInfo</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>        UserDTO userDTO <span class="token operator">=</span> userConverter<span class="token punctuation">.</span><span class="token function">entity2dto</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://p6-tt.byteimg.com/origin/pgc-image/33535db0ceb34ff4be0d128c89b33ce9?from=pc" alt="MapStruct(entity优雅的转dto)"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源利器：自动生成随机 mock 数据测试对象</title>
      <link href="2020/12/25/data-factory/"/>
      <url>2020/12/25/data-factory/</url>
      
        <content type="html"><![CDATA[<h2 id="测试的痛点"><a href="#测试的痛点" class="headerlink" title="测试的痛点"></a><strong>测试的痛点</strong></h2><p>大家好，我是老马。</p><p>每一位开发者大部分工作都是写代码、测试代码、修BUG。</p><p>我们有很多测试代码，总是花费大量的实践去构建一个对象。</p><p>于是就在想，能不能自动填充一个对象呢？</p><p>于是去 github 查了一下，找到了一个测试神器 data-factory。</p><blockquote><p><a href="https://github.com/houbb/data-factory/">https://github.com/houbb/data-factory/</a></p></blockquote><h2 id="data-factory"><a href="#data-factory" class="headerlink" title="data-factory"></a><strong>data-factory</strong></h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p>data-factory 项目用于根据对象，随机自动生成初始化信息。便于测试。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h3><ul><li>8 大基本类型的支持</li><li>数组、对象、枚举、Map、链表、Set 等支持</li><li>String、BigDecimal、BigInteger、Currency 等常见类型的支持</li><li>Date、LocalDate、LocalDateTime、LocalTime、Year 等常见日期类型支持</li><li>支持 Regex 正则表达式</li><li>@DataFactory 注解支持灵活配置</li></ul><p><strong>快速入门</strong></p><p>引入依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.houbb<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>data-factory-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过 DataUtil.build(class) 就可以生成对应类的随机值。</p><p>比如 DataUtil.build(String.class);，就可以生成随机的字符串：</p><pre><code>0s5Z8foS1</code></pre><p>老马发现，基本支持所有常见的类型，我们指定对应的 class 即可，这点还是挺方便的。</p><p>不过我一般都是使用对象，那可以自动填充一个对象吗？</p><h2 id="对象-bean-填充"><a href="#对象-bean-填充" class="headerlink" title="对象 bean 填充"></a><strong>对象 bean 填充</strong></h2><p>当然，最常用的还是初始化一个 java 对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthday<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> stringList<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//S/F 的枚举</span>    <span class="token keyword">private</span> StatusEnum statusEnum<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Getter &amp; Setter</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建方法 User user = DataUtil.build(User.class);</p><p>构建对象如下：</p><pre><code>User{name='wZ8CJZtK', age=-564106861, birthday=Wed Feb 27 22:14:34 CST 2019, stringList=[Du4iJkQj], statusEnum=S, map={yA5yDqM=Kdzi}}</code></pre><p>内容每次都随机，便于基本的测试数据填充。</p><h3 id="DataFactory-注解"><a href="#DataFactory-注解" class="headerlink" title="@DataFactory 注解"></a><strong><code>@DataFactory</code> 注解</strong></h3><p>当然，有时候我们希望生成的数据符合一定的规则，这个时候可以通过 @DataFactory 注解去进行限制。</p><h2 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a><strong>注解属性</strong></h2><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 数据生成注解 * @author binbin.hou * @date 2019/3/9 * @since 0.0.2 */</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">DataFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 是否忽略此字段     *     * @return 默认不忽略     */</span>    <span class="token keyword">boolean</span> <span class="token function">ignore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 数字整数部分最大值。     * 只作用于数字类型的字段     *     * @return 返回最大值     */</span>    <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 数字整数部分最小值。     * 只作用于数字类型的字段     *     * @return 返回最小值     */</span>    <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 精度。     * 作用于Float、Double、BigDecimal 小数部分长度     *     * @return 返回精度     */</span>    <span class="token keyword">int</span> <span class="token function">precision</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 最大长度。只作用于String类型的字段     *     * @return 返回最大长度     */</span>    <span class="token keyword">int</span> <span class="token function">maxLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 最小长度。只作用于String类型的字段     *     * @return 返回最小长度     */</span>    <span class="token keyword">int</span> <span class="token function">minLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 指定当前字段的类实现策略     * @return 实现类     * @since 0.0.6     */</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">IData</span><span class="token operator">></span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> IData<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 正则表达式     * 1. 当前版本为了简单方便，如果 regex 存在，则直接忽略长度，精度等其他注解配置。     * 2. 建议直接使用在 String 类型     * 3. 如果使用其他类型，则必须保证提供了对应的 String 构造器。如{@link Long#Long(String)}     * 4. 基本类型会直接使用对应的包装类型。     * @since 0.0.3     * @return 表达式信息     */</span>    String <span class="token function">regex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a><strong>String 类</strong></h2><ul><li>定义对象</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 字符串类注解测试 * @author binbin.hou * @date 2019/3/9 * @since 0.0.2 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAnnotationString</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 指定最小长度，最大长度     */</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>minLen <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> maxLen <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 忽略生成当前字段     */</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>ignore <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String hobby<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Getter &amp; Setter</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>测试代码</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**** Method: build(clazz)*/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stringAnnotationTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        UserAnnotationString userAnnotationString <span class="token operator">=</span> DataUtil<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>UserAnnotationString<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Assertions<span class="token punctuation">.</span><span class="token function">assertNull</span><span class="token punctuation">(</span>userAnnotationString<span class="token punctuation">.</span><span class="token function">getHobby</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Assertions<span class="token punctuation">.</span><span class="token function">assertTrue</span><span class="token punctuation">(</span>userAnnotationString<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Assertions<span class="token punctuation">.</span><span class="token function">assertTrue</span><span class="token punctuation">(</span>userAnnotationString<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Number-类"><a href="#Number-类" class="headerlink" title="Number 类"></a><strong>Number 类</strong></h2><ul><li>对象定义</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 数字类注解测试 * @author binbin.hou * @date 2019/3/9 * @since 0.0.2 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAnnotationNumber</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Byte aByte<span class="token punctuation">;</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Short aShort<span class="token punctuation">;</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Integer integer<span class="token punctuation">;</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Long aLong<span class="token punctuation">;</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span> precision <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Double aDouble<span class="token punctuation">;</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span> precision <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Float aFloat<span class="token punctuation">;</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span> precision <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> BigDecimal bigDecimal<span class="token punctuation">;</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>min <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> BigInteger bigInteger<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Getter &amp; Setter</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>测试代码</li></ul><p>通过 DataUtil.build(UserAnnotationNumber.class) 生成的对象如下：</p><pre><code>UserAnnotationNumber{aByte=10, aShort=17, integer=19, aLong=11, aDouble=19.888, aFloat=10.067, bigDecimal=18.035, bigInteger=13}</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><strong>正则表达式</strong></h2><p>正则表达式作为一大神器，自然是不能落下。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h2><p>对象的定义如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 正则表达式测试对象 * @author binbin.hou * @date 2019/3/12 * @since 0.0.3 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RegexBean</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>regex <span class="token operator">=</span> <span class="token string">"[0-3]([a-c]|[e-g]{1,2})"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>regex <span class="token operator">=</span> <span class="token string">"[0-9]{1,2}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>regex <span class="token operator">=</span> <span class="token string">"[0-9]{1,2}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> BigDecimal amount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//Getter &amp; Setter</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a><strong>效果</strong></h2><p>生成效果如下：</p><pre><code>RegexBean{name='2c', age=61, amount=39}</code></pre><h2 id="自定义-Data-生成策略"><a href="#自定义-Data-生成策略" class="headerlink" title="自定义 Data 生成策略"></a><strong>自定义 Data 生成策略</strong></h2><p>当然，所有的内置策略只能满足最常见的需求。</p><p>但是无法满足各种特殊的定制化策略，幸运的是我们可以自定义自己的数据填充策略。</p><h2 id="自定义生成策略"><a href="#自定义生成策略" class="headerlink" title="自定义生成策略"></a><strong>自定义生成策略</strong></h2><p>这里我们实现一个最简单的生成策略，如果是字符串，固定为 123。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyStringData</span> <span class="token keyword">implements</span> <span class="token class-name">IData</span><span class="token operator">&lt;</span>String<span class="token operator">></span>  <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">build</span><span class="token punctuation">(</span>IContext context<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>String<span class="token operator">></span> stringClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"123"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h2><p>我们在 @DataFactory 注解中指定自己的策略。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAnnotationData</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@DataFactory</span><span class="token punctuation">(</span>data <span class="token operator">=</span> MyStringData<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样生成的就是我们自己的数据生成策略。</p><h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a><strong>不足之处</strong></h2><p>当然，老马觉得这些特性还是不太方便。</p><p>希望作者可以实现支持全局配置之类的特性，这样会更加方便的。</p><p>各位小伙伴也可以体验一下，让自己早点下班，享受属于自己的时光。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>今天我们和大家一起感受了数据填充工具的便利性，大家工作中有需要就可以用起来。</p><p>为了便于大家学习，所有源码均已开源：</p><p>对象填充：<a href="https://github.com/houbb/data-factory">https://github.com/houbb/data-factory</a></p><p>性能压测：<a href="https://github.com/houbb/junitperf">https://github.com/houbb/junitperf</a></p><p>希望本文对你有所帮助，如果喜欢，欢迎点赞收藏转发一波。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mock </tag>
            
            <tag> data </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-agent</title>
      <link href="2020/12/25/java-agent/"/>
      <url>2020/12/25/java-agent/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>java agent是独立于应用程序外的代理程序，可以在应用程序启动前或运行中，修改类字节码信息，改变类的行为。这里对应用程序启动前和运行中的agent使用分别介绍。</p><h2 id="二、应用程序启动前的agent使用"><a href="#二、应用程序启动前的agent使用" class="headerlink" title="二、应用程序启动前的agent使用"></a>二、应用程序启动前的agent使用</h2><p>应用程序启动前agent使用，是通过在应用程序启动时添加-javaagent参数(可多个-javaagent参数)实现的。</p><h3 id="2-1-javaagent参数格式"><a href="#2-1-javaagent参数格式" class="headerlink" title="2.1 javaagent参数格式"></a>2.1 javaagent参数格式</h3><p>javaagent参数使用格式如下：</p><p>java -javaagent:/xx/agent.jar[=参数] -jar xx.jar</p><h3 id="2-2-开发步骤"><a href="#2-2-开发步骤" class="headerlink" title="2.2 开发步骤"></a>2.2 开发步骤</h3><p>应用程序启动前agent开发，包含agent程序开发、MENIFEST.MF配置文件定义、maven中maven-jar-plugin插件修改、打jar包、主程序调用，具体开发步骤如下：</p><p>定义agent程序，需包含方法名为premain的静态方法，同时实现ClassFileTransformer接口对特定类字节码修改(结合javassist工具)；</p><p>定义MENIFEST.MF配置文件，位于resources/META-INF目录下，内容类似：</p><p>Manifest-Version: 1.0.1</p><p>Premain-Class: com.dragon.study.spring_boot_pre_agent.PreAgentMain</p><p>Can-Redefine-Classes: true</p><p>其中Premain-Class为前面定义的agent类，且配置文件最要空一行。</p><p>修改mava的pom.xml中的插件配置，类似于：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-jar-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>archive</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifest</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>addClasspath</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>addClasspath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifest</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifestEntries</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Premain-Class</span><span class="token punctuation">></span></span>com.dragon.study.spring_boot_pre_agent.PreAgentMain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Premain-Class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifestEntries</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>archive</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将前面定义的agent程序打成jar包；</p><p>在目标主程序上，添加-javaagent参数及前面的agent的jar包，再运行目标主程序，类似于：</p><pre class="line-numbers language-shell"><code class="language-shell">java -javaagent:/xx/agent.jar=agentArgs -cp /xx.jar xx.Main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a>2.3 示例</h3><p>这是以spring_boot_pre_agent项目创建agent的jar包，以spring_boot_main项目中的PreAgentTargetMain为目标类为例。</p><h4 id="2-3-1-agent项目spring-boot-pre-agent"><a href="#2-3-1-agent项目spring-boot-pre-agent" class="headerlink" title="2.3.1 agent项目spring_boot_pre_agent"></a>2.3.1 agent项目spring_boot_pre_agent</h4><h5 id="2-3-1-1-agent项目中的maven依赖"><a href="#2-3-1-1-agent项目中的maven依赖" class="headerlink" title="2.3.1.1 agent项目中的maven依赖"></a>2.3.1.1 agent项目中的maven依赖</h5><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.3.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.dragon.study<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring_boot_pre_agent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>spring_boot_pre_agent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.javassist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javassist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.26.0-GA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-jar-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>archive</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifest</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>addClasspath</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>addClasspath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifest</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifestEntries</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Premain-Class</span><span class="token punctuation">></span></span>com.dragon.study.spring_boot_pre_agent.PreAgentMain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Premain-Class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifestEntries</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>archive</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-1-2-agent项目中的agent相关类"><a href="#2-3-1-2-agent项目中的agent相关类" class="headerlink" title="2.3.1.2 agent项目中的agent相关类"></a>2.3.1.2 agent项目中的agent相关类</h5><p>这里agent相关类包含自定义字节码编辑类ConfigTransformer.java和agent主类PreAgentMain.java,如下： ConfigTransformer.java类如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>dragon<span class="token punctuation">.</span>study<span class="token punctuation">.</span>spring_boot_pre_agent<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>ClassPool<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>CtClass<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>CtMethod<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>ClassFileTransformer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>IllegalClassFormatException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ProtectionDomain<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//修改类的字节码</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigTransformer</span> <span class="token keyword">implements</span> <span class="token class-name">ClassFileTransformer</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> ClassPool classPool <span class="token operator">=</span> ClassPool<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">transform</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">,</span> String className<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> classBeingRedefined<span class="token punctuation">,</span> ProtectionDomain protectionDomain<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classfileBuffer<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalClassFormatException <span class="token punctuation">{</span>String target <span class="token operator">=</span> <span class="token string">"com.dragon.study.spring_boot_main.StaticConfig"</span><span class="token punctuation">;</span>className <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>className<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">try</span> <span class="token punctuation">{</span>CtClass ctClass <span class="token operator">=</span> classPool<span class="token punctuation">.</span><span class="token function">getCtClass</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>CtMethod ctMethod <span class="token operator">=</span> ctClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"sayHello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定方法添加一行自定义输出</span>ctMethod<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span><span class="token string">"System.out.println(\"pre inject, configName:\"+configName);"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回修改后的字节码</span><span class="token keyword">return</span> ctClass<span class="token punctuation">.</span><span class="token function">toBytecode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//返回原类字节码</span><span class="token keyword">return</span> classfileBuffer<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>PreAgentMain类如下：<span class="token keyword">package</span> com<span class="token punctuation">.</span>dragon<span class="token punctuation">.</span>study<span class="token punctuation">.</span>spring_boot_pre_agent<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>Instrumentation<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PreAgentMain</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//主程序运行前执行自定义操作</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span>String agentArgs<span class="token punctuation">,</span> Instrumentation inst<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//这里示例打印传入参数</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"agentArgs:"</span><span class="token operator">+</span>agentArgs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//修改指定类行为</span>inst<span class="token punctuation">.</span><span class="token function">addTransformer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConfigTransformer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-1-3-agent项目中的MENIFEST-MF配置文件"><a href="#2-3-1-3-agent项目中的MENIFEST-MF配置文件" class="headerlink" title="2.3.1.3 agent项目中的MENIFEST.MF配置文件"></a>2.3.1.3 agent项目中的MENIFEST.MF配置文件</h5><p>MENIFEST.MF配置文件位于resources/META-INF目录下，内容为：</p><pre class="line-numbers language-text"><code class="language-text">Manifest-Version: 1.0.1Premain-Class: com.dragon.study.spring_boot_pre_agent.PreAgentMainCan-Redefine-Classes: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="2-3-1-4-agent项目打为jar包"><a href="#2-3-1-4-agent项目打为jar包" class="headerlink" title="2.3.1.4 agent项目打为jar包"></a>2.3.1.4 agent项目打为jar包</h5><p>这里通过maven打jar包为：spring_boot_pre_agent-0.0.1-SNAPSHOT.jar</p><h4 id="2-3-2-agent目标项目spring-boot-main"><a href="#2-3-2-agent目标项目spring-boot-main" class="headerlink" title="2.3.2 agent目标项目spring_boot_main"></a>2.3.2 agent目标项目spring_boot_main</h4><p>spring_boot_main示例包含目标相关类，以及最终添加agent启动。</p><h5 id="2-3-2-1-目标相关类"><a href="#2-3-2-1-目标相关类" class="headerlink" title="2.3.2.1 目标相关类"></a>2.3.2.1 目标相关类</h5><p>目标相关类包含静态配置类StaticConfig.java和目标类PreAgentTargetMain.java如下： StaticConfig.java：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>dragon<span class="token punctuation">.</span>study<span class="token punctuation">.</span>spring_boot_main<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticConfig</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//自定义静态属性</span><span class="token keyword">public</span> <span class="token keyword">static</span> String configName<span class="token operator">=</span><span class="token string">"apple"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//自定义静态方法</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">"hello "</span> <span class="token operator">+</span> configName<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>PreAgentTargetMain<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token keyword">package</span> com<span class="token punctuation">.</span>dragon<span class="token punctuation">.</span>study<span class="token punctuation">.</span>spring_boot_main<span class="token punctuation">.</span>agent<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>dragon<span class="token punctuation">.</span>study<span class="token punctuation">.</span>spring_boot_main<span class="token punctuation">.</span>StaticConfig<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PreAgentTargetMain</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调用指定方法</span>StaticConfig<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-3-测试"><a href="#2-3-3-测试" class="headerlink" title="2.3.3 测试"></a>2.3.3 测试</h4><p>应用程序启动前使用agent，是通过启动时添加-javaagent参数实现的。测试调用如下：</p><pre class="line-numbers language-shell"><code class="language-shell">java -javaagent:/xx/spring_boot_pre_agent-0.0.1-SNAPSHOT.jar=agentArgs -cp /xx/spring_boot_main-0.0.1-SNAPSHOT.jar com.dragon.study.spring_boot_main.agent.PreAgentTargetMain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">agentArgs</span><span class="token punctuation">:</span><span class="token attr-value">agentArgs</span>main<span class="token attr-name">pre</span> <span class="token attr-value">inject, configName:apple</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>总结分析，借助应用程序启动前agent的使用，在PreAgentTargetMain启动前改变了其行为。</p><p>三、应用程序运行中的agent使用</p><p>应用程序运行中的agent使用，是通过第三方程序，借助VirtualMachine将自定义agent添加到目标程序(通过进程号pid)上。</p><h3 id="3-1-开发步骤"><a href="#3-1-开发步骤" class="headerlink" title="3.1 开发步骤"></a>3.1 开发步骤</h3><p>应用程序运行中的agent开发和运行前类似，只是启动方式不同，包含agent程序开发、MENIFEST.MF配置文件定义、maven中maven-jar-plugin插件修改、打jar包、agent使用的目标程序、第三方启动程序，具体开发步骤如下：</p><p>定义agent程序，需包含方法名为agentmain的静态方法，同时实现ClassFileTransformer接口对特定类字节码修改(结合javassist工具)；</p><p>定义MENIFEST.MF配置文件，位于resources/META-INF目录下，内容类似：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">Manifest-Version</span><span class="token punctuation">:</span> <span class="token attr-value">1.0.1</span><span class="token attr-name">Agent-Class</span><span class="token punctuation">:</span> <span class="token attr-value">com.dragon.study.spring_boot_post_agent.PostAgentMain</span><span class="token attr-name">Can-Retransform-Classes</span><span class="token punctuation">:</span> <span class="token attr-value">true</span><span class="token attr-name">Can-Redefine-Classes</span><span class="token punctuation">:</span> <span class="token attr-value">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中Agent-Class为前面定义的agent类，且配置文件最要空一行。</p><p>修改mava的pom.xml中的插件配置，类似于：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-jar-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>archive</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifest</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>addClasspath</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>addClasspath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifest</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifestEntries</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Agent-Class</span><span class="token punctuation">></span></span>com.dragon.study.spring_boot_post_agent.PostAgentMain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Agent-Class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Can-Redefine-Classes</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Can-Redefine-Classes</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Can-Retransform-Classes</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Can-Retransform-Classes</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifestEntries</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>archive</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将前面定义的agent程序打成jar包；</p><p>通过第三方程序将agent程序添加到目标程序上，类似：</p><p>//获取指定项目运行的pid</p><p>String targetPid = “xx”</p><p>//运行期，对指定pid程序添加agent,动态改变程序行为</p><p>VirtualMachine vm = VirtualMachine.attach(targetPid);</p><p>//添加指定agent的jar包</p><p>vm.loadAgent(“/xx/agent.jar”);</p><p>vm.detach();</p><h3 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h3><p>这是以spring_boot_post_agent项目创建agent的jar包，以spring_boot_main项目为目标项目，以PostAgentTargetMain.java为第三方添加程序为例。</p><h4 id="3-2-1-agent项目spring-boot-post-agent"><a href="#3-2-1-agent项目spring-boot-post-agent" class="headerlink" title="3.2.1 agent项目spring_boot_post_agent"></a>3.2.1 agent项目spring_boot_post_agent</h4><h5 id="3-2-1-1-agent项目中的maven依赖"><a href="#3-2-1-1-agent项目中的maven依赖" class="headerlink" title="3.2.1.1 agent项目中的maven依赖"></a>3.2.1.1 agent项目中的maven依赖</h5><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.3.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.dragon.study<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring_boot_post_agent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>spring_boot_post_agent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.javassist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javassist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.26.0-GA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-jar-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>archive</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifest</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>addClasspath</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>addClasspath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifest</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>manifestEntries</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Agent-Class</span><span class="token punctuation">></span></span>com.dragon.study.spring_boot_post_agent.PostAgentMain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Agent-Class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Can-Redefine-Classes</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Can-Redefine-Classes</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Can-Retransform-Classes</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Can-Retransform-Classes</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>manifestEntries</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>archive</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.2.1.2 agent项目中的agent相关类</p><p>这里agent相关类包含自定义字节码编辑类ConfigTransformer.java和agent主类PreAgentMain.java,如下： ConfigTransformer.java类如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>dragon<span class="token punctuation">.</span>study<span class="token punctuation">.</span>spring_boot_post_agent<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>ClassPool<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>CtClass<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>CtMethod<span class="token punctuation">;</span><span class="token keyword">import</span> javassist<span class="token punctuation">.</span>Loader<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>ClassFileTransformer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>IllegalClassFormatException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>security<span class="token punctuation">.</span>ProtectionDomain<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigTransformer</span> <span class="token keyword">implements</span> <span class="token class-name">ClassFileTransformer</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> ClassPool classPool <span class="token operator">=</span> ClassPool<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">transform</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">,</span> String className<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> classBeingRedefined<span class="token punctuation">,</span> ProtectionDomain protectionDomain<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classfileBuffer<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalClassFormatException <span class="token punctuation">{</span>String target <span class="token operator">=</span> <span class="token string">"com.dragon.study.spring_boot_main.StaticConfig"</span><span class="token punctuation">;</span>className <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>className<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">try</span> <span class="token punctuation">{</span>CtClass ctClass <span class="token operator">=</span> classPool<span class="token punctuation">.</span><span class="token function">getCtClass</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>CtMethod ctMethod <span class="token operator">=</span> ctClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"sayHello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定方法添加一行自定义输出</span>ctMethod<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span><span class="token string">"System.out.println(\"post inject, configName:\"+configName);"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回修改后的字节码</span><span class="token keyword">return</span> ctClass<span class="token punctuation">.</span><span class="token function">toBytecode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//返回原类字节码</span><span class="token keyword">return</span> classfileBuffer<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>PostAgentMain类如下：<span class="token keyword">package</span> com<span class="token punctuation">.</span>dragon<span class="token punctuation">.</span>study<span class="token punctuation">.</span>spring_boot_post_agent<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>Instrumentation<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span>UnmodifiableClassException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>Stream<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PostAgentMain</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">agentmain</span><span class="token punctuation">(</span>String agentArgs<span class="token punctuation">,</span> Instrumentation inst<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//这里示例打印传入参数</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"agentArgs:"</span> <span class="token operator">+</span> agentArgs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//打印加载的所有类</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> clazzArr <span class="token operator">=</span> inst<span class="token punctuation">.</span><span class="token function">getAllLoadedClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Stream.of(clazzArr).forEach(System.out::println);</span><span class="token comment" spellcheck="true">//打印目标项目中指定字段的内存值</span>Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>clazzArr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>t<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"StaticConfig"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">try</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"configName:"</span><span class="token operator">+</span>t<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"configName"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//修改目标项目中指定字段的内存值</span>Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>clazzArr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>t<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"StaticConfig"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">try</span> <span class="token punctuation">{</span>t<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"configName"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"banana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//运行期修改指定类行为</span>Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>clazzArr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>t<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"StaticConfig"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">try</span> <span class="token punctuation">{</span>inst<span class="token punctuation">.</span><span class="token function">addTransformer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConfigTransformer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>inst<span class="token punctuation">.</span><span class="token function">retransformClasses</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnmodifiableClassException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-2-1-3-agent项目中的MENIFEST-MF配置文件"><a href="#3-2-1-3-agent项目中的MENIFEST-MF配置文件" class="headerlink" title="3.2.1.3 agent项目中的MENIFEST.MF配置文件"></a>3.2.1.3 agent项目中的MENIFEST.MF配置文件</h5><p>MENIFEST.MF配置文件位于resources/META-INF目录下，内容为：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">Manifest-Version</span><span class="token punctuation">:</span> <span class="token attr-value">1.0.1</span><span class="token attr-name">Agent-Class</span><span class="token punctuation">:</span> <span class="token attr-value">com.dragon.study.spring_boot_post_agent.PostAgentMain</span><span class="token attr-name">Can-Retransform-Classes</span><span class="token punctuation">:</span> <span class="token attr-value">true</span><span class="token attr-name">Can-Redefine-Classes</span><span class="token punctuation">:</span> <span class="token attr-value">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-2-1-4-agent项目打为jar包"><a href="#3-2-1-4-agent项目打为jar包" class="headerlink" title="3.2.1.4 agent项目打为jar包"></a>3.2.1.4 agent项目打为jar包</h5><p>这里通过maven打jar包为：spring_boot_post_agent-0.0.1-SNAPSHOT.jar</p><h4 id="3-2-2-agent目标项目spring-boot-main"><a href="#3-2-2-agent目标项目spring-boot-main" class="headerlink" title="3.2.2 agent目标项目spring_boot_main"></a>3.2.2 agent目标项目spring_boot_main</h4><p>spring_boot_main为完整常规项目。</p><h5 id="3-2-2-1-添加maven依赖"><a href="#3-2-2-1-添加maven依赖" class="headerlink" title="3.2.2.1 添加maven依赖"></a>3.2.2.1 添加maven依赖</h5><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span><span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.3.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.dragon.study<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring_boot_main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>spring_boot_main<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.62<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.javassist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javassist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.26.0-GA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.2.2.2 application.yaml配置</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span><span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10013</span><span class="token key atrule">spring</span><span class="token punctuation">:</span><span class="token key atrule">application</span><span class="token punctuation">:</span><span class="token key atrule">name</span><span class="token punctuation">:</span> spring<span class="token punctuation">-</span>boot<span class="token punctuation">-</span>main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-2-2-3-关键类"><a href="#3-2-2-3-关键类" class="headerlink" title="3.2.2.3 关键类"></a>3.2.2.3 关键类</h5><p>目标相关类包含静态配置类StaticConfig.java和启动类： StaticConfig.java：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>dragon<span class="token punctuation">.</span>study<span class="token punctuation">.</span>spring_boot_main<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticConfig</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//自定义静态属性</span><span class="token keyword">public</span> <span class="token keyword">static</span> String configName<span class="token operator">=</span><span class="token string">"apple"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//自定义静态方法</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">"hello "</span> <span class="token operator">+</span> configName<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动类SpringBootMainApplication.java:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>dragon<span class="token punctuation">.</span>study<span class="token punctuation">.</span>spring_boot_main<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringBootMainApplication</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringBootMainApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//主动加载静态类</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.dragon.study.spring_boot_main.StaticConfig"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-3-第三方添加类"><a href="#3-3-3-第三方添加类" class="headerlink" title="3.3.3 第三方添加类"></a>3.3.3 第三方添加类</h4><p>第三方添加类是通过VirtualMachine将agent和目标项目关联起来，示例PostAgentTargetMain如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>dragon<span class="token punctuation">.</span>study<span class="token punctuation">.</span>spring_boot_main<span class="token punctuation">.</span>agent<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>attach<span class="token punctuation">.</span>VirtualMachine<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>attach<span class="token punctuation">.</span>VirtualMachineDescriptor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PostAgentTargetMain</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>List<span class="token operator">&lt;</span>VirtualMachineDescriptor<span class="token operator">></span> vmList <span class="token operator">=</span> VirtualMachine<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取指定项目运行的pid</span>String targetPid <span class="token operator">=</span> vmList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>t<span class="token punctuation">.</span><span class="token function">displayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">"com.dragon.study.spring_boot_main.SpringBootMainApplication"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>t<span class="token operator">-</span><span class="token operator">></span>t<span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//运行期，对指定pid程序添加agent,动态改变程序行为</span>VirtualMachine vm <span class="token operator">=</span> VirtualMachine<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>targetPid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加指定agent的jar包</span>vm<span class="token punctuation">.</span><span class="token function">loadAgent</span><span class="token punctuation">(</span><span class="token string">"/xx/spring_boot_post_agent-0.0.1-SNAPSHOT.jar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>vm<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-4-测试"><a href="#3-3-4-测试" class="headerlink" title="3.3.4 测试"></a>3.3.4 测试</h4><p>启动spring_boot_main项目，运行第三方添加类PostAgentTargetMain。</p><pre class="line-numbers language-shell"><code class="language-shell">java -javaagent:/xx/spring_boot_pre_agent-0.0.1-SNAPSHOT.jar=agentArgs -cp /xx/spring_boot_main-0.0.1-SNAPSHOT.jar com.dragon.study.spring_boot_main.agent.PreAgentTargetMain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>spring_boot_main输出：</p><p>agentArgs:null</p><p>configName:apple</p><p>再次通过http查看：</p><p>GET <a href="http://localhost:10013/hello/sayHello">http://localhost:10013/hello/sayHello</a></p><p>Accept: application/json</p><p>http结果输出：</p><p>hello banana</p><p>同时spring_boot_main输出：</p><p>post inject, configName:banana</p><p>分析总结： 分析前面测试结果，可以发现，借助运行期agent的使用，实现了动态获取、修改、新增运行期StaticConfig.java(spring_boot_main项目）类的值和行为。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> agent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的加密算法</title>
      <link href="2020/12/17/encryption-algorithm/"/>
      <url>2020/12/17/encryption-algorithm/</url>
      
        <content type="html"><![CDATA[<p>加密算法我们整体可以分为：可逆加密和不可逆加密，可逆加密又可以分为：对称加密和非对称加密。</p><h2 id="一、不可逆加密"><a href="#一、不可逆加密" class="headerlink" title="一、不可逆加密"></a>一、不可逆加密</h2><p>常见的不可逆加密算法有<code>MD5</code>，<code>HMAC</code>，<code>SHA1</code>、<code>SHA-224</code>、<code>SHA-256</code>、<code>SHA-384</code>，和<code>SHA-512</code>，其中<code>SHA-224</code>、<code>SHA-256</code>、<code>SHA-384</code>，和<code>SHA-512</code>我们可以统称为<code>SHA2</code>加密算法，<code>SHA</code>加密算法的安全性要比<code>MD5</code>更高，而<code>SHA2</code>加密算法比<code>SHA1</code>的要高。其中<code>SHA</code>后面的数字表示的是加密后的字符串长度，<code>SHA1</code>默认会产生一个<code>160</code>位的信息摘要。</p><p>不可逆加密算法最大的特点就是密钥，但是<code>HMAC</code>是需要密钥的【手动狗头】。</p><p>由于这些加密都是不可逆的，因此比较常用的场景就是用户密码加密，其验证过程就是通过比较两个加密后的字符串是否一样来确认身份的。网上也有很多自称是可以破解<code>MD5</code>密码的网站，其原理也是一样，就是有一个巨大的资源库，存放了许多字符串及对应的<code>MD5</code>加密后的字符串，通过你输入的<code>MD5</code>加密串来进行比较，如果过你的密码复杂度比较低，还是有很大机率验证出来的。</p><h3 id="1-1-MD5"><a href="#1-1-MD5" class="headerlink" title="1.1 MD5"></a>1.1 MD5</h3><blockquote><p><strong>MD5信息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。</p></blockquote><p><code>MD5</code>算法有以下特点：</p><p>1、压缩性：无论数据长度是多少，计算出来的<code>MD5</code>值长度相同</p><p>2、容易计算性：由原数据容易计算出<code>MD5</code>值</p><p>3、抗修改性：即便修改一个字节，计算出来的<code>MD5</code>值也会巨大差异</p><p>4、抗碰撞性：知道数据和<code>MD5</code>值，很小概率找到相同<code>MD5</code>值相同的原数据。</p><pre class="line-numbers language-java"><code class="language-java"> 1public <span class="token keyword">static</span> String <span class="token function">md5</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">2</span>    MessageDigest messageDigest <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token number">3</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token number">4</span>        messageDigest <span class="token operator">=</span> MessageDigest<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"MD5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">5</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchAlgorithmException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">6</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">7</span>    <span class="token punctuation">}</span> <span class="token number">8</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> messageDigest<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">9</span>    <span class="token keyword">return</span> Hex<span class="token punctuation">.</span><span class="token function">encodeHexString</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">10</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-SHA系列"><a href="#1-2-SHA系列" class="headerlink" title="1.2 SHA系列"></a>1.2 SHA系列</h3><blockquote><p><strong>安全散列算法</strong>（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，是FIPS所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的机率很高。</p><p>2005年8月17日的CRYPTO会议尾声中王小云、姚期智、姚储枫再度发表更有效率的SHA-1攻击法，能在2的63次方个计算复杂度内找到碰撞。</p></blockquote><p>也就是说<code>SHA-1</code>加密算法有碰撞的可能性，虽然很小。</p><pre class="line-numbers language-java"><code class="language-java"> 1public <span class="token keyword">static</span> String <span class="token function">sha256</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">2</span>    MessageDigest messageDigest <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token number">3</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token number">4</span>        messageDigest <span class="token operator">=</span> MessageDigest<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"SHA-256"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">5</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchAlgorithmException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">6</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">7</span>    <span class="token punctuation">}</span> <span class="token number">8</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> messageDigest<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token number">9</span>    <span class="token keyword">return</span> Hex<span class="token punctuation">.</span><span class="token function">encodeHexString</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">10</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-HMAC系列"><a href="#1-3-HMAC系列" class="headerlink" title="1.3 HMAC系列"></a>1.3 HMAC系列</h3><blockquote><p>HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication  Code）的缩写，由H.Krawezyk，M.Bellare，R.Canetti于1996年提出的一种基于Hash函数和密钥进行消息认证的方法，并于1997年作为RFC2104被公布，并在IPSec和其他网络协议（如SSL）中得以广泛应用，现在已经成为事实上的Internet安全标准。它可以与任何迭代散列函数捆绑使用。</p><p>HMAC算法更像是一种加密算法，它引入了密钥，其安全性已经不完全依赖于所使用的Hash算法</p></blockquote><pre class="line-numbers language-java"><code class="language-java"> 1public <span class="token keyword">static</span> String <span class="token function">hmacSha256</span><span class="token punctuation">(</span>String text<span class="token punctuation">,</span> SecretKeySpec sk<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">2</span>    Mac mac <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token number">3</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token number">4</span>        mac <span class="token operator">=</span> Mac<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"HmacSHA256"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">5</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchAlgorithmException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">6</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">7</span>    <span class="token punctuation">}</span> <span class="token number">8</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token number">9</span>        mac<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">10</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvalidKeyException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">11</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">12</span>    <span class="token punctuation">}</span><span class="token number">13</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> rawHmac <span class="token operator">=</span> mac<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">14</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>Base64<span class="token punctuation">.</span><span class="token function">encodeBase64</span><span class="token punctuation">(</span>rawHmac<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">15</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要使用不可逆加密，推荐使用SHA256、SHA384、SHA512以及HMAC-SHA256、HMAC-SHA384、HMAC-SHA512这几种算法。</p><h2 id="二、对称加密算法"><a href="#二、对称加密算法" class="headerlink" title="二、对称加密算法"></a>二、对称加密算法</h2><p>对称加密算法是应用比较早的算法，在数据加密和解密的时用的都是同一个密钥，这就造成了密钥管理困难的问题。常见的对称加密算法有<code>DES</code>、<code>3DES</code>、<code>AES128</code>、<code>AES192</code>、<code>AES256</code>(默认安装的<code>JDK</code>尚不支持<code>AES256</code>，需要安装对应的<code>jce</code>补丁进行升级<code>jce1.7</code>，<code>jce1.8</code>)。其中<code>AES</code>后面的数字代表的是密钥长度。对称加密算法的安全性相对较低，比较适用的场景就是内网环境中的加解密。</p><h3 id="2-1-DES"><a href="#2-1-DES" class="headerlink" title="2.1 DES"></a>2.1 DES</h3><p><code>DES</code>是对称加密算法领域中的典型算法，其密钥默认长度为<code>56</code>位。</p><pre class="line-numbers language-java"><code class="language-java"> <span class="token number">1</span>  <span class="token comment" spellcheck="true">// 加密</span> <span class="token number">2</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dataSource<span class="token punctuation">,</span> String password<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token number">3</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token number">4</span>         SecureRandom random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecureRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">5</span>         DESKeySpec desKeySpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DESKeySpec</span><span class="token punctuation">(</span>password<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">6</span>         <span class="token comment" spellcheck="true">//创建一个密匙工厂，然后用它把DESKeySpec转换成 </span> <span class="token number">7</span>         SecretKeyFactory secretKeyFactory <span class="token operator">=</span> SecretKeyFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"DES"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token number">8</span>         SecretKey secretKey <span class="token operator">=</span> secretKeyFactory<span class="token punctuation">.</span><span class="token function">generateSecret</span><span class="token punctuation">(</span>desKeySpec<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token number">9</span>         <span class="token comment" spellcheck="true">//Cipher对象实际完成加密操作 </span><span class="token number">10</span>         Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"DES"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">11</span>         <span class="token comment" spellcheck="true">//用密匙初始化Cipher对象 </span><span class="token number">12</span>         cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>Cipher<span class="token punctuation">.</span>ENCRYPT_MODE<span class="token punctuation">,</span> secretKey<span class="token punctuation">,</span> random<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">13</span>         <span class="token comment" spellcheck="true">//正式执行加密操作 </span><span class="token number">14</span>         <span class="token keyword">return</span> Base64<span class="token punctuation">.</span><span class="token function">encodeBase64String</span><span class="token punctuation">(</span>cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">15</span>     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">16</span>         e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">17</span>     <span class="token punctuation">}</span> <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token number">18</span> <span class="token punctuation">}</span> <span class="token number">19</span>  <span class="token comment" spellcheck="true">// 解密</span><span class="token number">20</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">decrypt</span><span class="token punctuation">(</span>String src<span class="token punctuation">,</span> String password<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span> <span class="token number">21</span>    <span class="token comment" spellcheck="true">// DES算法要求有一个可信任的随机数源 </span><span class="token number">22</span>    SecureRandom random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecureRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">23</span>    <span class="token comment" spellcheck="true">// 创建一个DESKeySpec对象 </span><span class="token number">24</span>    DESKeySpec desKeySpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DESKeySpec</span><span class="token punctuation">(</span>password<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">25</span>    <span class="token comment" spellcheck="true">// 创建一个密匙工厂 </span><span class="token number">26</span>    SecretKeyFactory keyFactory <span class="token operator">=</span> SecretKeyFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"DES"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">27</span>    <span class="token comment" spellcheck="true">// 将DESKeySpec对象转换成SecretKey对象 </span><span class="token number">28</span>    SecretKey secretKey <span class="token operator">=</span> keyFactory<span class="token punctuation">.</span><span class="token function">generateSecret</span><span class="token punctuation">(</span>desKeySpec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">29</span>    <span class="token comment" spellcheck="true">// Cipher对象实际完成解密操作 </span><span class="token number">30</span>    Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"DES"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">31</span>    <span class="token comment" spellcheck="true">// 用密匙初始化Cipher对象 </span><span class="token number">32</span>    cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>Cipher<span class="token punctuation">.</span>DECRYPT_MODE<span class="token punctuation">,</span> secretKey<span class="token punctuation">,</span> random<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">33</span>    <span class="token comment" spellcheck="true">// 真正开始解密操作 </span><span class="token number">34</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>Base64<span class="token punctuation">.</span><span class="token function">decodeBase64</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">35</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-3DES"><a href="#2-2-3DES" class="headerlink" title="2.2 3DES"></a>2.2 3DES</h3><p><code>3DES</code>（即Triple DES）是<code>DES</code>向<code>AES</code>过渡的加密算法，它使用3条56位的密钥对数据进行三次加密。是<code>DES</code>的一个更安全的变形。它以<code>DES</code>为基本模块，通过组合分组方法设计出分组加密算法。比起最初的<code>DES</code>，<code>3DES</code>更为安全。密钥长度默认为<code>168</code>位，还可以选择<code>128</code>位。</p><pre class="line-numbers language-java"><code class="language-java"> 1public <span class="token keyword">static</span> String <span class="token function">encryptThreeDESECB</span><span class="token punctuation">(</span>String src<span class="token punctuation">,</span> String key<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">2</span>    <span class="token keyword">try</span><span class="token punctuation">{</span> <span class="token number">3</span>        DESedeKeySpec dks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DESedeKeySpec</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">4</span>        SecretKeyFactory keyFactory <span class="token operator">=</span> SecretKeyFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"DESede"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">5</span>        SecretKey securekey <span class="token operator">=</span> keyFactory<span class="token punctuation">.</span><span class="token function">generateSecret</span><span class="token punctuation">(</span>dks<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">6</span> <span class="token number">7</span>        Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"DESede/ECB/PKCS5Padding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">8</span>        cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>Cipher<span class="token punctuation">.</span>ENCRYPT_MODE<span class="token punctuation">,</span> securekey<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">9</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">10</span><span class="token number">11</span>        String ss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>Base64<span class="token punctuation">.</span><span class="token function">encodeBase64</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">12</span>        ss <span class="token operator">=</span> ss<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"\\+"</span><span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">13</span>        ss <span class="token operator">=</span> ss<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">14</span>        <span class="token keyword">return</span> ss<span class="token punctuation">;</span><span class="token number">15</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">16</span>        ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">17</span>        <span class="token keyword">return</span> src<span class="token punctuation">;</span><span class="token number">18</span>    <span class="token punctuation">}</span><span class="token number">19</span><span class="token punctuation">}</span><span class="token number">20</span>21public <span class="token keyword">static</span> String <span class="token function">decryptThreeDESECB</span><span class="token punctuation">(</span>String src<span class="token punctuation">,</span> String key<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">22</span>    <span class="token keyword">try</span><span class="token punctuation">{</span><span class="token number">23</span>        src <span class="token operator">=</span> src<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">24</span>        src <span class="token operator">=</span> src<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">25</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytesrc <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">decodeBase64</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">26</span>        <span class="token comment" spellcheck="true">// --解密的key</span><span class="token number">27</span>        DESedeKeySpec dks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DESedeKeySpec</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">28</span>        SecretKeyFactory keyFactory <span class="token operator">=</span> SecretKeyFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"DESede"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">29</span>        SecretKey securekey <span class="token operator">=</span> keyFactory<span class="token punctuation">.</span><span class="token function">generateSecret</span><span class="token punctuation">(</span>dks<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">30</span><span class="token number">31</span>        <span class="token comment" spellcheck="true">// --Chipher对象解密</span><span class="token number">32</span>        Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"DESede/ECB/PKCS5Padding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">33</span>        cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>Cipher<span class="token punctuation">.</span>DECRYPT_MODE<span class="token punctuation">,</span> securekey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">34</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> retByte <span class="token operator">=</span> cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>bytesrc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">35</span><span class="token number">36</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>retByte<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">37</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token number">38</span>        ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">39</span>        <span class="token keyword">return</span> src<span class="token punctuation">;</span><span class="token number">40</span>    <span class="token punctuation">}</span><span class="token number">41</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-AES"><a href="#2-3-AES" class="headerlink" title="2.3 AES"></a>2.3 AES</h3><p><code>AES</code>高级数据加密标准，能够有效抵御已知的针对<code>DES</code>算法的所有攻击，默认密钥长度为<code>128</code>位，还可以供选择<code>192</code>位，<code>256</code>位。这里顺便提一句这个位指的是bit。</p><pre class="line-numbers language-java"><code class="language-java"> 1private <span class="token keyword">static</span> <span class="token keyword">final</span> String defaultCharset <span class="token operator">=</span> <span class="token string">"UTF-8"</span><span class="token punctuation">;</span> 2private <span class="token keyword">static</span> <span class="token keyword">final</span> String KEY_AES <span class="token operator">=</span> <span class="token string">"AES"</span><span class="token punctuation">;</span> 3private <span class="token keyword">static</span> <span class="token keyword">final</span> String KEY_MD5 <span class="token operator">=</span> <span class="token string">"MD5"</span><span class="token punctuation">;</span> 4private <span class="token keyword">static</span> MessageDigest md5Digest<span class="token punctuation">;</span> 5static <span class="token punctuation">{</span> <span class="token number">6</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token number">7</span>        md5Digest <span class="token operator">=</span> MessageDigest<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>KEY_MD5<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">8</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchAlgorithmException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">9</span><span class="token number">10</span>    <span class="token punctuation">}</span><span class="token number">11</span><span class="token punctuation">}</span><span class="token number">12</span><span class="token comment" spellcheck="true">/**13  * 加密14  */</span>15public <span class="token keyword">static</span> String <span class="token function">encrypt</span><span class="token punctuation">(</span>String data<span class="token punctuation">,</span> String key<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">16</span>    <span class="token keyword">return</span> <span class="token function">doAES</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> Cipher<span class="token punctuation">.</span>ENCRYPT_MODE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">17</span><span class="token punctuation">}</span><span class="token number">18</span><span class="token comment" spellcheck="true">/**19  * 解密20  */</span>21public <span class="token keyword">static</span> String <span class="token function">decrypt</span><span class="token punctuation">(</span>String data<span class="token punctuation">,</span> String key<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">22</span>    <span class="token keyword">return</span> <span class="token function">doAES</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> Cipher<span class="token punctuation">.</span>DECRYPT_MODE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">23</span><span class="token punctuation">}</span><span class="token number">24</span><span class="token number">25</span><span class="token number">26</span><span class="token comment" spellcheck="true">/**27  * 加解密28  */</span>29private <span class="token keyword">static</span> String <span class="token function">doAES</span><span class="token punctuation">(</span>String data<span class="token punctuation">,</span> String key<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">30</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token number">31</span>        <span class="token keyword">boolean</span> encrypt <span class="token operator">=</span> mode <span class="token operator">==</span> Cipher<span class="token punctuation">.</span>ENCRYPT_MODE<span class="token punctuation">;</span><span class="token number">32</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> content<span class="token punctuation">;</span><span class="token number">33</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>encrypt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">34</span>            content <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>defaultCharset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">35</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">36</span>            content <span class="token operator">=</span> Base64<span class="token punctuation">.</span><span class="token function">decodeBase64</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">37</span>        <span class="token punctuation">}</span><span class="token number">38</span>        SecretKeySpec keySpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecretKeySpec</span><span class="token punctuation">(</span>md5Digest<span class="token punctuation">.</span><span class="token function">digest</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>defaultCharset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">39</span>                                                  <span class="token punctuation">,</span> KEY_AES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">40</span>        Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>KEY_AES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建密码器</span><span class="token number">41</span>        cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>mode<span class="token punctuation">,</span> keySpec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化</span><span class="token number">42</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">43</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>encrypt<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">44</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>Base64<span class="token punctuation">.</span><span class="token function">encodeBase64</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">45</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token number">46</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> defaultCharset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">47</span>        <span class="token punctuation">}</span><span class="token number">48</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">49</span>    <span class="token punctuation">}</span><span class="token number">50</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token number">51</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>推荐使用对称加密算法有：<code>AES128</code>、<code>AES192</code>、<code>AES256</code>。</p><h2 id="三、非对称加密算法"><a href="#三、非对称加密算法" class="headerlink" title="三、非对称加密算法"></a>三、非对称加密算法</h2><p>非对称加密算法有两个密钥，这两个密钥完全不同但又完全匹配。只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。常见的非对称加密有<code>RSA</code>、<code>SM2</code>等。</p><h3 id="3-1-RSA"><a href="#3-1-RSA" class="headerlink" title="3.1 RSA"></a>3.1 RSA</h3><p><code>RSA</code>密钥至少为500位长，一般推荐使用1024位。</p><pre class="line-numbers language-java"><code class="language-java">  <span class="token number">1</span><span class="token comment" spellcheck="true">//非对称密钥算法</span>  2public <span class="token keyword">static</span> <span class="token keyword">final</span> String KEY_ALGORITHM <span class="token operator">=</span> <span class="token string">"RSA"</span><span class="token punctuation">;</span>  <span class="token number">3</span>  <span class="token number">4</span><span class="token comment" spellcheck="true">/**  5  * 密钥长度，DH算法的默认密钥长度是1024  6  * 密钥长度必须是64的倍数，在512到65536位之间  7  */</span>  8private <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> KEY_SIZE <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>  <span class="token number">9</span><span class="token comment" spellcheck="true">//公钥</span> 10private <span class="token keyword">static</span> <span class="token keyword">final</span> String PUBLIC_KEY <span class="token operator">=</span> <span class="token string">"RSAPublicKey"</span><span class="token punctuation">;</span> <span class="token number">11</span><span class="token comment" spellcheck="true">//私钥</span> 12private <span class="token keyword">static</span> <span class="token keyword">final</span> String PRIVATE_KEY <span class="token operator">=</span> <span class="token string">"RSAPrivateKey"</span><span class="token punctuation">;</span> <span class="token number">13</span><span class="token comment" spellcheck="true">/** 14  * 初始化密钥对 15  * 16  * @return Map 甲方密钥的Map 17  */</span> 18public <span class="token keyword">static</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">initKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> <span class="token number">19</span>    <span class="token comment" spellcheck="true">//实例化密钥生成器</span> <span class="token number">20</span>    KeyPairGenerator keyPairGenerator <span class="token operator">=</span> KeyPairGenerator<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>KEY_ALGORITHM<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">21</span>    <span class="token comment" spellcheck="true">//初始化密钥生成器</span> <span class="token number">22</span>    keyPairGenerator<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span>KEY_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">23</span>    <span class="token comment" spellcheck="true">//生成密钥对</span> <span class="token number">24</span>    KeyPair keyPair <span class="token operator">=</span> keyPairGenerator<span class="token punctuation">.</span><span class="token function">generateKeyPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">25</span>    <span class="token comment" spellcheck="true">//甲方公钥</span> <span class="token number">26</span>    RSAPublicKey publicKey <span class="token operator">=</span> <span class="token punctuation">(</span>RSAPublicKey<span class="token punctuation">)</span> keyPair<span class="token punctuation">.</span><span class="token function">getPublic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">27</span>    <span class="token comment" spellcheck="true">//甲方私钥</span> <span class="token number">28</span>    RSAPrivateKey privateKey <span class="token operator">=</span> <span class="token punctuation">(</span>RSAPrivateKey<span class="token punctuation">)</span> keyPair<span class="token punctuation">.</span><span class="token function">getPrivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">29</span>    <span class="token comment" spellcheck="true">//将密钥存储在map中</span> <span class="token number">30</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> keyMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">31</span>    keyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>PUBLIC_KEY<span class="token punctuation">,</span> publicKey<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">32</span>    keyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>PRIVATE_KEY<span class="token punctuation">,</span> privateKey<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">33</span>    <span class="token keyword">return</span> keyMap<span class="token punctuation">;</span> <span class="token number">34</span><span class="token punctuation">}</span> <span class="token number">35</span><span class="token comment" spellcheck="true">/** 36  * 私钥加密 37  * 38  * @param data 待加密数据 39  * @param key  密钥 40  * @return byte[] 加密数据 41  */</span> 42public <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">encryptByPrivateKey</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> key<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> <span class="token number">43</span> <span class="token number">44</span>    <span class="token comment" spellcheck="true">//取得私钥</span> <span class="token number">45</span>    PKCS8EncodedKeySpec pkcs8KeySpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PKCS8EncodedKeySpec</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">46</span>    KeyFactory keyFactory <span class="token operator">=</span> KeyFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>KEY_ALGORITHM<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">47</span>    <span class="token comment" spellcheck="true">//生成私钥</span> <span class="token number">48</span>    PrivateKey privateKey <span class="token operator">=</span> keyFactory<span class="token punctuation">.</span><span class="token function">generatePrivate</span><span class="token punctuation">(</span>pkcs8KeySpec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">49</span>    <span class="token comment" spellcheck="true">//数据加密</span> <span class="token number">50</span>    Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>keyFactory<span class="token punctuation">.</span><span class="token function">getAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">51</span>    cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>Cipher<span class="token punctuation">.</span>ENCRYPT_MODE<span class="token punctuation">,</span> privateKey<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">52</span>    <span class="token keyword">return</span> cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">53</span><span class="token punctuation">}</span> <span class="token number">54</span> <span class="token number">55</span><span class="token comment" spellcheck="true">/** 56  * 公钥加密 57  * 58  * @param data 待加密数据 59  * @param key  密钥 60  * @return byte[] 加密数据 61  */</span> 62public <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">encryptByPublicKey</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> key<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> <span class="token number">63</span> <span class="token number">64</span>    <span class="token comment" spellcheck="true">//实例化密钥工厂</span> <span class="token number">65</span>    KeyFactory keyFactory <span class="token operator">=</span> KeyFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>KEY_ALGORITHM<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">66</span>    <span class="token comment" spellcheck="true">//初始化公钥</span> <span class="token number">67</span>    <span class="token comment" spellcheck="true">//密钥材料转换</span> <span class="token number">68</span>    X509EncodedKeySpec x509KeySpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">X509EncodedKeySpec</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">69</span>    <span class="token comment" spellcheck="true">//产生公钥</span> <span class="token number">70</span>    PublicKey pubKey <span class="token operator">=</span> keyFactory<span class="token punctuation">.</span><span class="token function">generatePublic</span><span class="token punctuation">(</span>x509KeySpec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">71</span>    <span class="token comment" spellcheck="true">//数据加密</span> <span class="token number">72</span>    Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>keyFactory<span class="token punctuation">.</span><span class="token function">getAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">73</span>    cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>Cipher<span class="token punctuation">.</span>ENCRYPT_MODE<span class="token punctuation">,</span> pubKey<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">74</span>    <span class="token keyword">return</span> cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">75</span><span class="token punctuation">}</span> <span class="token number">76</span> <span class="token number">77</span><span class="token comment" spellcheck="true">/** 78  * 私钥解密 79  * 80  * @param data 待解密数据 81  * @param key  密钥 82  * @return byte[] 解密数据 83  */</span> 84public <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">decryptByPrivateKey</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> key<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> <span class="token number">85</span>    <span class="token comment" spellcheck="true">//取得私钥</span> <span class="token number">86</span>    PKCS8EncodedKeySpec pkcs8KeySpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PKCS8EncodedKeySpec</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">87</span>    KeyFactory keyFactory <span class="token operator">=</span> KeyFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>KEY_ALGORITHM<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">88</span>    <span class="token comment" spellcheck="true">//生成私钥</span> <span class="token number">89</span>    PrivateKey privateKey <span class="token operator">=</span> keyFactory<span class="token punctuation">.</span><span class="token function">generatePrivate</span><span class="token punctuation">(</span>pkcs8KeySpec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">90</span>    <span class="token comment" spellcheck="true">//数据解密</span> <span class="token number">91</span>    Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>keyFactory<span class="token punctuation">.</span><span class="token function">getAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">92</span>    cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>Cipher<span class="token punctuation">.</span>DECRYPT_MODE<span class="token punctuation">,</span> privateKey<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">93</span>    <span class="token keyword">return</span> cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">94</span><span class="token punctuation">}</span> <span class="token number">95</span> <span class="token number">96</span><span class="token comment" spellcheck="true">/** 97  * 公钥解密 98  * 99  * @param data 待解密数据100  * @param key  密钥101  * @return byte[] 解密数据102  */</span>103public <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">decryptByPublicKey</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> key<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span><span class="token number">104</span><span class="token number">105</span>    <span class="token comment" spellcheck="true">//实例化密钥工厂</span><span class="token number">106</span>    KeyFactory keyFactory <span class="token operator">=</span> KeyFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>KEY_ALGORITHM<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">107</span>    <span class="token comment" spellcheck="true">//初始化公钥</span><span class="token number">108</span>    <span class="token comment" spellcheck="true">//密钥材料转换</span><span class="token number">109</span>    X509EncodedKeySpec x509KeySpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">X509EncodedKeySpec</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">110</span>    <span class="token comment" spellcheck="true">//产生公钥</span><span class="token number">111</span>    PublicKey pubKey <span class="token operator">=</span> keyFactory<span class="token punctuation">.</span><span class="token function">generatePublic</span><span class="token punctuation">(</span>x509KeySpec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">112</span>    <span class="token comment" spellcheck="true">//数据解密</span><span class="token number">113</span>    Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>keyFactory<span class="token punctuation">.</span><span class="token function">getAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">114</span>    cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>Cipher<span class="token punctuation">.</span>DECRYPT_MODE<span class="token punctuation">,</span> pubKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">115</span>    <span class="token keyword">return</span> cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">116</span><span class="token punctuation">}</span><span class="token number">117</span><span class="token number">118</span><span class="token comment" spellcheck="true">/**119  * 取得私钥120  *121  * @param keyMap 密钥map122  * @return byte[] 私钥123  */</span>124public <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getPrivateKey</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> keyMap<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token number">125</span>    Key key <span class="token operator">=</span> <span class="token punctuation">(</span>Key<span class="token punctuation">)</span> keyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>PRIVATE_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">126</span>    <span class="token keyword">return</span> key<span class="token punctuation">.</span><span class="token function">getEncoded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">127</span><span class="token punctuation">}</span><span class="token number">128</span><span class="token number">129</span><span class="token comment" spellcheck="true">/**130  * 取得公钥131  *132  * @param keyMap 密钥map133  * @return byte[] 公钥134  */</span>135public <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getPublicKey</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> keyMap<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span><span class="token number">136</span>    Key key <span class="token operator">=</span> <span class="token punctuation">(</span>Key<span class="token punctuation">)</span> keyMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>PUBLIC_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">137</span>    <span class="token keyword">return</span> key<span class="token punctuation">.</span><span class="token function">getEncoded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">138</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、加密盐"><a href="#四、加密盐" class="headerlink" title="四、加密盐"></a>四、加密盐</h2><p>加密盐也是比较常听到的一个概念，盐就是一个随机字符串用来和我们的加密串拼接后进行加密。加盐主要是为了提供加密字符串的安全性。假如有一个加盐后的加密串，黑客通过一定手段这个加密串，他拿到的明文，并不是我们加密前的字符串，而是加密前的字符串和盐组合的字符串，这样相对来说又增加了字符串的安全性。</p><p><strong>文中的一些算法来源于网络，可直接复制使用</strong>。</p><p>比较推荐的几个加密算法有：</p><ul><li>不可逆加密：<code>SHA256</code>、<code>SHA384</code>、<code>SHA512</code>以及<code>HMAC-SHA256</code>、<code>HMAC-SHA384</code>、<code>HMAC-SHA512</code></li><li>对称加密算法：<code>AES</code>、<code>3DES</code></li><li>非对称加密算法：<code>RSA</code></li></ul><p>作者：Java旅途<br>链接：<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247504648&amp;idx=3&amp;sn=a99e72e87a42e5226978843ce0b7a576&amp;chksm=eb50563edc27df28328bb731d0e071bcfdd65faab44f157ce37d9fc892eddff73996729f06df&amp;mpshare=1&amp;scene=1&amp;srcid=0814BbUANZahzDOZl3jK5UDR&amp;sharer_sharetime=1597375409640&amp;sharer_shareid=435636c34212982d3b3d0727d8fe020f&amp;key=d8d62429242a2c0edfd0010eaa53d21715fcbf89b88828f9a80b340559914e9e3fb15ca38d0b46478481da5060a9fbcb32ba1455869f177fefcee64c30e2b317c5065658b779911ce257a481f28af17d8377ab432fbf5cbfb45b9802bfb99f33bf792d5386735f5986ca6ca4ce5e5183585010440b30af1041210f0b2a127112&amp;ascene=1&amp;uin=MjY2MTM3NDU=&amp;devicetype=Windows+10+x64&amp;version=6300002f&amp;lang=zh_CN&amp;exportkey=Azn4+oIXr0yOB8MxZd1UYYc=&amp;pass_ticket=1qlYNDiFNFyY7QVygdW20NdHKJNTCiM6FPzTi+BaRWyJmMj/gc3TRTMdW+l04g8s&amp;wx_header=0">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247504648&amp;idx=3&amp;sn=a99e72e87a42e5226978843ce0b7a576&amp;chksm=eb50563edc27df28328bb731d0e071bcfdd65faab44f157ce37d9fc892eddff73996729f06df&amp;mpshare=1&amp;scene=1&amp;srcid=0814BbUANZahzDOZl3jK5UDR&amp;sharer_sharetime=1597375409640&amp;sharer_shareid=435636c34212982d3b3d0727d8fe020f&amp;key=d8d62429242a2c0edfd0010eaa53d21715fcbf89b88828f9a80b340559914e9e3fb15ca38d0b46478481da5060a9fbcb32ba1455869f177fefcee64c30e2b317c5065658b779911ce257a481f28af17d8377ab432fbf5cbfb45b9802bfb99f33bf792d5386735f5986ca6ca4ce5e5183585010440b30af1041210f0b2a127112&amp;ascene=1&amp;uin=MjY2MTM3NDU%3D&amp;devicetype=Windows+10+x64&amp;version=6300002f&amp;lang=zh_CN&amp;exportkey=Azn4%2BoIXr0yOB8MxZd1UYYc%3D&amp;pass_ticket=1qlYNDiFNFyY7QVygdW20NdHKJNTCiM6FPzTi%2BBaRWyJmMj%2Fgc3TRTMdW%2Bl04g8s&amp;wx_header=0</a><br>来源：微信公众号<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encryption </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 启动事件和监听器，太强大了</title>
      <link href="2020/12/15/springbootevent/"/>
      <url>2020/12/15/springbootevent/</url>
      
        <content type="html"><![CDATA[<p>大家都知道，在 Spring 框架中事件和监听无处不在，打通了 Spring 框架的任督二脉，事件和监听也是 Spring 框架必学的核心知识之一。</p><p>一般来说，我们很少会使用到应用程序事件，但我们也不要忘了它们的存在，比如说在 Spring 框架内部都使用了各种不同的事件来处理不同的任务。</p><p>毫无疑问，在 Spring Boot 框架中，事件和监听也得到了发扬光大，除了常用的 Spring Framework 事件（例如：ContextRefreshedEvent）之外，Spring Boot 在启动过程中还发送一系列其他的应用程序事件。</p><h2 id="Spring-Boot-启动事件顺序"><a href="#Spring-Boot-启动事件顺序" class="headerlink" title="Spring Boot 启动事件顺序"></a>Spring Boot 启动事件顺序</h2><p><strong>1、ApplicationStartingEvent</strong></p><p>这个事件在 Spring Boot 应用运行开始时，且进行任何处理之前发送（除了监听器和初始化器注册之外）。</p><p><strong>2、ApplicationEnvironmentPreparedEvent</strong></p><p>这个事件在当已知要在上下文中使用 Spring 环境（Environment）时，在 Spring 上下文（context）创建之前发送。</p><p><strong>3、ApplicationContextInitializedEvent</strong></p><p>这个事件在当 Spring 应用上下文（ApplicationContext）准备好了，并且应用初始化器（ApplicationContextInitializers）已经被调用，在 bean 的定义（bean definitions）被加载之前发送。</p><p><strong>4、ApplicationPreparedEvent</strong></p><p>这个事件是在 Spring 上下文（context）刷新之前，且在 bean 的定义（bean definitions）被加载之后发送。</p><p><strong>5、ApplicationStartedEvent</strong></p><p>这个事件是在 Spring 上下文（context）刷新之后，且在 application/ command-line runners 被调用之前发送。</p><p><strong>6、AvailabilityChangeEvent</strong></p><p>这个事件紧随上个事件之后发送，状态：ReadinessState.CORRECT，表示应用已处于活动状态。</p><p><strong>7、ApplicationReadyEvent</strong></p><p>这个事件在任何 application/ command-line runners 调用之后发送。</p><p><strong>8、AvailabilityChangeEvent</strong></p><p>这个事件紧随上个事件之后发送，状态：ReadinessState.ACCEPTING_TRAFFIC，表示应用可以开始准备接收请求了。</p><p><strong>9、ApplicationFailedEvent</strong></p><p>这个事件在应用启动异常时进行发送。</p><hr><p>上面所介绍的这些事件列表仅包括绑定到 SpringApplication 的 SpringApplicationEvents 事件，除了这些事件以外，以下事件也会在 ApplicationPreparedEvent 之后和 ApplicationStartedEvent 之前发送：</p><ul><li><strong>WebServerInitializedEvent</strong>这个 Web 服务器初始化事件在 WebServer 启动之后发送，对应的还有 ServletWebServerInitializedEvent（Servlet Web 服务器初始化事件）、ReactiveWebServerInitializedEvent（响应式 Web 服务器初始化事件）。</li><li><strong>ContextRefreshedEvent</strong>这个上下文刷新事件是在 Spring 应用上下文（ApplicationContext）刷新之后发送。</li></ul><hr><h2 id="自定义启动事件监听器"><a href="#自定义启动事件监听器" class="headerlink" title="自定义启动事件监听器"></a>自定义启动事件监听器</h2><p>既然我们知道了 Spring Boot 在启动过程中的各个事件，那么我们就可以在每个环节来处理一些我们想做的事情，只需要自定义一个监听器来监听某个事件就可以了。</p><p>比如我们想在上面的第 8 步，即应用启动完成可以接收请求了，我们简单输出一个成功标识。</p><p>Spring Boot 基础的构建这里就不介绍了，如果你对 Spring Boot 还不是很熟悉，或者只是会简单的使用，那还是建议你深入学习下吧，推荐这个 Spring Boot 学习仓库，欢迎 Star 关注：</p><blockquote><p><a href="https://github.com/javastacks/spring-boot-best-practice">https://github.com/javastacks/spring-boot-best-practice</a></p></blockquote><h3 id="1-新建监听器"><a href="#1-新建监听器" class="headerlink" title="1. 新建监听器"></a>1. 新建监听器</h3><pre><code>import lombok.extern.slf4j.Slf4j;import org.springframework.boot.availability.AvailabilityChangeEvent;import org.springframework.boot.availability.ReadinessState;import org.springframework.context.ApplicationListener;/** * 来源：Java技术栈 */@Slf4jpublic class JavastackListener implements ApplicationListener&lt;AvailabilityChangeEvent&gt; {    @Override    public void onApplicationEvent(AvailabilityChangeEvent event) {        log.info("监听到事件：" + event);        if (ReadinessState.ACCEPTING_TRAFFIC == event.getState()){            log.info("应用启动完成，可以请求了……");        }    }}</code></pre><p>新建一个自定义监听器，实现了 ApplicationListener 接口，泛型 AvailabilityChangeEvent 表示仅仅监听 AvailabilityChangeEvent 事件。</p><p>因第 8 步的事件和第 6 步的事件同名，我们可以根据事件的状态来区分到底是哪一个环节的事件 。</p><h3 id="2-注册监听器"><a href="#2-注册监听器" class="headerlink" title="2. 注册监听器"></a>2. 注册监听器</h3><p><strong>注册监听器有两种方式：</strong></p><p>1、在资源目录中的 META-INF/spring.factories 文件中自动注册：</p><pre><code>org.springframework.context.ApplicationListener=\cn.javastack.springboot.features.listener.JavastackListener</code></pre><p>2、如果是监听 Spring 应用上下文（ApplicationContext）创建之后的事件，可以直接在监听器上使用 @Component 注解即可，否则需要使用第一种方法的自动注册，因为 ApplicationContext 并未创建，这时的 Bean 是不能被加载的。</p><h3 id="3-应用启动"><a href="#3-应用启动" class="headerlink" title="3. 应用启动"></a>3. 应用启动</h3><p>下面来看下启动日志：</p><p><img src="https://p3-tt.byteimg.com/origin/pgc-image/173441b6373b46d7a82f8c90325b1926?from=pc" alt="Spring Boot 启动事件和监听器，太强大了"></p><p>可以看到同时输出了第 6 步和 8 步的监听日志，但只输出第 8 步的启动完成日志，自定义监听实现成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解了 Spring Boot 启动过程中的各个事件及监听机制，大家可以依葫芦画瓢实现 Spring Boot 启动过程中的各个自定义操作，比如说在启动过程上实现动态注册、移除 Bean 等。</p><p>一般来说，不建议使用事件和监听器来实现比较耗时和繁重的任务，这样会影响应用程序的正常启动，考虑使用 Spring Boot 的 application/ command-line runners 来进行实现。</p><p>本文只是介绍了一下 Spring Boot 启动过程中的事件及如何实现自定义监听器，怎么实现一个业务上的自定义事件和监听器不在本文范围之类，后续栈长再开一篇，关注Java技术栈第一时间推送，不要走开。</p><p>本文实践所有源代码已上传：</p><blockquote><p><a href="https://github.com/javastacks/spring-boot-best-practice">https://github.com/javastacks/spring-boot-best-practice</a></p></blockquote><p>参考资料：</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/2.3.5.RELEASE/reference/htmlsingle/#boot-features-application-events-and-listeners">https://docs.spring.io/spring-boot/docs/2.3.5.RELEASE/reference/htmlsingle/#boot-features-application-events-and-listeners</a></p></blockquote><p>最后，觉得有收获，在看、转发一下哦，原创不易，需要鼓励。</p><p>作者：Java技术栈<br>链接：<a href="https://www.toutiao.com/i6906359568658399752/?tt_from=dingtalk&amp;utm_campaign=client_share&amp;timestamp=1608014320&amp;app=news_article&amp;utm_source=dingtalk&amp;utm_medium=toutiao_ios&amp;use_new_style=1&amp;req_id=202012151438400100260790160D018A45&amp;dtshare_count=1&amp;group_id=6906359568658399752">https://www.toutiao.com/i6906359568658399752/?tt_from=dingtalk&amp;utm_campaign=client_share&amp;timestamp=1608014320&amp;app=news_article&amp;utm_source=dingtalk&amp;utm_medium=toutiao_ios&amp;use_new_style=1&amp;req_id=202012151438400100260790160D018A45&amp;dtshare_count=1&amp;group_id=6906359568658399752</a><br>来源：头条<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> event </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot2之优雅处理返回值</title>
      <link href="2020/12/15/springbootgracefullyhandlesthereturnvalue/"/>
      <url>2020/12/15/springbootgracefullyhandlesthereturnvalue/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近项目组有个老项目要进行前后端分离改造，应前端同学的要求，其后端提供的返回值格式需形如</p><pre><code>{  "status": 0,  "message": "success",  "data": {  }}</code></pre><p>方便前端数据处理。要实现前端同学这个需求，其实也挺简单的，仅需做如下改造，新增一个返回对象，形如</p><pre><code>@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Result&lt;T&gt; {    public static final int success = 0;    public static final int fail = 1;    private int status = success;    private String message = "success";    private T data;}</code></pre><p>然后controller改造成如下</p><pre><code>@RestController@RequestMapping("/user")@Slf4jpublic class UserController {  @Autowired  private UserService userService;  @PostMapping(value="/add")  public Result&lt;UserDTO&gt; addUser(@Valid UserDTO userDTO, BindingResult bindingResult){    Result&lt;UserDTO&gt; result = new Result&lt;&gt;();    if (bindingResult.hasErrors()){      return getUserFailResult(bindingResult, result);    }    saveUser(userDTO, result);    return result;  }}</code></pre><p>仅仅需要这么改造就可以满足前端同学的述求。但这边存在一个问题就是，这个项目后端接口的contoller之前都是直接返回业务bean对象，形如下</p><pre><code>@RestController@Api(tags = "用户管理")@Slf4jpublic class UserController {    @Autowired    private UserService userService;    @GetMapping(value="/get/{id}")    @ApiOperation("根据用户ID查找用户")    @ApiImplicitParam(value = "用户id",name = "id",required = true,paramType = "path")    public UserDTO getUserById(@PathVariable("id") Long id){        UserDTO dto = userService.getUserById(id);        log.info("{}",dto);        return dto;    }    }</code></pre><p>如果按上面的思路</p><pre><code>把UserDTO改造成Result&lt;UserDTO&gt;</code></pre><p>虽然可以满足需求，但问题是后端这样的接口有好几十个，按这种改法很明显工作量比较大，更重要的不符合开闭原则–<strong>对扩展开放，对修改关闭</strong>。那有没有优雅一点的处理方式呢？答案是有的，利用<br>@RestControllerAdvice+ResponseBodyAdvice就可以满足我们的需求</p><h2 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h2><h3 id="1、在改造前，先简单介绍一下-RestControllerAdvice和ResponseBodyAdvice"><a href="#1、在改造前，先简单介绍一下-RestControllerAdvice和ResponseBodyAdvice" class="headerlink" title="1、在改造前，先简单介绍一下@RestControllerAdvice和ResponseBodyAdvice"></a>1、在改造前，先简单介绍一下@RestControllerAdvice和ResponseBodyAdvice</h3><blockquote><p>@RestControllerAdvice</p></blockquote><p>@RestControllerAdvice这个注解是spring 4.3版本之后新增的注解。用于定义@ExceptionHandler、@InitBinder、@ModelAttribute，并应用到所有@RequestMapping。利用他可以来做<strong>异常统一处理</strong>。如果使用的spring低于4.3，那可以使用@ControllerAdvice+@ResponseBody。@ControllerAdvice是spring 3.2版本后就提供的注解，其实现的功能和@RestControllerAdvice类似。<br>其详细的参考文档，可以查看链接@RestControllerAdvice文档以及@ControllerAdvice文档</p><blockquote><p>ResponseBodyAdvice</p></blockquote><p>这个是spring4.1版本之后，新增的接口。其作用是<strong>允许在执行@ResponseBody或ResponseEntity控制器方法之后但在使用HttpMessageConverter编写正文之前自定义响应</strong>。可以直接在RequestMappingHandlerAdapter和ExceptionHandlerExceptionResolver中注册实现，也可以在@ControllerAdvice或者@RestControllerAdvice中注解。其详细参考文档可以查看链接ResponseBodyAdvice文档</p><h3 id="2、编写一个通用的响应实体"><a href="#2、编写一个通用的响应实体" class="headerlink" title="2、编写一个通用的响应实体"></a>2、编写一个通用的响应实体</h3><pre><code>@Data@AllArgsConstructor@NoArgsConstructor@Builderpublic class Result&lt;T&gt; {    public static final int success = 0;    public static final int fail = 1;    private int status = success;    private String message = "success";    private T data;}</code></pre><h3 id="3、编写一个类上加上-RestControllerAdvice并实现ResponseBodyAdvice接口。用来统一处理响应值"><a href="#3、编写一个类上加上-RestControllerAdvice并实现ResponseBodyAdvice接口。用来统一处理响应值" class="headerlink" title="3、编写一个类上加上@RestControllerAdvice并实现ResponseBodyAdvice接口。用来统一处理响应值"></a>3、编写一个类上加上@RestControllerAdvice并实现ResponseBodyAdvice接口。用来统一处理响应值</h3><pre><code>@RestControllerAdvice(basePackages = "com.github.lybgeek")@Slf4jpublic class ResponseAdvice implements ResponseBodyAdvice {    @Override    public boolean supports(MethodParameter methodParameter, Class aClass) {        return true;    }    @Override    public Object beforeBodyWrite(Object o, MethodParameter methodParameter, MediaType mediaType, Class aClass, ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse) {        if(Objects.isNull(o)){            return Result.builder().message("success").build();        }        if(o instanceof Result){            return o;        }        return Result.builder().message("success").data(o).build();    }    @ExceptionHandler(Exception.class)    @ResponseStatus(code = HttpStatus.INTERNAL_SERVER_ERROR)    public Result&lt;?&gt; exceptionHandler(HttpServletRequest request, Exception e) {        log.error(e.getMessage(), e);        return Result.builder().message(e.getMessage()).status(Result.fail).build();    }    /**     * 针对业务异常统一处理     * @param request     * @param bizException     * @return     */    @ExceptionHandler(BizException.class)    @ResponseStatus(code = HttpStatus.EXPECTATION_FAILED)    public Result&lt;?&gt; bizExceptionHandler(HttpServletRequest request, BizException bizException) {            int errorCode = bizException.getCode();            log.error("catch bizException {}", errorCode);            return Result.builder().message(bizException.getMessage()).status(errorCode).build();    }    /**     * 针对Validate校验异常统一处理     * @param request     * @param methodArgumentNotValidException     * @return     */    @ExceptionHandler(MethodArgumentNotValidException.class)    @ResponseStatus(code = HttpStatus.BAD_REQUEST)    public Result&lt;?&gt; methodArgumentNotValidExceptionExceptionHandler(HttpServletRequest request, MethodArgumentNotValidException methodArgumentNotValidException) {        Result result = new Result();        log.error("catch methodArgumentNotValidException :" + methodArgumentNotValidException.getMessage(), methodArgumentNotValidException);        return ResultUtils.INSTANCE.getFailResult(methodArgumentNotValidException.getBindingResult(),result);    }    /**     * 针对Assert断言异常统一处理     * @param request     * @param illegalArgumentExceptionException     * @return     */    @ExceptionHandler(IllegalArgumentException.class)    @ResponseStatus(code = HttpStatus.EXPECTATION_FAILED)    public Result&lt;?&gt; illegalArgumentExceptionHandler(HttpServletRequest request, IllegalArgumentException illegalArgumentExceptionException) {        log.error("illegalArgumentExceptionException:"+illegalArgumentExceptionException.getMessage(), illegalArgumentExceptionException);        return Result.builder().message(illegalArgumentExceptionException.getMessage()).status(Result.fail).build();    }</code></pre><h2 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h2><blockquote><p>1、编写业务DTO</p></blockquote><pre><code>@Data@AllArgsConstructor@NoArgsConstructor@Builder@ApiModelpublic class UserDTO implements Serializable {  @NotNull(message = "编号不能为空",groups = {Update.class, Delete.class})  @ApiModelProperty(value = "编号",name = "id",example = "1")  private Long id;  @NotBlank(message = "用户名不能为空",groups = {Add.class})  @ApiModelProperty(value = "用户名",name = "userName",example = "zhangsan")  private String userName;  @NotBlank(message = "姓名不能为空",groups = {Add.class})  @ApiModelProperty(value = "姓名",name = "realName",example = "张三")  private String realName;  @NotBlank(message = "密码不能为空",groups = {Add.class})  @Size(max=32,min=6,message = "密码长度要在6-32之间",groups = {Add.class})  @ApiModelProperty(value = "密码",name = "password",example = "123456")  private String password;  @NotNull(message = "性别不能为空",groups = {Add.class})  @ApiModelProperty(value = "性别",name = "gender",example = "1")  @EnumValid(target = Gender.class, message = "性别取值必须为0或者1",groups = {Add.class,Update.class})  private Integer gender;  @ApiModelProperty(value = "邮箱",name = "email",example = "zhangsan@qq.com")  @Pattern(regexp = "^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.[a-zA-Z0-9]{2,6}$",message = "不满足邮箱正则表达式",groups = {Add.class,Update.class})  private String email;}</code></pre><blockquote><p>2、编写业务controller</p></blockquote><pre><code>@RestController@Api(tags = "用户管理")@Slf4jpublic class UserController {    @Autowired    private UserService userService;    @GetMapping(value="/get/{id}")    @ApiOperation("根据用户ID查找用户")    @ApiImplicitParam(value = "用户id",name = "id",required = true,paramType = "path")    public UserDTO getUserById(@PathVariable("id") Long id){        UserDTO dto = userService.getUserById(id);        log.info("{}",dto);        return dto;    }    @PostMapping(value="/add")    @ApiOperation("添加用户")    public UserDTO add(@RequestBody @Validated({Add.class}) UserDTO userDTO){        log.info("{}",userDTO);        return userService.save(userDTO);    }    @PostMapping(value="/update")    @ApiOperation("更新用户")    public UserDTO update(@RequestBody @Validated({Update.class}) UserDTO userDTO){        log.info("{}",userDTO);        return userService.save(userDTO);    }    @DeleteMapping(value="/detele")    @ApiOperation("删除用户")    public boolean delete(@Validated({Delete.class}) UserDTO userDTO){        log.info("id：{}",userDTO.getId());        return userService.delete(userDTO.getId());    }}</code></pre><p><strong>注：</strong> 业务service就不贴了和文章内容关系不大。如果感兴趣的朋友，可以从文末提供的链接进行查看</p><blockquote><p>3、利用swagger在线接口文档进行测试</p></blockquote><p>a：正常响应时，返回值形如下</p><pre><code>{  "status": 0,  "message": "success",  "data": {    "id": 1,    "userName": "zhangsan",    "realName": "张三",    "password": "123456",    "gender": 1,    "email": "zhangsan@qq.com"  }}</code></pre><p>b：当数据校验异常时，返回值形如下</p><pre><code>{  "status": 1,  "message": "姓名不能为空;",  "data": null}</code></pre><p>c:当业务异常时，返回值形如下</p><pre><code>{  "status": 1,  "message": "user is not found by id :3",  "data": null}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了如何利用@RestControllerAdvice和ResponseBodyAdvice来统一处理返回值。本文代码示例还实现了分组校验，自定义校验，利用mdc traceId日志埋点，如果对这些内容感兴趣的朋友，可以查看文末项目链接</p><h2 id="demo链接"><a href="#demo链接" class="headerlink" title="demo链接"></a>demo链接</h2><blockquote><p><a href="https://github.com/lyb-geek/springboot-learning/tree/master/springboot-unit-resp">https://github.com/lyb-geek/springboot-learning/tree/master/springboot-unit-resp</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot @Validated分组功能用在service层校验对象解决方案</title>
      <link href="2020/11/28/springboot-validated-service/"/>
      <url>2020/11/28/springboot-validated-service/</url>
      
        <content type="html"><![CDATA[<h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Validated</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BrandServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token operator">&lt;</span>BrandMapper<span class="token punctuation">,</span> Brand<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">BrandService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Brand <span class="token function">getBrandByCode</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotBlank</span> String brandCode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getById</span><span class="token punctuation">(</span>brandCode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Validated</span><span class="token punctuation">(</span><span class="token punctuation">{</span>Create<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">saveBrand</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Valid</span> Brand brand<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">save</span><span class="token punctuation">(</span>brand<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Validated</span><span class="token punctuation">(</span><span class="token punctuation">{</span>Update<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">updateBrand</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Valid</span> Brand brand<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">updateById</span><span class="token punctuation">(</span>brand<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://blog.csdn.net/blueheart20/article/details/88817754">https://blog.csdn.net/blueheart20/article/details/88817754</a></p><p><a href="https://reflectoring.io/bean-validation-with-spring-boot/">https://reflectoring.io/bean-validation-with-spring-boot/</a></p>]]></content>
      
      
      <categories>
          
          <category> develop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> java </tag>
            
            <tag> validated </tag>
            
            <tag> group </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排名前 16 的 Java 工具类</title>
      <link href="2020/11/24/java-tools-class/"/>
      <url>2020/11/24/java-tools-class/</url>
      
        <content type="html"><![CDATA[<p>在Java中，实用程序类是定义一组执行通用功能的方法的类。</p><p>这篇文章展示了最常用的Java实用工具类及其最常用的方法。类列表及其方法列表均按受欢迎程度排序。数据基于从GitHub随机选择的50,000个开源Java项目。</p><p>希望您可以通过浏览列表来了解已经提供和流行的功能的一些想法，以使您知道不需要自己实现。这些方法的名称通常指示它们的作用。如果方法名称不够直观，您还可以查看其他开发人员如何在其开源项目中使用它们。</p><ol><li><code>org.apache.commons.io.IOUtils</code></li></ol><pre><code>closeQuietly()  toString()  copy()  toByteArray()  write()  toInputStream()  readLines()  copyLarge()  lineIterator()  readFully()  </code></pre><ol><li><code>org.apache.commons.io.FileUtils</code></li></ol><pre><code>deleteDirectory()  readFileToString()  deleteQuietly()  copyFile()  writeStringToFile()  forceMkdir()  write()  listFiles()  copyDirectory()  forceDelete()  </code></pre><ol><li><code>org.apache.commons.lang.StringUtils</code></li></ol><pre><code>isBlank()  isNotBlank()  isEmpty()  isNotEmpty()  equals()  join()  split()  EMPTY  trimToNull()  replace()  </code></pre><ol><li><code>org.apache.http.util.EntityUtils</code></li></ol><pre><code>toString()  consume()  toByteArray()  consumeQuietly()  getContentCharSet()  </code></pre><ol><li><code>org.apache.commons.lang3.StringUtils</code></li></ol><pre><code>isBlank()  isNotBlank()  isEmpty()  isNotEmpty()  join()  equals()  split()  EMPTY  replace()  capitalize()  </code></pre><ol><li><code>org.apache.commons.io.FilenameUtils</code></li></ol><pre><code>getExtension()  getBaseName()  getName()  concat()  removeExtension()  normalize()  wildcardMatch()  separatorsToUnix()  getFullPath()  isExtension()  </code></pre><ol><li><code>org.springframework.util.StringUtils</code></li></ol><pre><code>hasText()  hasLength()  isEmpty()  commaDelimitedListToStringArray()  collectionToDelimitedString()  replace()  delimitedListToStringArray()  uncapitalize()  collectionToCommaDelimitedString()  tokenizeToStringArray()  </code></pre><ol><li><code>org.apache.commons.lang.ArrayUtils</code></li></ol><pre><code>contains()  addAll()  clone()  isEmpty()  add()  EMPTY_BYTE_ARRAY  subarray()  indexOf()  isEquals()  toObject()  </code></pre><ol><li><code>org.apache.commons.lang.StringEscapeUtils</code></li></ol><pre><code>escapeHtml()  unescapeHtml()  escapeXml()  escapeSql()  unescapeJava()  escapeJava()  escapeJavaScript()  unescapeXml()  unescapeJavaScript()  </code></pre><ol><li><code>org.apache.http.client.utils.URLEncodedUtils</code></li></ol><pre><code>format()  parse()  </code></pre><ol><li><code>org.apache.commons.codec.digest.DigestUtils</code></li></ol><pre><code>md5Hex()  shaHex()  sha256Hex()  sha1Hex()  sha()  md5()  sha512Hex()  sha1()  </code></pre><ol><li><code>org.apache.commons.collections.CollectionUtils</code></li></ol><pre><code>isEmpty()  isNotEmpty()  select()  transform()  filter()  find()  collect()  forAllDo()  addAll()  isEqualCollection()  </code></pre><ol><li><code>org.apache.commons.lang3.ArrayUtils</code></li></ol><pre><code>contains()  isEmpty()  isNotEmpty()  add()  clone()  addAll()  subarray()  indexOf()  EMPTY_OBJECT_ARRAY  EMPTY_STRING_ARRAY  </code></pre><ol><li><code>org.apache.commons.beanutils.PropertyUtils</code></li></ol><pre><code>getProperty()  setProperty()  getPropertyDescriptors()  isReadable()  copyProperties()  getPropertyDescriptor()  getSimpleProperty()  isWriteable()  setSimpleProperty()  getPropertyType()  </code></pre><ol><li><code>org.apache.commons.lang3.StringEscapeUtils</code></li></ol><pre><code>unescapeHtml4()  escapeHtml4()  escapeXml()  unescapeXml()  escapeJava()  escapeEcmaScript()  unescapeJava()  escapeJson()  escapeXml10()  </code></pre><ol><li><code>org.apache.commons.beanutils.BeanUtils</code></li></ol><pre><code>copyProperties()  getProperty()  setProperty()  describe()  populate()  copyProperty()  cloneBean()  </code></pre><p>来源：<a href="https://www.programcreek.com/">https://www.programcreek.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA 超实用技巧</title>
      <link href="2020/11/24/intellij-idea-skills/"/>
      <url>2020/11/24/intellij-idea-skills/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>工欲善其事</p><p> 必先利其器</p></blockquote><p>最近受部门的邀请，给入职新人统一培训IDEA，发现有很多新人虽然日常开发使用的是IDEA，但是还是很多好用的技巧没有用到，只是用到一些基本的功能，蛮浪费IDEA这个优秀的IDE。 同时，在这次分享之后，本人自己也学习到了一些新的使用技巧，所以借着这次机会，一起分享出来。希望可以帮到一些人。</p><blockquote><p>基于的 IDEA 版本信息：IntelliJ IDEA 2018.2.2 (Ultimate Edition)</p></blockquote><p>知识点概览：</p><ul><li>高效率配置</li><li>日常使用 必备快捷键（★★）<ul><li>查找</li><li>跳转切换</li><li>编码相关</li><li>代码阅读相关</li><li>版本管理相关</li></ul></li><li>编码效率相关（★★）<ul><li>文件代码模板</li><li>实时代码模板</li><li>其他</li></ul></li><li>代码调试 源码阅读相关（★★★）<ul><li>视图模式</li><li>代码调试</li><li>…</li></ul></li><li>插件方面<ul><li>插件的安装与使用</li><li>插件推荐</li></ul></li><li>参考</li></ul><hr><h4 id="2019-08-09-UPDATE"><a href="#2019-08-09-UPDATE" class="headerlink" title="2019-08-09 UPDATE"></a>2019-08-09 UPDATE</h4><p>[插件推荐]增加图片描述，增加插件内容。阅读更友好。</p><hr><h3 id="高效率配置"><a href="#高效率配置" class="headerlink" title="高效率配置"></a>高效率配置</h3><h4 id="1-代码提示不区分大小写"><a href="#1-代码提示不区分大小写" class="headerlink" title="1. 代码提示不区分大小写"></a>1. 代码提示不区分大小写</h4><pre><code>Settings -&gt; Editor -&gt; General -&gt; Code Completion</code></pre><p><img src="/2020/11/24/intellij-idea-skills/1.jpg" alt="img"></p><p>(低版本 将 Case sensitive completion 设置为 None 就可以了)</p><h4 id="2-自动导包功能及相关优化功能"><a href="#2-自动导包功能及相关优化功能" class="headerlink" title="2. 自动导包功能及相关优化功能"></a>2. 自动导包功能及相关优化功能</h4><pre><code>Settings -&gt; Editor -&gt; General -&gt; Auto Import</code></pre><p><img src="/2020/11/24/intellij-idea-skills/2495526922-5d47f467e4aee_articlex.jfif" alt="img"></p><h4 id="3-CTRL-滑动滚轮-调整窗口显示大小"><a href="#3-CTRL-滑动滚轮-调整窗口显示大小" class="headerlink" title="3. CTRL + 滑动滚轮 调整窗口显示大小"></a>3. CTRL + 滑动滚轮 调整窗口显示大小</h4><pre><code>Settings -&gt; Editor -&gt; General -&gt; Change font size (Zoom) with Ctrl+Mouse wheel</code></pre><p><img src="/2020/11/24/intellij-idea-skills/728192460-5d47f46749132_articlex.jfif" alt="img"></p><p>选择之后，就可以通过CTRL+滑动滚轮的方式，调整编辑器窗口的字体大小</p><h4 id="4-tab-多行显示"><a href="#4-tab-多行显示" class="headerlink" title="4. tab 多行显示"></a>4. tab 多行显示</h4><p>这点因人而异，有些人喜欢直接取消所有tab，改用快捷键的方式，我屏幕比较大，所以喜欢把tab全部显示出来。</p><p><code>Window -&gt; Editor Tabs -&gt; Tabs Placement</code>，取消勾选 <code>Show Tabs In Single Row</code>选项。</p><p><img src="/2020/11/24/intellij-idea-skills/3370201002-5d47f467aac8b_articlex.jfif" alt="img"></p><p>效果如下：</p><p><img src="/2020/11/24/intellij-idea-skills/4172153788-5d47f46522c6c_articlex.jfif" alt="img"></p><h4 id="5-代码编辑区显示行号"><a href="#5-代码编辑区显示行号" class="headerlink" title="5. 代码编辑区显示行号"></a>5. 代码编辑区显示行号</h4><pre><code>Settings -&gt; Editor -&gt; General -&gt; Appearance `勾选 `Show Line Numbers</code></pre><p><img src="/2020/11/24/intellij-idea-skills/3589429929-5d47f5ae548ea_articlex.jfif" alt="img"></p><p><img src="/2020/11/24/intellij-idea-skills/1829319116-5d47f4654e925_articlex.jfif" alt="img"></p><p>6….</p><h3 id="日常使用-必备快捷键（★★）"><a href="#日常使用-必备快捷键（★★）" class="headerlink" title="日常使用 必备快捷键（★★）"></a>日常使用 必备快捷键（★★）</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + F</td><td>在当前文件进行文本查找</td></tr><tr><td>Ctrl + R</td><td>在当前文件进行文本替换</td></tr><tr><td>Shift + Ctrl + F</td><td>在项目进行文本查找</td></tr><tr><td>Shift + Ctrl + R</td><td>在项目进行文本替换</td></tr><tr><td>Shift + Shift</td><td>快速搜索</td></tr><tr><td>Ctrl + N</td><td>查找class</td></tr><tr><td>Ctrl + Shift + N</td><td>查找文件</td></tr><tr><td>Ctrl + Shift + Alt + N</td><td>查找symbol（查找某个方法名）</td></tr></tbody></table><h4 id="跳转切换"><a href="#跳转切换" class="headerlink" title="跳转切换"></a>跳转切换</h4><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + E</td><td>最近文件</td></tr><tr><td>Ctrl + Tab</td><td>切换文件</td></tr><tr><td>Ctrl + Alt + ←/→</td><td>跳转历史光标所在处</td></tr><tr><td>Alt + ←/→ 方向键</td><td>切换子tab</td></tr><tr><td>Ctrl + G</td><td>go to（跳转指定行号）</td></tr></tbody></table><h4 id="编码相关"><a href="#编码相关" class="headerlink" title="编码相关"></a>编码相关</h4><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + W</td><td>快速选中</td></tr><tr><td>(Shift + Ctrl) + Alt + J</td><td>快速选中同文本</td></tr><tr><td>Ctrl + C/Ctrl + X/Ctrl + D</td><td>快速复制或剪切</td></tr><tr><td>多行选中 Tab / Shift + Tab</td><td>tab</td></tr><tr><td>Ctrl + Y</td><td>删除整行</td></tr><tr><td>滚轮点击变量/方法/类</td><td>快速进入变量/方法/类的定义处</td></tr><tr><td>Shift + 点击Tab</td><td>快速关闭tab</td></tr><tr><td>Ctrl + Z 、Ctrl + Shift + Z</td><td>后悔药，撤销/取消撤销</td></tr><tr><td>Ctrl + Shift + enter</td><td>自动收尾，代码自动补全</td></tr><tr><td>Alt + enter</td><td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同</td></tr><tr><td>Alt + ↑/↓</td><td>方法快速跳转</td></tr><tr><td>F2</td><td>跳转到下一个高亮错误 或 警告位置</td></tr><tr><td>Alt + Insert</td><td>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td></tr><tr><td>Ctrl + Shift + L</td><td>格式化代码</td></tr><tr><td>Shift + F6</td><td>快速修改方法名、变量名、文件名、类名等</td></tr><tr><td>Ctrl + F6</td><td>快速修改方法签名</td></tr></tbody></table><h4 id="代码阅读相关"><a href="#代码阅读相关" class="headerlink" title="代码阅读相关"></a>代码阅读相关</h4><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + P</td><td>方法参数提示显示</td></tr><tr><td>Ctrl + Shift + i</td><td>就可以在当前类里再弹出一个窗口出来</td></tr><tr><td>Alt + F7</td><td>可以列出变量在哪些地方被使用了</td></tr><tr><td>光标在子类接口名，Ctrl + u</td><td>跳到父类接口</td></tr><tr><td>Alt + F1 + 1， esc</td><td></td></tr><tr><td>(Shift) + Ctrl + +/-</td><td>代码块折叠</td></tr><tr><td>Ctrl + Shift + ←/→</td><td>移动窗口分割线</td></tr><tr><td>Ctrl + (Alt) + B</td><td>跳转方法定义/实现</td></tr><tr><td>Ctrl + H</td><td>类的层级关系</td></tr><tr><td>Ctrl + F12</td><td>Show Members 类成员快速显示</td></tr></tbody></table><h4 id="版本管理相关"><a href="#版本管理相关" class="headerlink" title="版本管理相关"></a>版本管理相关</h4><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + D</td><td>Show Diff</td></tr><tr><td>(Shift) + F7</td><td>（上）下一处修改</td></tr></tbody></table><blockquote><p>更多快捷键请参考此文章</p><p><a href="https://github.com/judasn/Int">https://github.com/judasn/Int</a>…</p><p><strong>mac os</strong> 快捷键请参考本文章 <a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/keymap-win-mac.md">https://github.com/judasn/Int…</a></p></blockquote><h3 id="编码效率相关（★★）"><a href="#编码效率相关（★★）" class="headerlink" title="编码效率相关（★★）"></a>编码效率相关（★★）</h3><h4 id="文件代码模板"><a href="#文件代码模板" class="headerlink" title="文件代码模板"></a>文件代码模板</h4><pre><code>Settings -&gt; Editor -&gt; File and Code Template</code></pre><p><img src="/2020/11/24/intellij-idea-skills/2754792117-5d47f4680b132_articlex.jfif" alt="img"></p><p>在这里可以看到IDEA所有内置的文件代码模板，当你选择某个文件生成时，就会按照这里面的模板生成指定的代码文件。</p><p>另外，你可以在这里设置文件头。</p><p><img src="/2020/11/24/intellij-idea-skills/3923464073-5d47f6e6eee45_articlex.jfif" alt="img"></p><p>设置之后，效果如下</p><p><img src="/2020/11/24/intellij-idea-skills/2591569098-5d47f464eb1b5_articlex.jfif" alt="img"></p><h4 id="实时代码模板"><a href="#实时代码模板" class="headerlink" title="实时代码模板"></a>实时代码模板</h4><p>IDEA提供了强大的实时代码模板功能，并且原生内置了很多的模板，比如，当你输入<code>sout</code>或者<code>psvm</code>，就会快速自动生成<code>System.out.println();</code>和<code>public static void main(String[] args) {}</code>的代码块。</p><p><img src="/2020/11/24/intellij-idea-skills/3065273944-5d47f464d7f9e_articlex.jfif" alt="img"></p><p><img src="/2020/11/24/intellij-idea-skills/546789878-5d47f464b60fa_articlex.jfif" alt="img"></p><p>这些的模板可以在<code>Settings -&gt; Editor -&gt; Live Templates </code>看到。使用者可以按照自己的使用习惯来熟悉相关的代码模板。</p><p><img src="/2020/11/24/intellij-idea-skills/415570660-5d47f6e371702_articlex.jfif" alt="img"></p><h5 id="定制代码模板"><a href="#定制代码模板" class="headerlink" title="定制代码模板"></a>定制代码模板</h5><p>IDEA也提供自己定制实时代码模板的功能。</p><ol><li>创建自己的模板库</li><li>创建定制的代码模板</li></ol><p><img src="/2020/11/24/intellij-idea-skills/4292259647-5d47f464e180c_articlex.jfif" alt="img"></p><p>图中的<code>MyGroup</code>就存放着我自己定义的代码模板。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="CRTL-ALT-T"><a href="#CRTL-ALT-T" class="headerlink" title="CRTL+ALT+T"></a>CRTL+ALT+T</h5><p><img src="/2020/11/24/intellij-idea-skills/1460000019977280.jpg" alt="img"></p><p><code>Ctrl + Alt + T</code> 提供的是代码块包裹功能 - Surround With。可以快速将选中的代码块，包裹到选择的语句块中。</p><h5 id="本地历史版本"><a href="#本地历史版本" class="headerlink" title="本地历史版本"></a>本地历史版本</h5><p>IDEA 自带本地版本管理的功能，能够让你本地编写代码变得更加的安心和方便。</p><p><img src="/2020/11/24/intellij-idea-skills/1460000019977281.jpg" alt="img"></p><h3 id="代码调试-源码阅读相关（★★★）"><a href="#代码调试-源码阅读相关（★★★）" class="headerlink" title="代码调试 源码阅读相关（★★★）"></a>代码调试 源码阅读相关（★★★）</h3><h4 id="视图模式"><a href="#视图模式" class="headerlink" title="视图模式"></a>视图模式</h4><p><img src="/2020/11/24/intellij-idea-skills/1460000019977529.jpg" alt="img"></p><p>IDEA提供两种特殊的视图模式，</p><ol><li>Presentation Mode - 演示模式，专门用于Code Review这种需要展示代码的场景</li><li>Distraction Free Mode - 禅模式，专注于代码开发</li></ol><h4 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h4><h5 id="1-条件断点"><a href="#1-条件断点" class="headerlink" title="1. 条件断点"></a>1. 条件断点</h5><p>IDEA 可以设置指定条件的断点，增加我们调试的效率。</p><img src="/2020/11/24/intellij-idea-skills/abc.jpg" alt="img"><h5 id="2-强制返回"><a href="#2-强制返回" class="headerlink" title="2. 强制返回"></a>2. 强制返回</h5><p>IDEA 可以在打断点的方法栈处，强制返回你想要的方法返回值给调用方。非常灵活！</p><img src="/2020/11/24/intellij-idea-skills/1460000019977282.jpg" alt="img"><p><img src="/2020/11/24/intellij-idea-skills/1460000019977283.jpg" alt="img"></p><h5 id="3-模拟异常"><a href="#3-模拟异常" class="headerlink" title="3. 模拟异常"></a>3. 模拟异常</h5><p>IDEA 可以在打断点的方法栈处，强制抛出异常给调用方。这个在调试源码的时候非常有用。</p><p><img src="/2020/11/24/intellij-idea-skills/1460000019977284.jpg" alt="img"></p><h5 id="4-Evaluate-Expression"><a href="#4-Evaluate-Expression" class="headerlink" title="4. Evaluate Expression"></a>4. Evaluate Expression</h5><p>IDEA 还可以在调试代码的时候，动态修改当前方法栈中变量的值，方便我们的调试。</p><p><img src="/2020/11/24/intellij-idea-skills/1460000019977531.jpg" alt="img"></p><h3 id="插件方面"><a href="#插件方面" class="headerlink" title="插件方面"></a>插件方面</h3><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><pre><code>File -&gt; Setting -&gt; Plugin</code></pre><p>插件安装，可以直接在IDEA的插件库中实时搜索安装。<code>browse plugin repository</code></p><p>对于<strong>网络不好</strong>的用户，可以登录官方插件仓库地址：<a href="https://plugins.jetbrains.com/idea">https://plugins.jetbrains.com…</a>，下载压缩包之后，选择<code>install from disk</code></p><h4 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h4><p>本人日常开发中使用的插件</p><h5 id="Alibaba-Java-Coding-Guidelines"><a href="#Alibaba-Java-Coding-Guidelines" class="headerlink" title="Alibaba Java Coding Guidelines"></a>Alibaba Java Coding Guidelines</h5><p>阿里Java编程规约插件</p><h5 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h5><p>代码缺陷扫描</p><p><img src="/2020/11/24/intellij-idea-skills/sadfsadf.jpg" alt="img"></p><p><img src="/2020/11/24/intellij-idea-skills/sadfsaf.jpg" alt="img"></p><h5 id="PMD"><a href="#PMD" class="headerlink" title="PMD"></a>PMD</h5><p>代码缺陷扫描</p><h5 id="InnerBuilder"><a href="#InnerBuilder" class="headerlink" title="InnerBuilder"></a>InnerBuilder</h5><p>builder模式快速生成</p><p><img src="/2020/11/24/intellij-idea-skills/ddddd.jpg" alt="img"></p><h5 id="lombok-plugin"><a href="#lombok-plugin" class="headerlink" title="lombok plugin"></a>lombok plugin</h5><p>lombok 插件</p><h5 id="maven-helper"><a href="#maven-helper" class="headerlink" title="maven helper"></a>maven helper</h5><p>maven 依赖管理助手 ，解析maven pom结构，分析冲突；</p><p><img src="/2020/11/24/intellij-idea-skills/3l450-2134912873.jpg" alt="img"></p><p><img src="/2020/11/24/intellij-idea-skills/sdafsadfddd.jpg" alt="img"></p><h5 id="Rainbow-brackets"><a href="#Rainbow-brackets" class="headerlink" title="Rainbow brackets"></a>Rainbow brackets</h5><p>让代码中的括号更具标识性</p><p><img src="/2020/11/24/intellij-idea-skills/dddd.jpg" alt="img"></p><h5 id="HighlightBracketPair"><a href="#HighlightBracketPair" class="headerlink" title="HighlightBracketPair"></a>HighlightBracketPair</h5><p>自动高亮匹配代码段，和Rainbow brackets一起用爽爽的。</p><h5 id="String-Manipulation"><a href="#String-Manipulation" class="headerlink" title="String Manipulation"></a>String Manipulation</h5><p>String相关辅助简化，搭配 CTRL+W 、ALT+J等文本选择快捷键使用</p><p><img src="/2020/11/24/intellij-idea-skills/3332.gif" alt="img"></p><h5 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h5><p>翻译插件，阅读源码必备</p><p><img src="/2020/11/24/intellij-idea-skills/146000002001721.jpg" alt="img"></p><p><img src="/2020/11/24/intellij-idea-skills/146000002001.jpg" alt="img"></p><h5 id="GenerateAllSetter"><a href="#GenerateAllSetter" class="headerlink" title="GenerateAllSetter"></a>GenerateAllSetter</h5><p><img src="/2020/11/24/intellij-idea-skills/3726146879-5d4cce11103f7_articlex.gif" alt="img"></p><h5 id="Key-Promoter-X"><a href="#Key-Promoter-X" class="headerlink" title="Key Promoter X"></a>Key Promoter X</h5><p>对你的鼠标操作进行 快捷键提示</p><p><img src="/2020/11/24/intellij-idea-skills/1460000020017219.gif" alt="img"></p><h5 id="GenerateSerialVersionUID"><a href="#GenerateSerialVersionUID" class="headerlink" title="GenerateSerialVersionUID"></a>GenerateSerialVersionUID</h5><p><code>Alt</code> + <code>Insert</code> 快速生成SerialVersionUID</p><p><img src="/2020/11/24/intellij-idea-skills/1460000020017220.gif" alt="img"></p><h5 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h5><p><img src="/2020/11/24/intellij-idea-skills/1460000020017221.gif" alt="img"></p><h5 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a>RestfulToolkit</h5><ol><li>快速跳转到Restful Api处( use: Ctrl(Command) + or Ctrl + Alt + N )</li><li>展示Resultful 接口结构</li><li>http 简单请求工具</li></ol><p><img src="/2020/11/24/intellij-idea-skills/146000002001722.jpg" alt="img"></p><p><img src="/2020/11/24/intellij-idea-skills/14600000200172.jpg" alt="img"></p><h5 id="Material-Theme-UI"><a href="#Material-Theme-UI" class="headerlink" title="Material Theme UI"></a>Material Theme UI</h5><p>本人自用的主题就是这个。</p><p><img src="/2020/11/24/intellij-idea-skills/1460000020017.jpg" alt="img"></p><h5 id="MyBatis-Log-Plugin"><a href="#MyBatis-Log-Plugin" class="headerlink" title="MyBatis Log Plugin"></a>MyBatis Log Plugin</h5><p>把 Mybatis 输出的sql日志还原成完整的sql语句，看起来更直观。<br><img src="/2020/11/24/intellij-idea-skills/dddsddddafsa.jpg" alt="img"></p><h5 id="Free-Mybatis"><a href="#Free-Mybatis" class="headerlink" title="Free Mybatis"></a>Free Mybatis</h5><p>MyBatis 免费的插件</p><h5 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a>Codota</h5><p>自能代码提示，谁用谁知道。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">IntelliJ-IDEA-Tutorial)</a></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Commond</title>
      <link href="2020/11/24/linux-commond/"/>
      <url>2020/11/24/linux-commond/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>功能说明</th></tr></thead><tbody><tr><td>线上查询及帮助命令(2个)</td><td></td></tr><tr><td>man</td><td>查看命令帮助，命令的词典，更复杂的还有info，但不常用。</td></tr><tr><td>help</td><td>查看Linux内置命令的帮助，比如cd命令。</td></tr><tr><td>文件和目录操作命令(18个)</td><td></td></tr><tr><td>ls</td><td>全拼list，功能是列出目录的内容及其内容属性信息。</td></tr><tr><td>cd</td><td>全拼change directory，功能是从当前工作目录切换到指定的工作目录。</td></tr><tr><td>cp</td><td>全拼copy，其功能为复制文件或目录。</td></tr><tr><td>find</td><td>查找的意思，用于查找目录及目录下的文件。</td></tr><tr><td>mkdir</td><td>全拼make directories，其功能是创建目录。</td></tr><tr><td>mv</td><td>全拼move，其功能是移动或重命名文件。</td></tr><tr><td>pwd</td><td>全拼print working directory，其功能是显示当前工作目录的绝对路径。</td></tr><tr><td>rename</td><td>用于重命名文件。</td></tr><tr><td>rm</td><td>全拼remove，其功能是删除一个或多个文件或目录。</td></tr><tr><td>rmdir</td><td>全拼remove empty directories，功能是删除空目录。</td></tr><tr><td>touch</td><td>创建新的空文件，改变已有文件的时间戳属性。</td></tr><tr><td>tree</td><td>功能是以树形结构显示目录下的内容。</td></tr><tr><td>basename</td><td>显示文件名或目录名。</td></tr><tr><td>dirname</td><td>显示文件或目录路径。</td></tr><tr><td>chattr</td><td>改变文件的扩展属性。</td></tr><tr><td>lsattr</td><td>查看文件扩展属性。</td></tr><tr><td>file</td><td>显示文件的类型。</td></tr><tr><td>md5sum</td><td>计算和校验文件的MD5值。</td></tr><tr><td>查看文件及内容处理命令（21个）</td><td></td></tr><tr><td>cat</td><td>全拼concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。</td></tr><tr><td>tac</td><td>tac是cat的反向拼写，因此命令的功能为反向显示文件内容。</td></tr><tr><td>more</td><td>分页显示文件内容。</td></tr><tr><td>less</td><td>分页显示文件内容，more命令的相反用法。</td></tr><tr><td>head</td><td>显示文件内容的头部。</td></tr><tr><td>tail</td><td>显示文件内容的尾部。</td></tr><tr><td>cut</td><td>将文件的每一行按指定分隔符分割并输出。</td></tr><tr><td>split</td><td>分割文件为不同的小片段。</td></tr><tr><td>paste</td><td>按行合并文件内容。</td></tr><tr><td>sort</td><td>对文件的文本内容排序。</td></tr><tr><td>uniq</td><td>去除重复行。oldboy</td></tr><tr><td>wc</td><td>统计文件的行数、单词数或字节数。</td></tr><tr><td>iconv</td><td>转换文件的编码格式。</td></tr><tr><td>dos2unix</td><td>将DOS格式文件转换成UNIX格式。</td></tr><tr><td>diff</td><td>全拼difference，比较文件的差异，常用于文本文件。</td></tr><tr><td>vimdiff</td><td>命令行可视化文件比较工具，常用于文本文件。</td></tr><tr><td>rev</td><td>反向输出文件内容。</td></tr><tr><td>grep/egrep</td><td>过滤字符串，三剑客老三。</td></tr><tr><td>join</td><td>按两个文件的相同字段合并。</td></tr><tr><td>tr</td><td>替换或删除字符。</td></tr><tr><td>vi/vim</td><td>命令行文本编辑器。</td></tr><tr><td>文件压缩及解压缩命令（4个）</td><td></td></tr><tr><td>tar</td><td>打包压缩。oldboy</td></tr><tr><td>unzip</td><td>解压文件。</td></tr><tr><td>gzip</td><td>gzip压缩工具。</td></tr><tr><td>zip</td><td>压缩工具。</td></tr><tr><td>信息显示命令（11个）</td><td></td></tr><tr><td>uname</td><td>显示操作系统相关信息的命令。</td></tr><tr><td>hostname</td><td>显示或者设置当前系统的主机名。</td></tr><tr><td>dmesg</td><td>显示开机信息，用于诊断系统故障。</td></tr><tr><td>uptime</td><td>显示系统运行时间及负载。</td></tr><tr><td>stat</td><td>显示文件或文件系统的状态。</td></tr><tr><td>du</td><td>计算磁盘空间使用情况。</td></tr><tr><td>df</td><td>报告文件系统磁盘空间的使用情况。</td></tr><tr><td>top</td><td>实时显示系统资源使用情况。</td></tr><tr><td>free</td><td>查看系统内存。</td></tr><tr><td>date</td><td>显示与设置系统时间。</td></tr><tr><td>cal</td><td>查看日历等时间信息。</td></tr><tr><td>搜索文件命令（4个）</td><td></td></tr><tr><td>which</td><td>查找二进制命令，按环境变量PATH路径查找。</td></tr><tr><td>find</td><td>从磁盘遍历查找文件或目录。</td></tr><tr><td>whereis</td><td>查找二进制命令，按环境变量PATH路径查找。</td></tr><tr><td>locate</td><td>从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用updatedb更新库。</td></tr><tr><td>用户管理命令（10个）</td><td></td></tr><tr><td>useradd</td><td>添加用户。</td></tr><tr><td>usermod</td><td>修改系统已经存在的用户属性。</td></tr><tr><td>userdel</td><td>删除用户。</td></tr><tr><td>groupadd</td><td>添加用户组。</td></tr><tr><td>passwd</td><td>修改用户密码。</td></tr><tr><td>chage</td><td>修改用户密码有效期限。</td></tr><tr><td>id</td><td>查看用户的uid,gid及归属的用户组。</td></tr><tr><td>su</td><td>切换用户身份。</td></tr><tr><td>visudo</td><td>编辑/etc/sudoers文件的专属命令。</td></tr><tr><td>sudo</td><td>以另外一个用户身份（默认root用户）执行事先在sudoers文件允许的命令。</td></tr><tr><td>基础网络操作命令（11个）</td><td></td></tr><tr><td>telnet</td><td>使用TELNET协议远程登录。</td></tr><tr><td>ssh</td><td>使用SSH加密协议远程登录。</td></tr><tr><td>scp</td><td>全拼secure copy，用于不同主机之间复制文件。</td></tr><tr><td>wget</td><td>命令行下载文件。</td></tr><tr><td>ping</td><td>测试主机之间网络的连通性。</td></tr><tr><td>route</td><td>显示和设置linux系统的路由表。</td></tr><tr><td>ifconfig</td><td>查看、配置、启用或禁用网络接口的命令。</td></tr><tr><td>ifup</td><td>启动网卡。</td></tr><tr><td>ifdown</td><td>关闭网卡。</td></tr><tr><td>netstat</td><td>查看网络状态。</td></tr><tr><td>ss</td><td>查看网络状态。</td></tr><tr><td>深入网络操作命令（9个）</td><td></td></tr><tr><td>nmap</td><td>网络扫描命令。</td></tr><tr><td>lsof</td><td>全名list open files，也就是列举系统中已经被打开的文件。</td></tr><tr><td>mail</td><td>发送和接收邮件。</td></tr><tr><td>mutt</td><td>邮件管理命令。</td></tr><tr><td>nslookup</td><td>交互式查询互联网DNS服务器的命令。</td></tr><tr><td>dig</td><td>查找DNS解析过程。</td></tr><tr><td>host</td><td>查询DNS的命令。</td></tr><tr><td>traceroute</td><td>追踪数据传输路由状况。</td></tr><tr><td>tcpdump</td><td>命令行的抓包工具。</td></tr><tr><td>有关磁盘与文件系统的命令（16个）</td><td></td></tr><tr><td>mount</td><td>挂载文件系统。</td></tr><tr><td>umount</td><td>卸载文件系统。</td></tr><tr><td>fsck</td><td>检查并修复Linux文件系统。</td></tr><tr><td>dd</td><td>转换或复制文件。</td></tr><tr><td>dumpe2fs</td><td>导出ext2/ext3/ext4文件系统信息。</td></tr><tr><td>dump</td><td>ext2/3/4文件系统备份工具。</td></tr><tr><td>fdisk</td><td>磁盘分区命令，适用于2TB以下磁盘分区。</td></tr><tr><td>parted</td><td>磁盘分区命令，没有磁盘大小限制，常用于2TB以下磁盘分区。</td></tr><tr><td>mkfs</td><td>格式化创建Linux文件系统。</td></tr><tr><td>partprobe</td><td>更新内核的硬盘分区表信息。</td></tr><tr><td>e2fsck</td><td>检查ext2/ext3/ext4类型文件系统。</td></tr><tr><td>mkswap</td><td>创建Linux交换分区。</td></tr><tr><td>swapon</td><td>启用交换分区。</td></tr><tr><td>swapoff</td><td>关闭交换分区。</td></tr><tr><td>sync</td><td>将内存缓冲区内的数据写入磁盘。</td></tr><tr><td>resize2fs</td><td>调整ext2/ext3/ext4文件系统大小。</td></tr><tr><td>系统权限及用户授权相关命令（4个）</td><td></td></tr><tr><td>chmod</td><td>改变文件或目录权限。</td></tr><tr><td>chown</td><td>改变文件或目录的属主和属组。</td></tr><tr><td>chgrp</td><td>更改文件用户组。</td></tr><tr><td>umask</td><td>显示或设置权限掩码。</td></tr><tr><td>查看系统用户登陆信息的命令（7个）</td><td></td></tr><tr><td>whoami</td><td>显示当前有效的用户名称，相当于执行id -un命令。</td></tr><tr><td>who</td><td>显示目前登录系统的用户信息。</td></tr><tr><td>w</td><td>显示已经登陆系统的用户列表，并显示用户正在执行的指令。</td></tr><tr><td>last</td><td>显示登入系统的用户。</td></tr><tr><td>lastlog</td><td>显示系统中所有用户最近一次登录信息。</td></tr><tr><td>users</td><td>显示当前登录系统的所有用户的用户列表。</td></tr><tr><td>finger</td><td>查找并显示用户信息。</td></tr><tr><td>内置命令及其它（19个）</td><td></td></tr><tr><td>echo</td><td>打印变量，或直接输出指定的字符串</td></tr><tr><td>printf</td><td>将结果格式化输出到标准输出。</td></tr><tr><td>rpm</td><td>管理rpm包的命令。</td></tr><tr><td>yum</td><td>自动化简单化地管理rpm包的命令。</td></tr><tr><td>watch</td><td>周期性的执行给定的命令，并将命令的输出以全屏方式显示。</td></tr><tr><td>alias</td><td>设置系统别名。</td></tr><tr><td>unalias</td><td>取消系统别名。</td></tr><tr><td>date</td><td>查看或设置系统时间。</td></tr><tr><td>clear</td><td>清除屏幕，简称清屏。</td></tr><tr><td>history</td><td>查看命令执行的历史纪录。</td></tr><tr><td>eject</td><td>弹出光驱。</td></tr><tr><td>time</td><td>计算命令执行时间。</td></tr><tr><td>nc</td><td>功能强大的网络工具。</td></tr><tr><td>xargs</td><td>将标准输入转换成命令行参数。</td></tr><tr><td>exec</td><td>调用并执行指令的命令。</td></tr><tr><td>export</td><td>设置或者显示环境变量。</td></tr><tr><td>unset</td><td>删除变量或函数。</td></tr><tr><td>type</td><td>用于判断另外一个命令是否是内置命令。</td></tr><tr><td>bc</td><td>命令行科学计算器</td></tr><tr><td>系统管理与性能监视命令(9个)</td><td></td></tr><tr><td>chkconfig</td><td>管理Linux系统开机启动项。</td></tr><tr><td>vmstat</td><td>虚拟内存统计。</td></tr><tr><td>mpstat</td><td>显示各个可用CPU的状态统计。</td></tr><tr><td>iostat</td><td>统计系统IO。</td></tr><tr><td>sar</td><td>全面地获取系统的CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU中断和网络等性能数据。</td></tr><tr><td>ipcs</td><td>用于报告Linux中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。</td></tr><tr><td>ipcrm</td><td>用来删除一个或更多的消息队列、信号量集或者共享内存标识。</td></tr><tr><td>strace</td><td>用于诊断、调试Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</td></tr><tr><td>ltrace</td><td>命令会跟踪进程的库函数调用,它会显现出哪个库函数被调用。</td></tr><tr><td>关机/重启/注销和查看系统信息的命令（6个）</td><td></td></tr><tr><td>shutdown</td><td>关机。</td></tr><tr><td>halt</td><td>关机。</td></tr><tr><td>poweroff</td><td>关闭电源。</td></tr><tr><td>logout</td><td>退出当前登录的Shell。</td></tr><tr><td>exit</td><td>退出当前登录的Shell。</td></tr><tr><td>Ctrl+d</td><td>退出当前登录的Shell的快捷键。</td></tr><tr><td>进程管理相关命令（15个）</td><td></td></tr><tr><td>bg</td><td>将一个在后台暂停的命令，变成继续执行 （在后台执行）。</td></tr><tr><td>fg</td><td>将后台中的命令调至前台继续运行。</td></tr><tr><td>jobs</td><td>查看当前有多少在后台运行的命令。</td></tr><tr><td>kill</td><td>终止进程。</td></tr><tr><td>killall</td><td>通过进程名终止进程。</td></tr><tr><td>pkill</td><td>通过进程名终止进程。</td></tr><tr><td>crontab</td><td>定时任务命令。</td></tr><tr><td>ps</td><td>显示进程的快照。</td></tr><tr><td>pstree</td><td>树形显示进程。</td></tr><tr><td>nice/renice</td><td>调整程序运行的优先级。</td></tr><tr><td>nohup</td><td>忽略挂起信号运行指定的命令。</td></tr><tr><td>pgrep</td><td>查找匹配条件的进程。</td></tr><tr><td>runlevel</td><td>查看系统当前运行级别。</td></tr><tr><td>init</td><td>切换运行级别。</td></tr><tr><td>service</td><td>启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</td></tr></tbody></table><ul><li><p>查询端口监听情况</p><blockquote><p>netstat -lnp | grep 端口号</p></blockquote></li><li><p>查询java运行程序</p><blockquote><p>jps</p></blockquote></li><li><p>临时切换用户并执行命令</p><blockquote><p>su - esuser-c “/opt/elasticsearch-6.1.3/bin/elasticsearch -d”     # 切换esuser并启动elasticsearch</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> commond </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch在CentOS环境下开机启动</title>
      <link href="2020/11/24/elasticsearch-zai-centos-huan-jing-xia-kai-ji-qi-dong/"/>
      <url>2020/11/24/elasticsearch-zai-centos-huan-jing-xia-kai-ji-qi-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="elasticsearch在CentOS环境下开机启动"><a href="#elasticsearch在CentOS环境下开机启动" class="headerlink" title="elasticsearch在CentOS环境下开机启动"></a>elasticsearch在CentOS环境下开机启动</h1><h4 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h4><p>​        OS版本：CentOS-7-x86_64-Minimal-1708；ES版本：elasticsearch-7.4.0.</p><h4 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h4><ol><li><p>在/etc/init.d/目录创建es文件</p><pre class="line-numbers language-shell"><code class="language-shell">vi /etc/init.d/es<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件内容：</p><pre class="line-numbers language-shell"><code class="language-shell">#!/bin/bash##chkconfig: 345 63 37#description: elasticsearch#processname: elasticsearch-7.4.0ES_HOME=/usr/local//usr/local/elasticsearch-7.4.0case $1 in  start)    su - es_user -c "$ES_HOME/bin/elasticsearch -d -p pid"    echo "elasticsearch is started"    ;;  stop)    pid=`cat $ES_HOME/pid`    kill -9 $pid    echo "elasticsearch is stopped"    ;;  restart)    pid=`cat $ES_HOME/pid`    kill -9 $pid    echo "elasticsearch is stopped"    sleep 1    su - es_user -c "$ES_HOME/bin/elasticsearch -d -p pid"    echo "elasticsearch is started"    ;;  *)    echo "start|stop|restart"    ;;  esacexit 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><ol start="2"><li><p>修改上面文件的权限，执行命令</p><pre class="line-numbers language-shell"><code class="language-shell">chmod 777 /etc/init.d/es<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><ol start="3"><li><p>添加和删除服务并设置启动方式（chkconfig具体使用另行百度）</p><pre class="line-numbers language-shell"><code class="language-shell">chkconfig --add eschkconfig --del es<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><ol start="4"><li><p>启动和关闭服务</p><pre class="line-numbers language-shell"><code class="language-shell">service es start    // 启动服务service es stop     // 关闭服务service es restart  // 重启服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><ol start="5"><li><p>设置服务的启动方式</p><pre class="line-numbers language-shell"><code class="language-shell">chkconfig es on  // 设置开机启动chkconfig es off // 关闭开机启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用VS Code的REST客户端插件即可进行API调用</title>
      <link href="2020/11/22/restfull-request-tool-for-vscode/"/>
      <url>2020/11/22/restfull-request-tool-for-vscode/</url>
      
        <content type="html"><![CDATA[<p><strong>为什么要离开IDE去测试新的API？现在你不必这样做了。</strong></p><h2 id="我们如何获取数据"><a href="#我们如何获取数据" class="headerlink" title="我们如何获取数据"></a>我们如何获取数据</h2><p>如果你已经做了很长时间的Web开发，你可能知道我们的很多工作都是围绕着数据展开的：读取数据、写入数据、操作数据，并以合理的方式在浏览器中显示出来。</p><p>而这些数据绝大部分都是由REST API端点提供的，通俗地说：我们想要的数据存在于其他服务或数据库中，我们的应用程序查询该服务来检索数据，并根据自己的需要使用数据。</p><p>在过去，为了在连接UI以接受数据之前测试REST API，通常必须通过终端的命令行查询API，或者使用像Insomnia或Postman这样的GUI(我在之前的博客中对它们进行了比较)。</p><p>但现在，如果你使用VS Code（为什么不呢，用它写代码多好啊！），生活就变得简单了。我们不再需要退出IDE来测试API，因为现在已经有一个插件可以做到这一点：<a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">REST Client</a>。</p><p>使用REST Client是非常简单的，我将向您展示这个插件是多么简单，而且功能齐全。</p><h2 id="认识VS-Code-REST-Client插件"><a href="#认识VS-Code-REST-Client插件" class="headerlink" title="认识VS Code REST Client插件"></a>认识VS Code REST Client插件</h2><p>我是VS Code这个代码编辑器的粉丝，已经有好几年了，每次得知有人创建了一个新的有用的插件并添加到VS Code市场，我都会无比感激。</p><p>所以当我决定每次需要测试一个新的API路由时，都要启动Postman或Insomnia是一件很痛苦的事情，我发现了REST Client 这个插件，可以让这一切变得不必要。</p><p>REST Client是迄今存在的工具的最明显名称，其VS Code市场描述准确地概括了其功能：“REST Client允许您发送HTTP请求并直接在Visual Studio Code中查看响应。”</p><p>就这么简单。然后，它会提供大量的详细信息以及使用方法的示例，但实际上，它是VS Code中内置的HTTP工具。因此，让我们开始使用它。</p><h3 id="安装REST-Client"><a href="#安装REST-Client" class="headerlink" title="安装REST Client"></a>安装REST Client</h3><p>要找到它，打开VS Code中的市场扩展（左侧面板上的俄罗斯方块小图标），在搜索栏中输入 “rest client”，然后安装列表中的第一个结果（作者应该是Huachao Mao）。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b33d9065a224205a79e67822e49de5e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>安装完成后，我们可以继续进行设置。</p><h3 id="设置REST-Client脚本"><a href="#设置REST-Client脚本" class="headerlink" title="设置REST Client脚本"></a>设置REST Client脚本</h3><p>只需在项目的根目录下创建一个以 <code>.http</code> 结尾的文件，REST Client可以识别出这一点，并且知道它应该能够运行来自该文件的HTTP请求。</p><p>在测试的时候，我把几年前做的一个docker化的全栈MERN登录应用，把一个我命名为 <code>test.http</code> 的文件丢到项目文件夹的根目录。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b88b62e037544f29bbdb0c17ac74fae3~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><h2 id="测试一下：基本操作"><a href="#测试一下：基本操作" class="headerlink" title="测试一下：基本操作"></a>测试一下：基本操作</h2><p>这是很酷的部分：在我的经验中，这个小小的REST Client插件能够做的事情和Postman等更复杂的API客户端一样多。</p><p>下面，我将向你展示如何进行每一种类型的基本CRUD操作，再加上如何像JWT令牌一样进行需要认证的API调用，使用我在本地运行的MERN用户注册应用来指向调用。</p><h3 id="POST示例"><a href="#POST示例" class="headerlink" title="POST示例"></a>POST示例</h3><p>我将介绍的第一个示例是REST Client的 <code>POST</code>，因为用户在我的应用程序中必须先注册才能进行其他任何操作（毕竟，这只是一个登录服务）。</p><p>因此，该代码将在 <code>test.http</code> 文件中显示。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5b2eb13d003451aa4e8a0031d636898~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>好的，让我们回顾一下上面的代码片段中发生的事情。</p><p>REST Client为了正常工作所需要的第一件事是发出请求的类型及其尝试访问的路由的完整URL路径。在这种情况下，请求是POST，URL是 <code>http://localhost:3003/registerUser</code>。第一行末尾的 <code>HTTP/1.1</code> 与RFC 2616建立的标准有关，但是我不确定是否有必要，因此我将其保留只是为了安全。</p><p>然后，因为这是一个 <code>POST</code>，所以在请求中要包含一个JSON体，注意 <code>Content-Type</code> 和 <code>body</code> 之间有一行空行——这是REST Client有意要求的。所以，我们把所需的字段填好，然后，在 <code>POST</code> 上面应该会出现一个小小的 <code>send Request</code> 选项。把鼠标放在上面，然后点击，看看会有什么结果。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38251f08b2c64f608da4a69a6547042e~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>您最后要注意的是 <code>test.http</code> 文件中请求后的 <code>###</code> ，这是请求之间的分隔符，只要在每个请求之间插入 <code>###</code> 就可以在文件中包含任意数量的请求。</p><p>如果请求成功，您将看到与我上面发布的内容类似的内容。即使请求不成功，你仍然会得到所有这些关于刚才发生的信息，以及（希望）出了什么问题。爽啊</p><h3 id="GET示例"><a href="#GET示例" class="headerlink" title="GET示例"></a>GET示例</h3><p>现在已经创建了一个用户，比方说我们忘记了他们的密码，他们发了一封邮件来找回密码。电子邮件中包含令牌和链接，该链接会将他们带到页面以重置密码。</p><p>一旦他们点击了链接并登陆页面，一个 <code>GET</code> 请求就会被启动，以确保邮件中包含的用于重置密码的令牌是有效的，这就是它可能的样子。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7568ce65c5cb45c9959e27955af2d5a8~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>我的 <code>GET</code> 指向了 <code>/reset</code> 端点，并在服务端附加了验证所需的 <code>resetPasswordToken</code> 查询参数。<code>Content-Type</code> 仍为 <code>application/json</code>，底部的 <code>###</code> 将此请求与文件中的任何其他请求分开。</p><p>如果令牌确实有效，则服务器的响应如下所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96614ed1e8d2465caa6c139d2b999e48~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>而这就是GET请求所需要的全部内容，他们不用担心请求体的问题。</p><h3 id="Update示例"><a href="#Update示例" class="headerlink" title="Update示例"></a>Update示例</h3><p>接下来是CRUD中的U：更新。假设用户想更新其个人资料信息中的某些内容。使用REST Client也不难。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e19cfa68a234413b10b0f7dfc1e3b51~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>对于这个请求，请求类型更新为 <code>PUT</code>，body包括该对象上需要更新的任何字段。在我的应用程序中，用户可以更新其名字，姓氏或电子邮件。</p><p>因此，在传递正文时，如果REST Client成功击中PUT端点，则这就是VS Code中的Response选项卡的样子。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1edf960fc2ea44c194070d20b1ff8d8c~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>到此为止，让我们继续进行身份验证示例。因为据我所知，没有保护路由的应用程序很少，需要某种认证。</p><h3 id="Authentication示例"><a href="#Authentication示例" class="headerlink" title="Authentication示例"></a>Authentication示例</h3><p>REST Client支持的不同身份验证格式的广度再一次让我印象深刻。在撰写本文时，REST Client的文档说它支持六种流行的身份验证类型，包括对JWT身份验证的支持，这是我的应用程序在所有受保护的路由上都依赖的身份验证类型。</p><p>因此，事不宜迟，这里是我需要验证的端点之一：在数据库中查找用户的信息。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d7928f47cfd4977933702d1df64f77c~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>在REST Client请求中添加授权真的很简单：简单地在路由和 content-type 被声明的地方下面添加键 <code>Authorization</code>，然后（至少对我的情况而言）我添加JWT的键和值（因为它们出现在浏览器的本地存储中）作为 <code>Authorization</code> 头的值。</p><p>这样就变成了：</p><pre><code>Authorization: jwt XXXXXXXXXXXXXXXXXX复制代码</code></pre><p>然后只需发送请求，看看会发生什么。</p><p>如果您的身份验证配置正确，您将收到来自服务器的某种类型的200响应，对于我的请求，它将返回存储在数据库中的与该用户相关的所有信息，以及一个成功找到该用户的消息。</p><p>这部分可能需要一些尝试和错误，但如果您能够弄清楚一个成功的请求是如何在浏览器的Dev Tools网络调用中发出的，通过现有的Swagger端点，或者通过其他类似的文档，这是非常值得的。</p><h3 id="DELETE示例"><a href="#DELETE示例" class="headerlink" title="DELETE示例"></a>DELETE示例</h3><p>经过我上面提供的其他例子，这个示例应该很简单</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0df2e36815f412eab2492cacb67458b~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p><p>这个 <code>DELETE</code> 需要的查询参数是 <code>username</code>，这样它就知道到底要删除数据库中的哪个用户，而且还需要验证这个用户是否有资格提出这个请求。除此以外，这里就没有什么其他的新东西可以介绍了。</p><p>![img](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>)</p><p>这实际上只是REST Client可以做的冰山一角。我涵盖了REST请求和一种形式的认证，但它也可以支持GraphQL请求、多种其他类型的认证、环境和自定义变量、查看和保存原始响应等等。</p><p>我强烈建议您查阅文档，以了解REST Client的所有功能，它非常强大。</p><blockquote><p>REST Client文档：<a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client">https://marketplace.visualstudio.com/items?itemName=humao.rest-client</a></p></blockquote><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>数据驱动着互联网，而随着职业生涯的进一步发展，Web开发人员最终会变得非常善于访问和转换数据以满足自己的需求。</p><p>以前，当获取托管在其他地方的数据时，Web开发人员经常会求助于Postman或Insomnia这样的工具，以拥有比命令行稍微好一点的界面，但现在有一个VS Code插件，它让代码编辑器之外的需求成为了过去，它叫REST Client，非常棒。</p><p>CRUD操作？没问题！支持GraphQL？没问题！认证选项？没问题！REST Client提供了所有这些选项以及更多，而且设置和使用起来非常简单。我肯定会在以后的项目中更多地使用它。</p><p>请过几周再回来看看——我将写更多有关JavaScript，React，ES6或其他与Web开发相关的内容。</p><p>谢谢你的阅读。我希望你能考虑用REST Client来处理你未来可能需要做的任何API查询，我想你会对它能提供的愉快体验感到惊喜，不需要任何API GUI。 🙂</p><p>作者：杭州程序员张张<br>链接：<a href="https://juejin.cn/post/6897863358964629511">https://juejin.cn/post/6897863358964629511</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> restfull </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支管理策略方案分析与总结</title>
      <link href="2020/11/22/git-branch-manage-summary/"/>
      <url>2020/11/22/git-branch-manage-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着Git的流行，越来越多的团队在往Git迁移或者转型，在团队建设初期或者中期转型优化，合适的Git分支管理策略方案能够较好的提高团队的效率，节约人员成本，降低代码版本管理带来的风险。笔者曾经历过因为分支管理策略不合适、人员操作不规范引发的代码版本混乱、线上版本与生产版本不一致等问题。本文旨在对几种Git分支管理策略进行梳理总结，对适用场景做探讨分析。同时非常渴望各位提出指正问题，共同沟通探讨更适用的解决方案。</p><h2 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h2><p>本文将通过对Git Flow、GitHub Flow、GitLab Flow三种流行的工作流程模型进行分析，总结各模型的优缺点与适用场景</p><h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3d29949272d429c9bf2625cb8d55903~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>Git Flow模型声明了以下5个分支：</p><ul><li>Master<br> 与生产保持一致，同时也是发布的分支（需要严格控制合并权限）</li><li>Develop<br> 基于Master检出的开发分支，保持最新开发进度的稳定分支（需要控制合并权限）</li><li>Feature Branch<br> 基于Develop检出特性分支，用于功能开发的分支，完成功能开发后合并到Develop分支</li><li>Release Branch<br> 基于Develop分支检出的预发布分支，用与预发布测试，测试完成后合并到Develop，合并到Master发布，合并时需要标记版本Tag，用于区分历史版本，合并完成后删除</li><li>Hotfix Branch<br> 基于Master检出的热点分支，用于修复生产bug，修复完成后合并到Develop，合并到Master发布，标记版本Tag</li></ul><h3 id="开发流程简述"><a href="#开发流程简述" class="headerlink" title="开发流程简述"></a>开发流程简述</h3><p>单个需求开发：</p><ol><li>默认存在Master，Develop分支，在工程初始化阶段基于Master检出Develop（前置工作）</li><li>此时开发人员收到需求需要开发A功能，从Develop检出Feature—A用于A功能的开发</li><li>A功能开发完成，将Feature—A分支合并到Develop分支，并进行初步的测试</li><li>从Develop检出Release-A分支用于测试，用于回归测试，并且修复bug</li><li>将测试好的Release-A分支合并Develop，合并到Master发布，并打上版本标签</li><li>当生产出现bug时，从master检出Hotfix-fixbug分支修复bug，修复后合并到Develop，合并到Master发布，并打上版本标签</li></ol><p>多个需求并行开发：<br> 与单个需求开发的步骤基本一致，但要在合适的时间将Develop再合并到特性分支，避免多个版本交叉影响的风险（比如A功能的修改，对B功能的修改也有影响，此时应在A合并Develop后，主动将Develop合并到Feature—A，如果有问题，提早暴露解决）</p><h3 id="特殊场景分析"><a href="#特殊场景分析" class="headerlink" title="特殊场景分析"></a>特殊场景分析</h3><p>场景1：计划功能A与功能B在某个时间点要同时上线，并且已经合并Feature—A、Feature—B到了Develop，将要检出Release分支进行测试，但此时收到通知，只上功能A不上功能B，此时Develop却包含了Feature—B的代码<br> 解决方案：回滚Develop到上一版本，重新合并Feature—A到Develop</p><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>优点:</p><ul><li>功能分支独立，互不干扰，可以独立开发、测试</li><li>当Feature分支较长的时候，可以避免提前进Release</li><li>具备多个版本发布的能力</li></ul><p>缺点:</p><ul><li>模型相对复杂,维护了Master，Develop两个基准分支,当回归或者生产出现bug时，合并Master的同时合并回Develop，对开发人员要求较高,开发人员容易搞错导致Develop分支跟Master不一致</li><li>并行的feature分支太多时，代码冲突的可能性增加</li><li>当多个需求并行开发，如上特殊场景1情况，会造成分支污染</li></ul><h2 id="GitHub-Flow"><a href="#GitHub-Flow" class="headerlink" title="GitHub Flow"></a>GitHub Flow</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d31b628131f249c2b593b46f4d5f86c7~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h3 id="开发流程简述-1"><a href="#开发流程简述-1" class="headerlink" title="开发流程简述"></a>开发流程简述</h3><ol><li>默认存在master分支，与生产保持一致（GitHub Flow模型默认分支的更新与产品的发布是一致）</li><li>开发需求A，基于master检出分支A</li><li>A需求开发完成，提交合并到master的合并请求</li><li>评审合并代码，处理合并请求（未处理前还可以持续提交）</li><li>发布master 多个需求并行开发： 也与单个需求的开发一致，只是需要在master解决冲突，有可能多个需求分支合并到master后需要进行回归测试</li></ol><h3 id="特殊场景分析-1"><a href="#特殊场景分析-1" class="headerlink" title="特殊场景分析"></a>特殊场景分析</h3><p>场景2：当A分支开发完成后，合并到master，但此时由于各种原因未能发布到生产，此时会导致生产环境与master的代码不一致<br> 解决方案：从master创建一个product分支，只有在master代码发布成功后才合并product 场景3：在多个需求并行开发的场景下，需要并行去测试这些功能分支，假设我以功能分支作为测试分支提供给测试团队，那可能需要具备多套测试环境，假设以master作为测试分支，会受到其他合并到master分支的污染</p><p>解决方案：控制质量，提高master准入标准</p><h3 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>优点：操作简单，可以持续发布</p><p>缺点：对于测试来说不那么友好</p><h2 id="GitLab-Flow"><a href="#GitLab-Flow" class="headerlink" title="GitLab Flow"></a>GitLab Flow</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7691aeb52524ae282bb2e0eb1650d01~tplv-k3u1fbpfcp-watermark.image" alt="img"> 图1 ![img](data:image/svg+xml;utf8,<!--?xml version="1.0"?--><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"></svg>) 图2</p><h3 id="开发流程简述-2"><a href="#开发流程简述-2" class="headerlink" title="开发流程简述"></a>开发流程简述</h3><ol><li>GitLab Flow 开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展，如上面第一张图，最上游的MASTER作为开发分支，只有在开发分支完成，达到提交下一阶段的准入条件才能合并到PRE-PRODUCTION</li><li>项目持续发布，假设某一个迭代版本开始，从生产分支检出Dev分支，后续从上游DEV经过测试验收达到准入要求后向下游SIT、UAT、PRE-PRODUCTION合并，最后发布，合并到PRODUCTION</li><li>项目版本发布，如上图2，从master检出版本分支，并更新小版本后，持续维护这些版本分支。</li></ol><h3 id="特殊场景分析-2"><a href="#特殊场景分析-2" class="headerlink" title="特殊场景分析"></a>特殊场景分析</h3><p>场景4 :假设某功能分支流转到中间节点比如说UAT，但此时某些需求代码临时决定不上了，可能会污染UAT的代码</p><p>解决方案：回滚此代码，尽量保持中游分支的整洁</p><h3 id="优缺点分析-2"><a href="#优缺点分析-2" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><p>优点：</p><ul><li>方案同时兼顾了“版本发布”、“持续发布”</li><li>能够对各环境版本有较好的区分，对测试团队支持较好 缺点：存在中游分支被污染的风险</li></ul><h2 id="基于GitLab-Flow的研发工作流程图解"><a href="#基于GitLab-Flow的研发工作流程图解" class="headerlink" title="基于GitLab Flow的研发工作流程图解"></a>基于GitLab Flow的研发工作流程图解</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25a397b79a4c4f02bf878bdd5b65c652~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Git分支管理策略方案，要根据团队特性尽量选择复杂度低的方案，例如：在并行需求较少，不需要基于版本发布的团队，可以选择GitHub FLow模型；对测试环境要求较强可以选择GitLab Flow模型；在大型团队，开发人员技术水平较高，控制非常严格的情况下，可以参考Git FLow。在方案确定的过程中，不要只是套用模型，而是在模型的基础上，根据团队特性制定更简单、高效、风险系数低的方案。 本文分析与总结了三种Git分支管理策略，希望对大家在选择与指定版本管理方案时有所启发。</p><p>作者：sleeper<br>链接：<a href="https://juejin.cn/post/6897071017919774728">https://juejin.cn/post/6897071017919774728</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-stash</title>
      <link href="2020/11/22/git-stash/"/>
      <url>2020/11/22/git-stash/</url>
      
        <content type="html"><![CDATA[<h1 id="Git实用技巧：git-stash"><a href="#Git实用技巧：git-stash" class="headerlink" title="Git实用技巧：git stash"></a>Git实用技巧：git stash</h1><p>我们经常会遇到这样的情况：</p><blockquote><p>正在<strong>dev</strong>分支开发新功能，做到一半时有人过来反馈一个<strong>bug</strong>，让马上解决，但是新功能做到了一半你又不想提交，这时就可以使用<code>git stash</code>命令先把当前进度保存起来。然后切换到另一个分支去修改<strong>bug</strong>，修改完提交后，再切回<strong>dev</strong>分支，使用<code>git stash pop</code>来恢复之前的进度继续开发新功能。</p></blockquote><h3 id="1-stash当前修改"><a href="#1-stash当前修改" class="headerlink" title="1. stash当前修改"></a>1. stash当前修改</h3><ul><li><code>git stash</code>：<br>保存当前工作进度，会把暂存区和工作区的改动保存起来。执行完这个命令后，在运行<code>git status</code>命令，就会发现当前是一个干净的工作区，没有任何改动。</li></ul><ol><li><code>stash</code>是本地的，不会上传到服务器上；</li><li>使用<code>git stash save 'message...'</code>可以添加一些注释。</li></ol><h3 id="2-查看现有stash"><a href="#2-查看现有stash" class="headerlink" title="2. 查看现有stash"></a>2. 查看现有<code>stash</code></h3><ul><li><code>git stash list</code>：<br>显示保存进度的列表。也就意味着，<code>git stash</code>命令可以多次执行。</li><li><code>git stash show</code> ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}</li></ul><h3 id="3-重新应用缓存的stash"><a href="#3-重新应用缓存的stash" class="headerlink" title="3. 重新应用缓存的stash"></a>3. 重新应用缓存的<code>stash</code></h3><ul><li><code>git stash pop [–index] [stash_id]</code>：<br>恢复之前缓存的工作目录。</li></ul><ol><li><code>git stash pop</code>：恢复最新的进度到工作区。<code>git</code>默认会把工作区和暂存区的改动都恢复到工作区,同时删除该进度；</li><li><code>git stash pop stash@[stash_id]</code>：恢复指定的进度到工作区,如：<code>git stash pop stash@{1}</code>。<code>stash_id</code>是通过<code>git stash list</code>命令得到的；</li><li>通过<code>git stash pop</code>命令恢复进度后，会删除当前进度；</li><li><code>git stash apply stash@{1}</code>：恢复进度后，不会删除当前进度，默认使用最近的stash（即<code>stash@{0}</code>）。</li></ol><h3 id="4-移除stash"><a href="#4-移除stash" class="headerlink" title="4. 移除stash"></a>4. 移除<code>stash</code></h3><ul><li><code>git stash drop [stash_id]</code>：<br>删除一个存储的进度,如：<code>git stash drop stash@{0}</code></li></ul><ol><li>如果不指定<code>stash_id</code>：，则默认删除最新的存储进度；</li><li><code>git stash clear</code>：删除所有存储的进度。</li></ol>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> develop </tag>
            
            <tag> stash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx全能解析及性能调优</title>
      <link href="2020/11/18/nginx-quan-neng-jie-xi-ji-xing-neng-diao-you/"/>
      <url>2020/11/18/nginx-quan-neng-jie-xi-ji-xing-neng-diao-you/</url>
      
        <content type="html"><![CDATA[<blockquote><p>nginx 是一个轻量级的、基于http的、高性能的反向代理的服务器和静态web服务器。</p></blockquote><h1 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h1><blockquote><p>不管是正向代理还是反向代理都是基于客户端来说的。</p></blockquote><ul><li>正向代理<ul><li>特点<ul><li>正向代理是对客户端的代理</li><li>正向代理是架设在客户端的主机</li><li>客户端在使用正向代理服务器时是要知道访问的目标服务的地址</li></ul></li><li>案例<ul><li>隐藏真正的访问者<ul><li>向服务端隐藏真正的访问者。对于服务端来说，真正的访问者时代理服务器。起到了隐藏客户端的作用。例如：实际生活中的短信轰炸，你根本不知道是谁给你发的短信；ddos攻击也是这个原理，使用很多‘肉鸡’机器来攻击我们的服务器，我们无法查找真正的攻击源。</li></ul></li><li>翻墙<ul><li>由于很多复杂的原因，导致服务器A不能直接访问服务器B，但是服务器C可以访问服务器B，而服务器A又可以访问服务器C；这时，服务器C作为服务起A的代理服务器对B进行访问。目前的翻墙软件就是使用这个原理。</li></ul></li><li>提速<ul><li>同上原理一样，服务器A访问服务器B速度过慢，而服务器C访问服务器B很快，服务器A访问服务器C很快。则使用代理服务器提高效率。</li></ul></li><li>缓存<ul><li>增加客户端缓存，减少对服务器的请求资源的压力。例如maven的nexus就是一个典型的客户端缓存例子。</li></ul></li><li>授权<ul><li>例如，在公司中，需要对员工电脑进行外网监控授权，则也是使用这种客户端正向代理服务器。</li></ul></li></ul></li></ul></li><li>反向代理<ul><li>特点<ul><li>反向代理是对服务端的代理</li><li>反向代理是架设在服务端的主机</li><li>客户端端访问的时候不知道真正服务主机的地址</li></ul></li><li>案例<ul><li>保护隐藏真正的服务<ul><li>客户端只能访问服务端代理服务器，而真正的服务端是不能直接访问的，保护了服务端。</li></ul></li><li>分布式路由<ul><li>根据客户端不同的请求，将请求路由到不同的服务端去。</li></ul></li><li>负载均衡<ul><li>服务端均摊客户端的请求，保证服务端的高可用。</li></ul></li><li>动静分离<ul><li>例如图片、静态页面、css、js等，都为静态资源，将其放到对应目录下，客户端加载静态资源时，就不会请求到服务端，而只会将动态资源的请求发送到服务端，减轻服务端的压力。</li></ul></li><li>数据缓存<ul><li>反向代理同正向代理一样具有数据缓存的功能，都是为了减少服务端的压力。</li></ul></li></ul></li></ul></li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><blockquote><p>1、nginx的负载均衡策略有两种：内置策略和扩展策略</p></blockquote><blockquote><p>2、内置策略：轮询、权重轮询、IP hash、least_conn</p></blockquote><blockquote><p>3、扩展策略：自己想怎么实现就怎么实现</p></blockquote><table><thead><tr><th>轮询</th><th>默认方式</th></tr></thead><tbody><tr><td>权重（weight）</td><td>权重方式</td></tr><tr><td>ip_hash</td><td>根据IP分配方式</td></tr><tr><td>least_conn</td><td>最少连接方式</td></tr><tr><td>fair（第三方）</td><td>响应时间方式</td></tr><tr><td>url_hash（第三方）</td><td>根据URL分配方式</td></tr></tbody></table><p><strong>轮询</strong></p><blockquote><p>轮询是upstream默认的负载均衡策略，每个请求会按时间顺序逐一分配到不同的服务器</p></blockquote><p>参数如下：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>fail_timeout</td><td>与max_fail结合使用</td></tr><tr><td>max_fails</td><td>设置在fail_timeout设置的时间内的最大失败数</td></tr><tr><td>fail_time</td><td>服务器会被认为停机的时间长度，默认10s</td></tr><tr><td>backup</td><td>标记该服务器是备用服务器。当主服务器停止时，请求才会发到</td></tr><tr><td>down</td><td>标记服务器永久停机了</td></tr></tbody></table><p>例子：</p><pre class="line-numbers language-shell"><code class="language-shell">#动态服务器组upstream dynamic_zuoyu {    server localhost:8080;  #tomcat 7.0    server localhost:8081;  #tomcat 8.0    server localhost:8082 backup;  #tomcat 8.5    server localhost:8083 max_fails=3 fail_timeout=20s;  #tomcat 9.0}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：此策略适合服务器配置相当，无状态且短平快的服务使用</p><p><strong>权重</strong></p><blockquote><p>权重的方式，是在轮询基础上制定轮询的几率；权重分配越高，需要处理的请求越多；此策略也可和ip_hash、least_conn结合使用。</p></blockquote><p>例子：</p><pre class="line-numbers language-shell"><code class="language-shell">#动态服务器组upstream dynamic_zuoyu {    server localhost:8080 weight=2;  #tomcat 7.0    server localhost:8081;  #tomcat 8.0    server localhost:8082 backup;  #tomcat 8.5    server localhost:8083 max_fails=3 fail_timeout=20s;  #tomcat 9.0}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：此策略适合服务器硬件配置差异比较大时使用</p><p><strong>ip_hash</strong></p><blockquote><p>ip哈希的方式，基于客户端IP来分配，确保统一IP地址的客户端请求都到同一台服务器，保证session会话。可以解决session不能跨域的问题</p></blockquote><p>例子：</p><pre class="line-numbers language-shell"><code class="language-shell">#动态服务器组upstream dynamic_zuoyu {    ip_hash;    #保证每个访客固定访问一个后端服务器    server localhost:8080 weight=2;  #tomcat 7.0    server localhost:8081;  #tomcat 8.0    server localhost:8082;  #tomcat 8.5    server localhost:8083 max_fails=3 fail_timeout=20s;  #tomcat 9.0}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：此策略适合服务器解决session不能跨域的问题时使用</p><p><strong>least_conn</strong></p><blockquote><p>最少连接方式，将请求转发给连接数较少的服务端。由于轮询的方式是平均将请求转发给各个服务器，使得负载大致相同。但是也存在其中某些请求的链路过长，占用时间长，导致某一些服务器的负载较高。所以最少连接的方式可以平衡轮询会出现的这种问题</p></blockquote><p>例子：</p><pre class="line-numbers language-shell"><code class="language-shell">#动态服务器组 upstream dynamic_zuoyu {     least_conn;    #把请求转发给连接数较少的后端服务器     server localhost:8080   weight=2;  #tomcat 7.0     server localhost:8081;  #tomcat 8.0     server localhost:8082 backup;  #tomcat 8.5     server localhost:8083   max_fails=3 fail_timeout=20s;  #tomcat 9.0 }复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：此策略适合请求时间长短不一造成服务器负载的情况时使用</p><p><strong>fair（第三方，需要单独安装插件）</strong></p><blockquote><p>按照服务器的响应时间来分配请求，响应时间短的服务器优先分配（能者多劳）</p></blockquote><p>例子：</p><pre class="line-numbers language-shell"><code class="language-shell">#动态服务器组upstream dynamic_zuoyu {    server localhost:8080;  #tomcat 7.0    server localhost:8081;  #tomcat 8.0    server localhost:8082;  #tomcat 8.5    server localhost:8083;  #tomcat 9.0    fair;    #实现响应时间短的优先分配}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>url_hash（第三方，需要单独安装插件）</strong></p><blockquote><p>按照url哈希来分配请求到服务器，使得相同的url每次到的服务器一致，这样也可以减轻对服务器的压力（配合缓存命中来使用）</p></blockquote><p>例子：</p><pre class="line-numbers language-shell"><code class="language-shell">#动态服务器组upstream dynamic_zuoyu {    hash $request_uri;    #实现每个url定向到同一个后端服务器    server localhost:8080;  #tomcat 7.0    server localhost:8081;  #tomcat 8.0    server localhost:8082;  #tomcat 8.5    server localhost:8083;  #tomcat 9.0}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：此策略适合同一个资源多次请求的情况时使用</p><h2 id="静态web服务器"><a href="#静态web服务器" class="headerlink" title="静态web服务器"></a>静态web服务器</h2><ul><li>前后端分离</li></ul><pre class="line-numbers language-shell"><code class="language-shell">location / {    root   /data/paibo_web_8081_css; #前端代码存放路径    index  index.html index.htm;}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>静态资源（文件、图片等）</li></ul><pre class="line-numbers language-shell"><code class="language-shell">location /upfile/ {    root /home/audit_files/; #文件存放路径    index index.html;}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Nginx的下载与安装"><a href="#Nginx的下载与安装" class="headerlink" title="Nginx的下载与安装"></a>Nginx的下载与安装</h1><pre class="line-numbers language-shell"><code class="language-shell">#下载gcc编译器yum -y install gcc gcc-c++#下载PCREyum -y install pcre-devel openssl-devel#下载nginx，官方网站是 http://nginx.org ，自己找到需要的版本，右键复制下载链接wget http://nginx.org/download/nginx-1.19.2.tar.gz#解压tar -zxvf nginx-1.19.2.tar.gz#生成makefile。使用./configure --help查看各个模块的使用情况，使用--without-http_ssi_module的方式关闭不需要的模块。可以使用--with-http_perl_modules方式安装需要的模块cd nginx-1.19.2./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module #编译安装make && make install#进入到安装目录cd /usr/local/nginx/#将 /usr/local/nginx/sbin/nginx 软连接到 /usr/local/sbin 下，就可以在任意地方使用nginx命令ln -s /usr/local/nginx/sbin/nginx /usr/local/sbin/#修改配置文件vim /usr/local/nginx/conf/nginx.conf#测试nginx配置文件是否正常nginx -t#启动nginxnginx#关闭防火墙systemctl stop firewalldsystemctl disable firewalld#外部访问，nginx默认监听80端口192.168.198.98:80#重新载入配置文件nginx -s reload#重启nginxnginx -s reopen#停止nginxnginx -s stop复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Nginx-Keepalived实现高可用"><a href="#Nginx-Keepalived实现高可用" class="headerlink" title="Nginx+Keepalived实现高可用"></a>Nginx+Keepalived实现高可用</h2><pre class="line-numbers language-shell"><code class="language-shell">#在两台服务器安装nginx，参考<Nginx的下载与安装>#我这里用的是下面两台服务器，为了区分，做了以下修改192.168.198.6 #编辑index.html，<h1>Welcome to nginx! 2</h1>192.168.198.98 #编辑index.html，<h1>Welcome to nginx! 1</h1>#两台服务器都需要执行以下操作#下载keepalived安装包cd /data/soft/wget https://www.keepalived.org/software/keepalived-2.1.0.tar.gz#解压安装包tar -zxvf keepalived-2.1.0.tar.gz#编译安装cd keepalived-2.1.0./configure --prefix=/usr/local/keepalivedmake && make install#keepalived启动脚本变量引用文件，默认文件路径是/etc/sysconfig/，也可以不做软链接，直接修改启动脚本中文件路径即可（安装目录下）cp /usr/local/keepalived/etc/sysconfig/keepalived  /etc/sysconfig/keepalived#将keepalived主程序加入到环境变量（安装目录下）cp /usr/local/keepalived/sbin/keepalived /usr/sbin/keepalived#keepalived启动脚本（源码目录下），放到/etc/init.d/目录下就可以使用service命令便捷调用cp /data/soft/keepalived-2.1.0/keepalived/etc/init.d/keepalived  /etc/init.d/keepalived#将配置文件放到默认路径下mkdir /etc/keepalivedcp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf#加为系统服务chkconfig –add keepalived#开机启动chkconfig keepalived on#查看开机启动的服务chkconfig –list#启动、关闭、重启service keepalived start|stop|restart######################### 至此，安装完成；以下就是在keepalived.conf做HA的配置 #########################vim /etc/keepalived/keepalived.conf##### master #####! Configuration File for keepalived# 全局定义块global_defs {   router_id redis-rocketMQ     #标志本节点的字符串，建议使用hostname}# keepalived 会定时执行脚本并对脚本执行的结果进行分析，动态调整 vrrp_instance 的优先级。如果脚本执行结果为 0，并且 weight 配置的值大于 0，则优先级相应>的增加。如果脚本执行结果非 0，并且 weight配置的值小于 0，则优先级相应的减少。其他情况，维持原本配置的优先级，即配置文件中 priority 对应的值。vrrp_script chk_nginx {    script "/etc/keepalived/nginx_check.sh"     #检测 nginx 状态的脚本路径    interval 2                                  #检测时间间隔    weight -20                                  #如果条件成立，权重-20}# 定义虚拟路由，VI_1 为虚拟路由的标示符，自己定义名称vrrp_instance VI_1 {    state MASTER                #主节点为MASTER，备用节点为BACKUP    interface eno16777736       #与本机网卡名称一致    virtual_router_id 51        #虚拟路由的id号，两个节点必须设置一样    mcast_src_ip 192.168.198.98    priority 100                #设置优先级，值范围 0~254，master要比backup高    nopreempt                   #优先级高的设置 nopreempt 解决异常恢复后再次抢占的问题    advert_int 1                #组播信息发送间隔，节点必须设置一致    authentication {            #设置验证信息，节点必须设置一致        auth_type PASS        auth_pass 1111    }    #将 track_script 块加入 instance 配置块    track_script {        chk_nginx               #执行 Nginx 监控的服务    }    virtual_ipaddress {         #虚拟节点池，节点必须设置一样        192.168.198.111         #虚拟ip，可设置多个    }}##### backup #####! Configuration File for keepalivedglobal_defs {   router_id zk_alone}vrrp_script chk_nginx {    script "/etc/keepalived/nginx_check.sh"    interval 2    weight -20}vrrp_instance VI_1 {    state BACKUP    interface eno16777736    virtual_router_id 51    mcast_src_ip 192.168.198.6    priority 90    advert_int 1    authentication {        auth_type PASS        auth_pass 1111    }    track_script {        chk_nginx    }    virtual_ipaddress {        192.168.198.111    }}#编写 Nginx 状态检测脚本#ps -C nginx | wc -l，查看当前有多少个nginx进程#逻辑：如果 nginx 停止运行，尝试启动，如果无法启动则杀死本机的 keepalived 进程， keepalied将虚拟 ip 绑定到 BACKUP 机器上vi /etc/keepalived/nginx_check.sh#!/bin/bashA=`ps -C nginx –no-header |wc -l`if [ $A -eq 0 ];then/usr/local/nginx/sbin/nginxsleep 2if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then    killall keepalivedfifi#赋权限chmod +x /etc/keepalived/nginx_check.sh#启动 两台Keepalivedservice keepalived start#访问虚拟IP192.168.198.111 # Welcome to nginx! 1######################### HA测试 ##########################由于我们写了一个自动启动nginx的脚本再keepalived中，故关闭时，先关闭keepalived，再关闭nginx192.168.198.98service keepalived stopnginx -s stop#再次访问192.168.198.111查看变化 Welcome to nginx! 2192.168.198.98service keepalived start #由于有启动nginx的脚本，故省去启动nginx的操作#再次访问192.168.198.111查看变化 Welcome to nginx! 1复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Nginx高并发处理原理"><a href="#Nginx高并发处理原理" class="headerlink" title="Nginx高并发处理原理"></a>Nginx高并发处理原理</h1><blockquote><p>高并发一般是由多进程、多线程和异步机制来处理的，而正好nginx采用了这三种有效的处理高并发的方式。</p></blockquote><h2 id="Nginx的进程模型"><a href="#Nginx的进程模型" class="headerlink" title="Nginx的进程模型"></a>Nginx的进程模型</h2><p>​        进程模型采用Master/Worker 方式。当 nginx 启动的时候，会创建一个 Master 进程，Master进程会根据nginx.conf配置文件中相应的配置项来fork出多个worker子进程去处理请求（怎么处理也是根据配置文件中相应的配置文件）。</p><p>​        Master进程负责管理Worker进程的生命周期、处理网络事件、接收外界信号等。由于Master进程可以fork出多个Worker进程，所以说Nginx是多进程的。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce7c164ede604616a69595aebdbd98c9~tplv-k3u1fbpfcp-watermark.image" alt="Cheney爱逼逼"></p><h2 id="Nginx的线程模型"><a href="#Nginx的线程模型" class="headerlink" title="Nginx的线程模型"></a>Nginx的线程模型</h2><p>​        线程模型是指worker进程用于接收和处理客户端请求。每个worker进程可以同时处理多个用户请求。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06b81665d16149b083a8e4b6b73069b7~tplv-k3u1fbpfcp-watermark.image" alt="Cheney爱逼逼"></p><h2 id="Nginx的异步处理模型"><a href="#Nginx的异步处理模型" class="headerlink" title="Nginx的异步处理模型"></a>Nginx的异步处理模型</h2><p>​        异步处理模式是指nginx处理请求的时候是采用I/O多路复用技术（select | poll | epoll 模型），即多个 I/O 可以复用一个进程。当 worker 进程接收到客户端的请求后，会调用服务端对其请求进行处理，如果没有立即得到响应结果， worker 进程没有阻塞，而是去处理其他请求，知道有请求被服务端处理完成并返回响应结果。</p><p>​        这里的 worker 进程默认就是采用 epoll 多路复用机制来对服务端进行处理的。当服务端返回响应结果时，回调 epoll 多路复用器，epoll 告知 worker 进程，worker 会挂起当前正在处理的线程，去获取响应结果返回客户端，完成后再去执行被挂起的线程。整个过程中不会出现等待的情况，所以理论上Ngnix的一个进程就可以处理无限数量的连接，而且无需轮询。</p><p>​        注：worker 进程接收客户端请求不是采用的 epoll 模型，而是互斥锁机制；只有对服务端的请求和响应采用的是 epoll 模型。 <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e470287e34dc46a5be745ec06b2ec54e~tplv-k3u1fbpfcp-watermark.image" alt="Cheney爱逼逼"></p><h1 id="Nginx的特点"><a href="#Nginx的特点" class="headerlink" title="Nginx的特点"></a>Nginx的特点</h1><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>一个nginx的默认并发量为1024，是因为默认一个woker进程，每个进程处理量为1024，故1*1024；但是，在硬件条件满足的条件下，nginx可以支持5~10w的并发量。具体做法如下：</p><pre class="line-numbers language-shell"><code class="language-shell">####################### 操作系统配置 start ########################查看当前会话中所有的linux核心配置，而我们只需要关注open file这项ulimit -a#查看linux系统的“进程最大可打开文件数的设置”，默认时1024ulimit -n#修改“进程最大可打开文件数的设置”vim /etc/security/limit.conf#添加下面两行soft nofile 65535 #应用软件级别限制的最大可打开文件数的限制hard nofile 65535 #操作系统级别限制的最大可打开文件数的限制#文件保存后不会马上生效，所以还得更改当前会话级别的配置ulimit -n 65535####################### 操作系统配置 end ############################################## nginx配置 start ########################修改nginx配置文件（下面两行）vim /src/local/nginx/conf/nginx.confuser root root;worker_processes 4;worker_rlimit_nofile 65535; #这行，看这里看这里#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events {    use epoll;    worker_connections 65535; #这行，看这里看这里}#热部署重新加载配置文件nginx -s reload####################### nginx配置 end ############################################## 验证配置是否正确 start ########################查看当前nginx进程信息ps -ef | grep nginxroot     103734      1  0 13:27 ?        00:00:00 nginx: master process nginxnobody   103735 103734  0 13:27 ?        00:00:00 nginx: worker processroot     105129   3066  0 14:50 pts/0    00:00:00 grep --color=auto nginx#注意，也是看open files这项cat /proc/103735/limits####################### 验证配置是否正确 start ############################################## max client计算方式 start #######################max client = worker_processes * worker_connections或max client = worker_processes * worker_connections / 4#第一种很好理解，进程数*每个进程并发数#第二种为什么要除以4呢？是因为在nginx官网有这么一段话Since a browser opens 2 connections by default to a server and nginx uses the fds (file descriptors) from the same pool to connect to the upstream backend。#就是说，浏览器会建立两条链接到nginx，而nginx也会建立两条链接到服务端，故就是4####################### max client计算方式 end #######################复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="低消耗"><a href="#低消耗" class="headerlink" title="低消耗"></a>低消耗</h2><p>一万个非活跃性链接，消耗内存仅暂用2.5M，故对于一般的dos攻击不受影响，但是ddos还是有问题。</p><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><p>可以在7*24小时不间断服务提供，进行版本和配置平滑升级</p><pre class="line-numbers language-shell"><code class="language-shell">#命令nginx -s reload####################### 命令过程解析 start #######################1、当上面的命令一执行，如果发现配置文件已更改，会创建一个新的主进程2、当前所有的worker进程不会再接收新的请求并把当前正在处理的请求执行完就关闭3、master主进程会创建新的worker进程来接收并处理新的请求####################### 命令过程解析 end #######################复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>之所以实现高可用，是因为在nginx中，woker都一个一个的进程，就算其中某个进程挂掉了，也对其他的进程没得影响，而且其他的进程会接替出问题的进程。</p><h2 id="高扩展"><a href="#高扩展" class="headerlink" title="高扩展"></a>高扩展</h2><p>由于nginx是模块化集成，故在我们使用中，缺少什么模块我们就安装什么模块（模块一般分为C语言扩展模块和Lua脚本扩展模块）</p><pre class="line-numbers language-shell"><code class="language-shell">#下载模块git clone https://github.com/agentzh/echo-nginx-module#放入指定位置mv echo-nginx-module-master /usr/local/nginx/echo-nginx-module#就用这个命令生成新的makefile./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --add-module=/usr/local/nginx/echo-nginx-module#编译（这里只需要make，一定不要执行make install，不然会被覆盖）make#备份原文件cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak#替换nginx二进制文件cp /usr/local/nginx/objs/nginx /usr/local/nginx/sbin/nginx#重新建立软连接，检测配置文件并平滑启动ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginxnginx -tnginx -s reload复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Nginx配置文件详解"><a href="#Nginx配置文件详解" class="headerlink" title="Nginx配置文件详解"></a>Nginx配置文件详解</h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4e952b5c973479a85295eda4fdf671d~tplv-k3u1fbpfcp-watermark.image" alt="Cheney爱逼逼"></p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h3><p>配置影响nginx的全局指令。包括：</p><ul><li>配置运行nginx的服务器用户组</li><li>worker process数</li><li>nginx进程</li><li>pid存放路径</li><li>错误日志存放路径</li><li>配置文件的引入</li></ul><h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3><p>配置影响nginx服务器或与用户的网络连接。包括：</p><ul><li>设置网络连接的序列化（惊群）</li><li>是否允许同时接收多个网络连接</li><li>选择事件驱动模型</li><li>设置最大连接数</li></ul><h3 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h3><p>可以嵌套多个server模块，配置代理、缓存、日志定义等和第三方模块的配置。包括：</p><ul><li>定义MIMI-Type</li><li>自定义服务日志格式</li><li>允许sendfile方式传输文件</li><li>连接超时时间</li><li>单连接请求数上限</li></ul><h3 id="server块"><a href="#server块" class="headerlink" title="server块"></a>server块</h3><p>配置虚拟主机相关参数。包括：</p><ul><li>配置网络监听</li><li>配置基于名称的虚拟主机</li><li>配置基于IP的虚拟主机</li></ul><h3 id="location块"><a href="#location块" class="headerlink" title="location块"></a>location块</h3><p>配置请求的路由，以及页面和其他静态资源的处理。包括：</p><ul><li>location配置</li><li>请求根目录配置更改</li><li>URL</li><li>网站默认首页配置</li></ul><h3 id="配置清单例析"><a href="#配置清单例析" class="headerlink" title="配置清单例析"></a>配置清单例析</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd998aa92614417f8b1b9db6302bc738~tplv-k3u1fbpfcp-watermark.image" alt="Cheney爱逼逼"></p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="配置文件一"><a href="#配置文件一" class="headerlink" title="配置文件一"></a>配置文件一</h3><pre class="line-numbers language-shell"><code class="language-shell">########### 每个指令必须有分号结束 ##################user administrator administrators;  #配置用户或者组，默认为nobody nobody。#worker_processes 2;  #允许生成的进程数，默认为1#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emergevents {    accept_mutex on;  #设置网路连接序列化，防止惊群现象发生，默认为on    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off    #use epoll;  #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport    worker_connections  1024;  #最大连接数，默认为512}http {    include       mime.types;  #文件扩展名与文件类型映射表    default_type  application/octet-stream;  #默认文件类型，默认为text/plain    #access_log off;  #取消服务日志        log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for';  #自定义格式    access_log log/access.log myFormat;  #combined为日志格式的默认值    sendfile on;  #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。    upstream mysvr {         server 127.0.0.1:7878;      server 192.168.10.121:3333 backup;  #热备    }    error_page 404 https://www.baidu.com;  #错误页    server {        keepalive_requests 120;  #单连接请求上限次数。        listen       4545;  #监听端口        server_name  127.0.0.1;  #监听地址               location  ~*^.+$ {  #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。           #root path;  #根目录           #index vv.txt;  #设置默认页           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表           deny 127.0.0.1;  #拒绝的ip           allow 172.18.5.54;  #允许的ip                   }     }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置文件二"><a href="#配置文件二" class="headerlink" title="配置文件二"></a>配置文件二</h3><pre class="line-numbers language-shell"><code class="language-shell">#运行用户user nobody;#启动进程,通常设置成和cpu的数量相等worker_processes  1;#全局错误日志及PID文件#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;#工作模式及连接数上限events {    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,    #仅用于linux2.6以上内核,可以大大提高nginx的性能    use   epoll;     #单个后台worker process进程的最大并发链接数        worker_connections  1024;    # 并发总数是 worker_processes 和 worker_connections 的乘积    # 即 max_clients = worker_processes * worker_connections    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么    # 为什么上面反向代理要除以4，上面反向代理案例是有讲到    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000    # worker_connections 值的设置跟物理内存大小有关    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：    # $ cat /proc/sys/fs/file-max    # 输出 34336    # 32000 < 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置    # 使得并发总数小于操作系统可以打开的最大文件数目    # 其实质也就是根据主机的物理CPU和内存进行配置    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。    # ulimit -SHn 65535}http {    #设定mime类型,类型由mime.type文件定义    include    mime.types;    default_type  application/octet-stream;    #设定日志格式    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  logs/access.log  main;    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，    #对于普通应用，必须设为 on,    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，    #以平衡磁盘与网络I/O处理速度，降低系统的uptime.    sendfile     on;    #tcp_nopush     on;    #连接超时时间    #keepalive_timeout  0;    keepalive_timeout  65;    tcp_nodelay     on;    #开启gzip压缩    gzip  on;    gzip_disable "MSIE [1-6].";    #设定请求缓冲    client_header_buffer_size    128k;    large_client_header_buffers  4 128k;    #设定虚拟主机配置    server {        #监听80端口        listen    80;        #定义使用 www.nginx.cn访问        server_name  www.nginx.cn;        #定义服务器的默认网站根目录位置        root html;        #设定本虚拟主机的访问日志        access_log  logs/nginx.access.log  main;        #默认请求        location / {            #定义首页索引文件的名称            index index.php index.html index.htm;           }        # 定义错误提示页面        error_page   500 502 503 504 /50x.html;        location = /50x.html {        }        #静态文件，nginx自己处理        location ~ ^/(images|javascript|js|css|flash|media|static)/ {            #过期30天，静态文件不怎么更新，过期可以设大一点，            #如果频繁更新，则可以设置得小一点。            expires 30d;        }        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.        location ~ .php$ {            fastcgi_pass 127.0.0.1:9000;            fastcgi_index index.php;            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;            include fastcgi_params;        }        #禁止访问 .htxxx 文件        location ~ /.ht {            deny all;        }    }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置文件三"><a href="#配置文件三" class="headerlink" title="配置文件三"></a>配置文件三</h3><pre class="line-numbers language-shell"><code class="language-shell">worker_processes 8; #nginx进程数，建议设置为等于CPU总核心数.error_log /var/log/nginx/error.log info; #全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]pid /var/run/nginx.pid; #进程文件#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 65535;#工作模式与连接数上限events{　　#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。　　use epoll;　　#单个进程最大连接数（最大连接数=连接数*进程数）　　worker_connections 65535;}#设定http服务器http{    include mime.types; #文件扩展名与文件类型映射表    default_type application/octet-stream; #默认文件类型    #charset utf-8; #默认编码    server_names_hash_bucket_size 128; #服务器名字的hash表大小    client_header_buffer_size 32k; #上传文件大小限制    large_client_header_buffers 4 64k; #设定请求缓    client_max_body_size 8m; #设定请求缓    sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。    autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。    tcp_nopush on; #防止网络阻塞    tcp_nodelay on; #防止网络阻塞    keepalive_timeout 120; #长连接超时时间，单位是秒    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。    fastcgi_connect_timeout 300;    fastcgi_send_timeout 300;    fastcgi_read_timeout 300;    fastcgi_buffer_size 64k;    fastcgi_buffers 4 64k;    fastcgi_busy_buffers_size 128k;    fastcgi_temp_file_write_size 128k;    #gzip模块设置    gzip on; #开启gzip压缩输出    gzip_min_length 1k; #最小压缩文件大小    gzip_buffers 4 16k; #压缩缓冲区    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）    gzip_comp_level 2; #压缩等级    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。    gzip_vary on;    #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用    upstream blog.ha97.com {        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。        server 192.168.80.121:80 weight=3;        server 192.168.80.122:80 weight=2;        server 192.168.80.123:80 weight=3;    }    #虚拟主机的配置    server{        listen 80;　　　　#监听端口        server_name aa.cn www.aa.cn ; #server_name end  #域名可以有多个，用空格隔开        index index.html index.htm index.php;  # 设置访问主页        set $subdomain '';  # 绑定目录为二级域名 bbb.aa.com  根目录 /bbb  文件夹        if( $host ~* "(?:(\w+\.){0,})(\b(?!www\b)\w+)\.\b(?!(com|org|gov|net|cn)\b)\w+\.[a-zA-Z]+" ){             set $subdomain "/$2";         }        root /home/wwwroot/aa.cn/web$subdomain;# 访问域名跟目录          include rewrite/dedecms.conf; #rewrite end   #载入其他配置文件        location ~ .*.(php|php5)?$ {            fastcgi_pass 127.0.0.1:9000;            fastcgi_index index.php;            include fastcgi.conf;        }        #图片缓存时间设置        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ {    　　　　expires 10d;        }        #JS和CSS缓存时间设置        location ~ .*.(js|css)?$ {    　　　　expiresexpires 1h;        }    }    #日志格式设定    log_format access '$remote_addr - $remote_user [$time_local] "$request" '    '$status $body_bytes_sent "$http_referer" '    '"$http_user_agent" $http_x_forwarded_for';    #定义本虚拟主机的访问日志    access_log /var/log/nginx/ha97access.log access;    #对 "/" 启用反向代理    location / {        proxy_pass http://127.0.0.1:88;        proxy_redirect off;        proxy_set_header X-Real-IP $remote_addr;        #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        #以下是一些反向代理的配置，可选。        proxy_set_header Host $host;        client_max_body_size 10m; #允许客户端请求的最大单文件字节数        client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，        proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)        proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)        proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)        proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小        proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置        proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）        proxy_temp_file_write_size 64k;        #设定缓存文件夹大小，大于这个值，将从upstream服务器传    }    #设定查看Nginx状态的地址    location /NginxStatus {        stub_status on;        access_log on;        auth_basic "NginxStatus";        auth_basic_user_file conf/htpasswd;        #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。    }    #本地动静分离反向代理配置    #所有jsp的页面均交由tomcat或resin处理    location ~ .(jsp|jspx|do)?$ {        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_pass http://127.0.0.1:8080;    }    #所有静态文件由nginx直接读取不经过tomcat或resin    location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$ {        expires 15d;    }    location ~ .*.(js|css)?${        expires 1h;    }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置文件四"><a href="#配置文件四" class="headerlink" title="配置文件四"></a>配置文件四</h3><pre class="line-numbers language-shell"><code class="language-shell">######Nginx配置文件nginx.conf中文详解######定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /usr/local/nginx/logs/error.log info;#进程pid文件pid /usr/local/nginx/logs/nginx.pid;#指定进程可以打开的最大描述符：数目#工作模式与连接数上限#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。worker_rlimit_nofile 65535;events{ #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型 #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。 #补充说明： #与apache相类，nginx针对不同的操作系统，有不同的事件模型 #A）标准事件模型 #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll #B）高效事件模型 #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。 #Epoll：使用于Linux内核2.6版本及以后的系统。 #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。 #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。 worker_connections 65535; #keepalive超时时间。 keepalive_timeout 60; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 #分页大小可以用命令getconf PAGESIZE 取得。 #[root@web001 ~]# getconf PAGESIZE #4096 #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。 client_header_buffer_size 4k; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。 open_file_cache max=65535 inactive=60s; #这个是指多长时间检查一次缓存的有效信息。 #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息. open_file_cache_valid 80s; #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。 #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态. open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误. open_file_cache_errors on;}#设定http服务器，利用它的反向代理功能提供负载均衡支持http{ #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #服务器名字的hash表大小 #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小. server_names_hash_bucket_size 128; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。 client_header_buffer_size 32k; #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。 large_client_header_buffers 4 64k; #设定通过nginx上传文件的大小 client_max_body_size 8m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 sendfile on; #开启目录列表访问，合适下载服务器，默认关闭。 autoindex on; #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用 tcp_nopush on; tcp_nodelay on; #长连接超时时间，单位是秒 keepalive_timeout 120; #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_vary on; #开启限制IP连接数的时候需要使用 #limit_zone crawler $binary_remote_addr 10m; #负载均衡配置 upstream piao.jd.com {  #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。  server 192.168.80.121:80 weight=3;  server 192.168.80.122:80 weight=2;  server 192.168.80.123:80 weight=3;  #nginx的upstream目前支持4种方式的分配  #1、轮询（默认）  #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。  #2、weight  #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。  #例如：  #upstream bakend {  # server 192.168.0.14 weight=10;  # server 192.168.0.15 weight=10;  #}  #2、ip_hash  #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。  #例如：  #upstream bakend {  # ip_hash;  # server 192.168.0.14:88;  # server 192.168.0.15:80;  #}  #3、fair（第三方）  #按后端服务器的响应时间来分配请求，响应时间短的优先分配。  #upstream backend {  # server server1;  # server server2;  # fair;  #}  #4、url_hash（第三方）  #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。  #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法  #upstream backend {  # server squid1:3128;  # server squid2:3128;  # hash $request_uri;  # hash_method crc32;  #}  #tips:  #upstream bakend{#定义负载均衡设备的Ip及设备状态}{  # ip_hash;  # server 127.0.0.1:9090 down;  # server 127.0.0.1:8080 weight=2;  # server 127.0.0.1:6060;  # server 127.0.0.1:7070 backup;  #}  #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;  #每个设备的状态设置为:  #1.down表示单前的server暂时不参与负载  #2.weight为weight越大，负载的权重就越大。  #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误  #4.fail_timeout:max_fails次失败后，暂停的时间。  #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。  #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。  #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug  #client_body_temp_path设置记录文件的目录 可以设置最多3层目录  #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡 } #虚拟主机的配置 server {  #监听端口  listen 80;  #域名可以有多个，用空格隔开  server_name www.jd.com jd.com;  index index.html index.htm index.php;  root /data/www/jd;  #对******进行负载均衡  location ~ .*.(php|php5)?$ {   fastcgi_pass 127.0.0.1:9000;   fastcgi_index index.php;   include fastcgi.conf;  }  #图片缓存时间设置  location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ {   expires 10d;  }  #JS和CSS缓存时间设置  location ~ .*.(js|css)?$ {   expires 1h;  }  #日志格式设定  #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；  #$remote_user：用来记录客户端用户名称；  #$time_local： 用来记录访问时间与时区；  #$request： 用来记录请求的url与http协议；  #$status： 用来记录请求状态；成功是200，  #$body_bytes_sent ：记录发送给客户端文件主体内容大小；  #$http_referer：用来记录从那个页面链接访问过来的；  #$http_user_agent：记录客户浏览器的相关信息；  #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。  log_format access '$remote_addr - $remote_user [$time_local] "$request" '  '$status $body_bytes_sent "$http_referer" '  '"$http_user_agent" $http_x_forwarded_for';  #定义本虚拟主机的访问日志  access_log /usr/local/nginx/logs/host.access.log main;  access_log /usr/local/nginx/logs/host.access.404.log log404;  #对 "/" 启用反向代理  location / {   proxy_pass http://127.0.0.1:88;   proxy_redirect off;   proxy_set_header X-Real-IP $remote_addr;   #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;   #以下是一些反向代理的配置，可选。   proxy_set_header Host $host;   #允许客户端请求的最大单文件字节数   client_max_body_size 10m;   #缓冲区代理缓冲用户端请求的最大字节数，   #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。   #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误   client_body_buffer_size 128k;   #表示使nginx阻止HTTP应答代码为400或者更高的应答。   proxy_intercept_errors on;   #后端服务器连接的超时时间_发起握手等候响应超时时间   #nginx跟后端服务器连接超时时间(代理连接超时)   proxy_connect_timeout 90;   #后端服务器数据回传时间(代理发送超时)   #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据   proxy_send_timeout 90;   #连接成功后，后端服务器响应时间(代理接收超时)   #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）   proxy_read_timeout 90;   #设置代理服务器（nginx）保存用户头信息的缓冲区大小   #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小   proxy_buffer_size 4k;   #proxy_buffers缓冲区，网页平均在32k以下的设置   #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k   proxy_buffers 4 32k;   #高负荷下缓冲大小（proxy_buffers*2）   proxy_busy_buffers_size 64k;   #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长   #设定缓存文件夹大小，大于这个值，将从upstream服务器传   proxy_temp_file_write_size 64k;  }  #设定查看Nginx状态的地址  location /NginxStatus {   stub_status on;   access_log on;   auth_basic "NginxStatus";   auth_basic_user_file confpasswd;   #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。  }  #本地动静分离反向代理配置  #所有jsp的页面均交由tomcat或resin处理  location ~ .(jsp|jspx|do)?$ {   proxy_set_header Host $host;   proxy_set_header X-Real-IP $remote_addr;   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;   proxy_pass http://127.0.0.1:8080;  }  #所有静态文件由nginx直接读取不经过tomcat或resin  location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|  pdf|xls|mp3|wma)$ {   expires 15d;   }  location ~ .*.(js|css)?$ {   expires 1h;  } }}######Nginx配置文件nginx.conf中文详解#####复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置文件五"><a href="#配置文件五" class="headerlink" title="配置文件五"></a>配置文件五</h3><pre class="line-numbers language-shell"><code class="language-shell">user                              nobody nobody;   ## 指定运行用户和组worker_processes                  4;               ## 指定worker数量，建议此处autoworker_rlimit_nofile              51200;           ## 最大打开文件描述符error_log                         logs/error.log  notice;pid                               /var/run/nginx.pid;events {  use                             epoll;            ## 使用epoll事件驱动模型  worker_connections              51200;            ## 一个worker能处理的最大并发}http {  server_tokens                   off;              ## 隐藏nginx版本  include                         mime.types;          proxy_redirect                off;                ## 关闭代理重定向  proxy_set_header              Host $host;              proxy_set_header              X-Real-IP $remote_addr;  proxy_set_header              X-Forwarded-For $proxy_add_x_forwarded_for;  client_max_body_size          20m;                ## 设置客户端请求body的最大允许大小  client_body_buffer_size       256k;                 ## 设置客户端请求body的缓冲区大小  proxy_connect_timeout         90;                     ## 与后端服务器连接的超时时长  proxy_send_timeout            90;                    ## 把请求发送给后端服务器的超时时长  proxy_read_timeout            90;                    ## 等待后端服务器发送响应报文的超时时长  proxy_buffer_size             128k;                 ## 从代理服务器接收的响应的第一部分缓冲区  proxy_buffers                 4 64k;            ## 从代理服务器读取响应的缓冲区number和size  proxy_busy_buffers_size       128k;            ## 限制size在响应尚未完全读取时可能忙于向客户端发送响应的缓冲区总数  proxy_temp_file_write_size    128k;            ## 该指令设置缓冲临时文件的最大值  default_type                    application/octet-stream;  charset                         utf-8;        ## 字符集  client_body_temp_path           /var/tmp/client_body_temp 1 2;  ## 请求body临时目录  proxy_temp_path                 /var/tmp/proxy_temp 1 2;    ## 代理服务器接受数据临时目录  fastcgi_temp_path               /var/tmp/fastcgi_temp 1 2; ## FastCGI服务器接收临时目录   uwsgi_temp_path                 /var/tmp/uwsgi_temp 1 2; ## uwsgi 服务器接收临时目录  scgi_temp_path                  /var/tmp/scgi_temp 1 2; ##scgi服务器接收临时目录  ignore_invalid_headers          on;        ## 开启控制忽略具有无效名称的标头字段  server_names_hash_max_size      256;        ## 服务器名称哈希表的最大值  server_names_hash_bucket_size   64;        ## 服务器名称哈希表存储bucket大小  client_header_buffer_size       8k;        ## 设置缓冲区以读取客户端请求标头  large_client_header_buffers     4 32k;    ## 设置缓冲区以读取客户端请求标头最大值number和size  connection_pool_size            256;        ## 允许精确调整每个连接的内存分配  request_pool_size               64k;        ## 允许精确调整每个请求的内存分配  output_buffers                  2 128k;    ## 设置用于从磁盘读取响应的缓冲区number和size  postpone_output                 1460;        ## 客户端数据的传输最小值，单位字节  client_header_timeout           1m;        ## 定义读取客户端请求标头的超时时长  client_body_timeout             3m;        ## 定义读取客户端请求主体的超时时长  send_timeout                    3m;        ## 设置将响应传输到客户端的超时时长  log_format main                 '$server_addr $remote_addr [$time_local] $msec+$connection '                                  '"$request" $status $connection $request_time $body_bytes_sent "$http_referer" '                                  '"$http_user_agent" "$http_x_forwarded_for"';  open_log_file_cache               max=1000 inactive=20s min_uses=1 valid=1m;  access_log                      logs/access.log      main;  log_not_found                   on;  sendfile                        on;              tcp_nodelay                     on;        ## 启用长连接马上响应，提高性能  tcp_nopush                      off;        ## 关闭套接字选项  reset_timedout_connection       on;        ## 启用重置超时连接  keepalive_timeout               10 5;        ## 第一个参数设置长连接超时时长，第二个浏览器识别为keep-alive:timeout=5  keepalive_requests              100;        ## 设置可通过一个保持活动连接提供的最大请求数  gzip                            on;        ## 开启压缩  gzip_http_version               1.1;        ## 启用压缩时协议最小版本  gzip_vary                       on;           gzip_proxied                    any;        ## 为所有代理请求启用压缩  gzip_min_length                 1024;        ## 设置将被gzip压缩的响应的最小长度  gzip_comp_level                 6;        ## 设置压缩等级  gzip_buffers                    16 8k;    ## 设置用于压缩响应的缓冲区number和size  gzip_proxied                    expired no-cache no-store private auth no_last_modified no_etag;  gzip_types                      text/plain application/x-javascript text/css application/xml application/json;  gzip_disable                    "MSIE [1-6]\.(?!.*SV1)";  upstream tomcat8080 {    ip_hash;    server                        172.16.100.103:8080 weight=1 max_fails=2;    server                        172.16.100.104:8080 weight=1 max_fails=2;    server                        172.16.100.105:8080 weight=1 max_fails=2;  }  server {    listen                        80;    server_name                   www.chan.com;    # config_apps_begin    root                          /data/webapps/htdocs;    access_log                    /var/logs/webapp.access.log     main;    error_log                     /var/logs/webapp.error.log      notice;    location / {      location ~* ^.*/favicon.ico$ {        root                      /data/webapps;        expires                   180d;        ## 缓存180天        break;      }      if ( !-f $request_filename ) {        proxy_pass                http://tomcat8080;        break;      }    }    error_page                    500 502 503 504  /50x.html;    location = /50x.html {      root                        html;    }  }  server {    listen                        8088;    server_name                   nginx_status;    location / {      access_log                  off;      deny                        all;      return                      503;    }    location /status {      stub_status                 on;      access_log                  off;      allow                       127.0.0.1;      allow                       172.16.100.71;      deny                        all;    }  }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h2 id="全局模块下的-调优"><a href="#全局模块下的-调优" class="headerlink" title="全局模块下的 调优"></a>全局模块下的 调优</h2><pre class="line-numbers language-shell"><code class="language-shell"># 设置进程数worker_processes 2;# 设置内核数量以及进程使用内核情况worker_cpu_affinity 01 10;# 可打开最大文件数worker_rlimit_nofile 65535;复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p><strong>worker_processes</strong></p><p>​    worker的进程数，该值一般设置为CPU内核数，或者内核的整倍数。例：当前有2个4核的CPU，那么将worker_processes的值可以设置为8或16，也阔以设置为4。这个不仅仅取决于CPU内核数，也与磁盘数量和负载均衡模式有关系，在不知道怎么做的时候可以设置为auto。</p></li><li><p><strong>worker_cpu_affinity</strong></p><p>​    将worker进程与cpu内核进行绑定，该配置是以多位二进制数进行设置。例：如上配置的情况，代表四个内核，0代表关闭，1代表开启。</p><table><thead><tr><th>内核数量</th><th>worker_processes</th><th>worker_cpu_affinity</th><th>解释</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>0001 0010 0100 1000</td><td>每个进程各使用一个内核</td></tr><tr><td>2</td><td>4</td><td>01 10 01 10</td><td>4个进程交替使用两个内核</td></tr><tr><td>4</td><td>2</td><td>0101 1010</td><td>每个进程使用两个内核</td></tr><tr><td>4</td><td>4</td><td>0001 0010 0100 1000</td><td>每个进程各使用一个内核</td></tr></tbody></table></li><li><p><strong>worker_rlimit_nofile</strong></p><p>​    设置一个worker进程最大能打开的文件数。默认值与当前linux系统的设置的最大能打开的文件描述符一致。见上 《高并发》章节。</p></li></ol><h2 id="events模块下的调优"><a href="#events模块下的调优" class="headerlink" title="events模块下的调优"></a>events模块下的调优</h2><pre class="line-numbers language-shell"><code class="language-shell">events {    # 设置worker进程与客户端的连接方式（事件驱动模型）    use epoll;    # 设置worker进程最大的连接数，默认为512    worker_connections  1024;    # 设置网路连接序列化，防止惊群现象发生，默认为on    accept_mutex on;    accept_mutex_delay 500ms;    # 设置一个进程是否同时接受多个网络连接，默认为off    multi_accept on;}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p><strong>use</strong></p><p>​    设置worker进程与客户端连接的方式。而nginx支持多种连接方式，默认nginx会根据当前版本选择当前系统最高效的方式；而我们也阔以自行设定，该值可设置为select | poll | epoll | kqueue 等。这里涉及到 I/O 多路复用，在结尾来讲吧。</p></li><li><p><strong>worker_connections</strong></p><p>​    设置每个worker进程可以处理的最大并发数，该值不能超过 <strong>worker_rlimit_nofile</strong> 的值</p></li><li><p><strong>accept_mutex</strong></p><p>​    设置worker的接收互斥锁，当前所有空闲worker进程被放进了一个阻塞队列，等在新的连接来。如果开启：系统会创建一个互斥锁，而只有阻塞队列队首的worker进程可以获取锁，进而获得新的连接（预防惊群现象）；如果关闭：阻塞队列中所有的worker进程都会尝试获得新的连接，这就是惊群现象。</p></li><li><p><strong>multi_accept</strong></p><p>​    设置一个worker进程是否可以一次处理多个连接。如果开启：当多个新的连接来的时候，server会计算当前每个worker进程正在处理的连接数，选取一个最少的，将多个新的连接全交给他；如果关闭：当多个新的连接来的时候，server会根据负载均衡算法，依次将新的连接分配给当前处理连接最少的woker进程。</p></li></ol><h2 id="http模块下的调优"><a href="#http模块下的调优" class="headerlink" title="http模块下的调优"></a>http模块下的调优</h2><pre class="line-numbers language-shell"><code class="language-shell">http {    # 将当前目录(conf 目录)中的 mime.types 文件包含进来    include       mime.types;    # 对于无扩展名的文件，默认其为 application/octet-stream 类型，即 Nginx 会将其作为一个八进制流文件来处理    default_type  application/octet-stream;    # 设置请求与响应的字符编码    charset utf-8;    # 设置日志格式    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    # 开启访问日志，存放路径为logs/access.log，以log_format  main格式存放    access_log  logs/access.log  main;    log_format  postdata  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                                          ' $request_body'                      '"$http_user_agent" "$http_x_forwarded_for"';    # 设置为 on 则开启 Linux 系统的零拷贝机制，否则不启用零拷贝。当然，开启后是否起作用，要看所使用的系统版本。CentOS6 及其以上版本支持 sendfile 零拷贝。注意：如果图片显示不正常把这个改成off。    sendfile        on;    # 防止网络阻塞    tcp_nopush     on;    # 设置数据发送缓存    tcp_nodelay     on;    # 设置客户端与Nginx间所建立的长连接的生命超时时间，时间到达，则连接将自动关闭。单位秒    keepalive_timeout  65;    # 设置一个长连接发出最多的请求数    keepalive_requests  2000;    #开启gzip压缩    gzip  on;    # 设定请求缓冲    client_header_buffer_size    128k;    large_client_header_buffers  4 128k;    upstream api {        server 127.0.0.1:19090 weight=1;    }    # 虚拟主机    server {        listen       445 ssl;        server_name  localhost;        ssl_certificate /usr/local/nginx/conf/server.crt;        ssl_certificate_key /usr/local/nginx/conf/server.key;        location  ^~ /api/ {            #设置代理            proxy_set_header Host $host;            #proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_set_header X-Forwarded-Proto $scheme;            proxy_pass http://api/;        }        location /upfile/ {            root  /home/audit_files;            add_header Access-Control-Allow-Origin *;        }        error_page  404              /404.html;        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p><strong>sendfile</strong></p><p>​    设置为 on 则开启 Linux 系统的零拷贝机制，否则不启用零拷贝。当然，开启后是否起作用，要看所使用的系统版本。CentOS6 及其以上版本支持 sendfile 零拷贝。注意：如果图片显示不正常把这个改成 off。</p></li><li><p><strong>tcp_nopush</strong></p><p>​    设置是否将nginx的响应头单独发送，如果开启：则会以单独的形式发送nginx的响应头，而真实的响应体数据会在单独以数据包的形式发送；如果关闭：则会将nginx的响应头和真实的响应体数据一起发送，每个响应都会包含。</p></li><li><p><strong>tcp_nodelay</strong></p><p>​    设置数据发送缓存，如果开启：不设置数据发送缓存，适合传输小数据；如果关闭：开启数据发送缓存，如果传输图片等大文件，建议设置为 off。</p></li><li><p><strong>keepalive_timeout</strong></p><p>​    设置连接活跃时间，如果超时则断开连接。若设置为0，则表示禁止keepalive连接。如果传输的数据量小，且系统运算量很小，则可以将该值设置小一些；反之。</p></li><li><p><strong>keepalive_requests</strong></p><p>​    设置一个长连接发送请求的最大数。如果当前系统并发量大，而如果 该值 设置很小，则会导致keepalive_timeout 时间还未到，但是keepalive_requests上限已经到了。故我们需要根据真实系统并发量和连接活跃时间来设置该值。</p></li><li><p><strong>client_body_timeout</strong></p><p>​    设置客户端获取响应的超时时间。如果超时了 ，则认为请求失败。可根据此值得设置来做接口的简单小压测，并且 可设置一个合理的值，保证请求响应的最优。</p></li></ol><h1 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h1><p>以单独的文章来说明</p><h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><p>以单独的文章来说明</p><p>链接：<a href="https://juejin.im/post/6895660634466156558">https://juejin.im/post/6895660634466156558</a></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 异步 API、循环、日期，用好提高生产力</title>
      <link href="2020/11/09/java8new-api/"/>
      <url>2020/11/09/java8new-api/</url>
      
        <content type="html"><![CDATA[<h4 id="异步API"><a href="#异步API" class="headerlink" title="异步API"></a>异步API</h4><p>对于多任务耗时的业务场景，一般我们会用到线程异步处理,在以前我们用 Thread 或者 Runnable 来实现异步，这是oracle官方做法，不过缺点很明显</p><ul><li>对于复杂业务场景需要配置线程池</li><li>代码繁杂，对于新手容易造成不必要的bug</li><li>如果涉及到线程锁或线程通讯就棘手了</li></ul><p>现在，java8为我们提供了<code>CompletableFuture</code>类，可以完全解决以上问题。</p><p>主要方法有:</p><ul><li><code>runAsync()</code> 异步无参返回</li><li>样例:</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">asyncThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    CompletableFuture async1 <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"none return Async"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用get()将等待异步逻辑处理完成</span>    async1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>supplyAsync()</code> 异步有参返回</li><li>样例:</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">asyncThread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span> async2 <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String result <span class="token operator">=</span> async2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// String result2 = async2.get(5L, TimeUnit.SECONDS);</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>allOf()</code> 多个异步处理(针对有参返回)</li><li>样例：</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">asyncThread3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span> a <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span> b <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"youth"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span> c <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    CompletableFuture all <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">allOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    all<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String result <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span>c<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>CompletableFuture<span class="token operator">:</span><span class="token operator">:</span>join<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>anyOf()</code> 多个异步随机处理(针对有参返回)</p></li><li><p>样例</p></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">asyncThread4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span> a <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">try</span><span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token string">"none~"</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span> b <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"youth"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    CompletableFuture<span class="token operator">&lt;</span>String<span class="token operator">></span> c <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    CompletableFuture<span class="token operator">&lt;</span>Object<span class="token operator">></span> any <span class="token operator">=</span> CompletableFuture<span class="token punctuation">.</span><span class="token function">anyOf</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    String result <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>any<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环ForEach"><a href="#循环ForEach" class="headerlink" title="循环ForEach"></a>循环<code>ForEach</code></h4><p>java8 在原有<code>for</code>或<code>iterator</code>循环下又提供了 <code>forEach</code> 的方法，不过与for循环不同的是 <code>forEach</code> 循环是建立在<code>stream</code>之上的,而且比for或iterator方便的是，他可以循环<code>Map</code>对象，  如果您尝试配合filter处理就更赞了~</p><ul><li>forEach对List的循环样例</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listForeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> lst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"H"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"O"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>forEach对数组的循环 样例</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">arrForeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> strArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"A"</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">,</span><span class="token string">"D"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>strArr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>forEach对int范围的循环 样例</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">numericForeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            IntStream<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>forEach对Map的循环 样例:</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">mapForeach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> mps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>        <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">23.44F</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"e"</span><span class="token punctuation">,</span>11L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    mps<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>k<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String str <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="新的时间类-LocalDate、LocalDateTime"><a href="#新的时间类-LocalDate、LocalDateTime" class="headerlink" title="新的时间类(LocalDate、LocalDateTime)"></a>新的时间类(<code>LocalDate</code>、<code>LocalDateTime</code>)</h4><p>java8 之前我们处理时间 大多会涉及到这几个类<code>Date、SimpleDateFormat、Calendar</code> ，这种处理方式复杂、存在线程隐患、国际化困难、日期加减等处理麻烦等等。</p><p>现在有了 <code>LocalDate</code>、<code>LocalDateTime</code>、<code>DateTimeFormatter</code>生活就变得简单了~详情可以关注公众号Java技术栈搜索阅读这系列的教程。</p><ul><li>格式化及区域定义</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**设置格式化模板**/</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> DateTimeFormatter DATE_TIME_FORMATTER <span class="token operator">=</span> DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd HH:mm:ss.SSSS"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**设置日期时区常量**/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ZoneId CHINA_ZONE_ID <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Date格式化为DateTime</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**Date格式化为DateTime**/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dateToDateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDateTime dateTime <span class="token operator">=</span> date<span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span>CHINA_ZONE_ID<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLocalDateTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dateTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>LocalDate/LocalDateTime转Date</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**LocalDate/LocalDateTime转Date**/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">toDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// LocalDate</span>  LocalDate localDate <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Date d1 <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>localDate<span class="token punctuation">.</span><span class="token function">atStartOfDay</span><span class="token punctuation">(</span>CHINA_ZONE_ID<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// LocalDateTime</span>  LocalDateTime localDateTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Date d2 <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>localDateTime<span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span>CHINA_ZONE_ID<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInstant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>日期格式化</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**日期格式化**/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">formatDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>DATE_TIME_FORMATTER<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>日期加减</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**日期加减**/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">plusDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    LocalDateTime dateTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>CHINA_ZONE_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//天</span>    dateTime<span class="token operator">=</span>dateTime<span class="token punctuation">.</span><span class="token function">plusDays</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//时</span>    dateTime<span class="token operator">=</span>dateTime<span class="token punctuation">.</span><span class="token function">plusHours</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//分钟</span>    dateTime<span class="token operator">=</span>dateTime<span class="token punctuation">.</span><span class="token function">plusMinutes</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dateTime<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>DATE_TIME_FORMATTER<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>日期时间间隔</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**日期时间间隔**/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">betweenDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// LocalDateTime</span>    LocalDateTime startDate <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">07</span><span class="token punctuation">,</span><span class="token number">01</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDateTime endDate <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">07</span><span class="token punctuation">,</span><span class="token number">03</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Long withSecond <span class="token operator">=</span>  endDate<span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span>CHINA_ZONE_ID<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEpochSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startDate<span class="token punctuation">.</span><span class="token function">atZone</span><span class="token punctuation">(</span>CHINA_ZONE_ID<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEpochSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>withSecond<span class="token operator">/</span><span class="token number">60</span><span class="token operator">/</span><span class="token number">60</span><span class="token operator">/</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// LocalDate</span>    LocalDate startDate2 <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">07</span><span class="token punctuation">,</span><span class="token number">01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDate endDate2 <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">07</span><span class="token punctuation">,</span><span class="token number">03</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Long withSecond2 <span class="token operator">=</span>  endDate2<span class="token punctuation">.</span><span class="token function">toEpochDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startDate2<span class="token punctuation">.</span><span class="token function">toEpochDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>withSecond2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第一天and最后一天</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**第一天and最后一天**/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">theLastDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当月第一天</span>    LocalDateTime dateTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">07</span><span class="token punctuation">,</span><span class="token number">03</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dateTime <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span>TemporalAdjusters<span class="token punctuation">.</span><span class="token function">firstDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dateTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当月最后一天</span>    dateTime <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span>TemporalAdjusters<span class="token punctuation">.</span><span class="token function">lastDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dateTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//当月的第几天</span>    dateTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> dayOfMonth <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfMonth<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前周的第几天</span>    <span class="token keyword">int</span> dayOfWeek <span class="token operator">=</span> dateTime<span class="token punctuation">.</span><span class="token function">getDayOfWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OK，本次分享就到这里，如有谬误恳请指正~</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8 快速实现List转map 、分组、过滤等操作</title>
      <link href="2020/11/09/java8stream/"/>
      <url>2020/11/09/java8stream/</url>
      
        <content type="html"><![CDATA[<p>利用java8新特性，可以用简洁高效的代码来实现一些数据处理。定义1个Apple对象：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> BigDecimal money<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer num<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Apple</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> BigDecimal money<span class="token punctuation">,</span> Integer num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>money <span class="token operator">=</span> money<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加一些测试数据：</p><pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>Apple<span class="token operator">></span> appleList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存放apple对象集合</span>Apple apple1 <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"苹果1"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"3.25"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Apple apple12 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"苹果2"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"1.35"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Apple apple2 <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"香蕉"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"2.89"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Apple apple3 <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"荔枝"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token string">"9.99"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>appleList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>apple1<span class="token punctuation">)</span><span class="token punctuation">;</span>appleList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>apple12<span class="token punctuation">)</span><span class="token punctuation">;</span>appleList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>apple2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>List里面的对象元素，以某个属性来分组，例如，以id分组，将id相同的放在一起：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//List 以ID分组 Map&lt;Integer,List&lt;Apple>></span>Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Apple<span class="token operator">>></span> groupBy <span class="token operator">=</span> appleList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>Apple<span class="token operator">:</span><span class="token operator">:</span>getId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"groupBy:"</span><span class="token operator">+</span>groupBy<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">=</span><span class="token punctuation">[</span>Apple<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'苹果1'</span><span class="token punctuation">,</span> money<span class="token operator">=</span><span class="token number">3.25</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">,</span> Apple<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'苹果2'</span><span class="token punctuation">,</span> money<span class="token operator">=</span><span class="token number">1.35</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">=</span><span class="token punctuation">[</span>Apple<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'香蕉'</span><span class="token punctuation">,</span> money<span class="token operator">=</span><span class="token number">2.89</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">=</span><span class="token punctuation">[</span>Apple<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'荔枝'</span><span class="token punctuation">,</span> money<span class="token operator">=</span><span class="token number">9.99</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">40</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="List转Map"><a href="#List转Map" class="headerlink" title="List转Map"></a>List转Map</h4><p>id为key，apple对象为value，可以这么做：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * List -> Map * 需要注意的是： * toMap 如果集合对象有重复的key，会报错Duplicate key .... *  apple1,apple12的id都为1。 *  可以用 (k1,k2)->k1 来设置，如果有重复的key,则保留key1,舍弃key2 */</span>Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Apple<span class="token operator">></span> appleMap <span class="token operator">=</span> appleList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>Apple<span class="token operator">:</span><span class="token operator">:</span>getId<span class="token punctuation">,</span> a <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">,</span><span class="token punctuation">(</span>k1<span class="token punctuation">,</span>k2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>k1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">-</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">=</span>Apple<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'苹果1'</span><span class="token punctuation">,</span> money<span class="token operator">=</span><span class="token number">3.25</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">=</span>Apple<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'香蕉'</span><span class="token punctuation">,</span> money<span class="token operator">=</span><span class="token number">2.89</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">=</span>Apple<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'荔枝'</span><span class="token punctuation">,</span> money<span class="token operator">=</span><span class="token number">9.99</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">40</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="过滤Filter"><a href="#过滤Filter" class="headerlink" title="过滤Filter"></a>过滤Filter</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//过滤出符合条件的数据</span>List<span class="token operator">&lt;</span>Apple<span class="token operator">></span> filterList <span class="token operator">=</span> appleList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>a <span class="token operator">-</span><span class="token operator">></span> a<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"香蕉"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"filterList:"</span><span class="token operator">+</span>filterList<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">-</span><span class="token punctuation">[</span>Apple<span class="token punctuation">{</span>id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'香蕉'</span><span class="token punctuation">,</span> money<span class="token operator">=</span><span class="token number">2.89</span><span class="token punctuation">,</span> num<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h4><pre><code>//计算 总金额BigDecimal totalMoney = appleList.stream().map(Apple::getMoney).reduce(BigDecimal.ZERO, BigDecimal::add);System.err.println("totalMoney:"+totalMoney);  //totalMoney:17.48</code></pre><h4 id="查找流中最大-最小值"><a href="#查找流中最大-最小值" class="headerlink" title="查找流中最大 最小值"></a>查找流中最大 最小值</h4><pre class="line-numbers language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>Dish<span class="token operator">></span> maxDish <span class="token operator">=</span> Dish<span class="token punctuation">.</span>menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>      <span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">maxBy</span><span class="token punctuation">(</span>Comparator<span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span>Dish<span class="token operator">:</span><span class="token operator">:</span>getCalories<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>maxDish<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>Optional<span class="token operator">&lt;</span>Dish<span class="token operator">></span> minDish <span class="token operator">=</span> Dish<span class="token punctuation">.</span>menu<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>      <span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">minBy</span><span class="token punctuation">(</span>Comparator<span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span>Dish<span class="token operator">:</span><span class="token operator">:</span>getCalories<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>minDish<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Comparator<span class="token punctuation">.</span>comparingLong<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>Collectors<span class="token punctuation">.</span>collectingAndThen<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>Collectors<span class="token punctuation">.</span>toCollection<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 根据id去重</span>     List<span class="token operator">&lt;</span>Person<span class="token operator">></span> unique <span class="token operator">=</span> appleList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>                <span class="token function">collectingAndThen</span><span class="token punctuation">(</span>                        <span class="token function">toCollection</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token function">comparingLong</span><span class="token punctuation">(</span>Apple<span class="token operator">:</span><span class="token operator">:</span>getId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ArrayList<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/11/05/hello-world/"/>
      <url>2020/11/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
